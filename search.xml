<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub搜索开源项目技巧</title>
    <url>/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>本文主要介绍使用GitHub搜索栏时的搜索技巧，我们平时搜索时一般在在搜索栏中直接键入内容。<br>本文会介绍根据<strong>仓库名字，readme内容，description内容，star数，语言以及最近推送时间</strong>做限制条件来进行搜索。<br>首先以一个仓库的页面来介绍上述名字的意思<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic1.png" alt="spring_boot仓库界面"></p>
<span id="more"></span>
<p>接下来介绍在搜索框中的操作</p>
<h2 id="根据仓库名字进行搜索"><a href="#根据仓库名字进行搜索" class="headerlink" title="根据仓库名字进行搜索"></a>根据仓库名字进行搜索</h2><p><code>in:name spring boot</code>表示仓库的名字中带有spring boot</p>
<h2 id="根据readme内中的内容来进行搜索"><a href="#根据readme内中的内容来进行搜索" class="headerlink" title="根据readme内中的内容来进行搜索"></a>根据readme内中的内容来进行搜索</h2><p><code>in:readme 微服务</code>readme中含有“微服务”的仓库会被搜索</p>
<h2 id="根据description的内容来进行搜索"><a href="#根据description的内容来进行搜索" class="headerlink" title="根据description的内容来进行搜索"></a>根据description的内容来进行搜索</h2><p>description内容一般是对项目的简单描述，根据description来进行搜索会更加的准确<br><code>in:description spring boot stars:&gt;3000</code>表示在限定仓库描述中含有spring boot的同时，stars数大于3000</p>
<hr>
<h2 id="搜索时限定stars数"><a href="#搜索时限定stars数" class="headerlink" title="搜索时限定stars数"></a>搜索时限定stars数</h2><p><code>in:name spring boot stars:&gt;3000</code>表示在限定仓库名字中含有spring boot的同时，要求仓库的stars数大于3000</p>
<h2 id="搜索时限定语言"><a href="#搜索时限定语言" class="headerlink" title="搜索时限定语言"></a>搜索时限定语言</h2><p><code>in:description spring boot language:Java</code>在限定仓库的description中含有spring boot的同时，限定语言为Java来进行搜索</p>
<h2 id="搜索时限定最近推送时间"><a href="#搜索时限定最近推送时间" class="headerlink" title="搜索时限定最近推送时间"></a>搜索时限定最近推送时间</h2><p><code>in:description spring boot language:Java pushed:&gt;2019-09-03</code>搜索description中含有spring boot且使用Java语言，且最近一次更新时间在2019-09-03之前进行搜索。</p>
<hr>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><p>单独搜索spring boot<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic2.png" alt="pic2"><br>在description中搜索spring boot基础，可以看到spring boot官方那个仓库已被筛除<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic3.png" alt="pic3"><br>加上限制条件，stars数要求大于1000，可以看到上一张图的最后一个仓库被筛除了<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic4.png" alt="pic4"><br>再加上限制条件，要求最后一个push时间要晚于2019-01-01号，可以看到更新与18年的那个仓库被筛除了<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic5.png" alt="pic5"></p>
<p>本文完全参考了B站up主codesheep的视频，来源如下<a href="https://www.bilibili.com/video/BV1yJ411S7Wu?from=search&seid=13430377427568355855">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作</a><br>另，在github的advanced search中有更多的高级搜索选项。</p>
]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>2020北航，南大软院，计算所夏令营，北邮，西交人机所预推免记录</title>
    <url>/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="北航夏令营流程"><a href="#北航夏令营流程" class="headerlink" title="北航夏令营流程"></a>北航夏令营流程</h2><h3 id="大致情况"><a href="#大致情况" class="headerlink" title="大致情况"></a>大致情况</h3><p>北航夏令营一共就两天，节奏非常的快。有大约600个人入营，最后170人左右优营。600个人里，应该还有不少没有参加北航夏令营，去参加那天冲突的其他学校去了。</p>
<p>一共两部分，分为机考和面试。机考环节可以提交CSP考试成绩进行代替，只要累计排名前百分之50都可以提交。建议排名不是很高的话，可以考一下机试，今年的难度不是很大。</p>
<span id="more"></span>
<h3 id="机考部分"><a href="#机考部分" class="headerlink" title="机考部分"></a>机考部分</h3><p>机试语言为C++或C，允许使用STL。</p>
<p>第一题60分，和<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805407749357568">PAT A1064</a>几乎完全一样，除了题干描述，稍有不同，代码是完全相同的。主要是，考查二叉树的中序遍历顺序是有序的，和对一颗已知结构的二叉树进行中序遍历。</p>
<p>第二题40分，是一道模拟题，模拟函数调用的过程。题目给出了，push main, push sqr, push ABC, pop, pop, pop。这样一系列的压栈和弹栈的操作，来模拟函数调用。最后要求输出，压栈最深的函数，如本题中为ABC。以及它对应的调用函数的次数，调用次数和扇入数（关于扇入数，题干有充分的解释）。如果有多个函数深度相同，则所有情况都要输出。</p>
<p>我主要用了stl中的vector, set等来硬做，没有想到什么简便的技巧。</p>
<h3 id="面试部分"><a href="#面试部分" class="headerlink" title="面试部分"></a>面试部分</h3><p>面试部分。每人限时20分钟，老师问满20分钟，就会马上停止问下一位同学了。</p>
<p>今年的面试流程是，</p>
<p>第一部分思政题，应该是不计分的。我被问到的是，如何看待在这次疫情中我们国家制度的优越性？只要不偏离主旋律，正常答就行。</p>
<p>第二部分，英文问答。第一问，please briefly introduce yourself.背一下英文自我介绍就行。第二问，你擅长什么东西？请你具体的描述一下。</p>
<p>第三部分，数学问题两题（我复习的线代和概率论部分都没问到）。第一题，集合论，是否存在一个集合到其所有子集的元素的映射？（不知道描述，准不准确）。完全不会，说了半天还是不对。建议大家，不会就直接说不会，直接换题吧，可以节约下面试的时间。第二题，如果一个学校的学生，身高为随机变量X，那么其中一位同学的身高服从什么分布？（这个我也不太清楚，回答了根据中心极限定理，服从正态分布，不知道对不对）。老师，随后问，描述一下中心极限定理，我背了下教科书的定义，老师似乎没听懂，让我用更简单的语言讲一下，回答的不是很好。</p>
<p>第四部分，一般会根据你的成绩单和简历来问，如果你有优秀的论文和竞赛获奖的话，老师可能会问那方面，因为我没有，老师主要就是问的是成绩单。我是软件工程专业，请软件工程专业的同学一定好好复习软件工程，网上各个学校往年面试经验里有很多高频的问题（1.软件工程和计算机科学的区别 2.描述一下软件的开发的过程 3.常见的软件声明周期的模型，瀑布模型和快速原型的模型的区别在哪？）。</p>
<p>第一问，考的很高的课全都没问，直接问了考了最差的那门课，软件工程相关的那门课学了什么？</p>
<p>第二问，描述一下软件的开发的过程？</p>
<p>第三问，瀑布模型和快速原型（敏捷开发）的模型的区别在哪？</p>
<p>第四问，除了维护阶段，软件生命周期的哪个阶段耗时最长？我回答，开发阶段，老师说是维护阶段，并让我回去好好查资料。</p>
<p>然后换了一位老师，开始问语言相关。第一问，Java和C的区别。（网上有很多，不能只回答面向对象，还有内存管理机制等等）。第二问，Java中的拷贝是什么意思？（完全没懂，胡乱回答了一下，老师反问我，是吗）。最后一位老师，询问简历内容，问了做的一个项目，自己是如何做的（如果本科没有做过什么项目，可以贴上自己平时上课的课程设计的作业，如果github有不少star的话，也可以贴上自己的github）。</p>
<p>面试分为两批，分为两天进行。每个人应该是随机的，同一学校的学生一般在同一天。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试结束之后，第二天公布入营名单。接着自己拿表，找愿意接收自己的老师签字。建议大家，如果简历比较优秀的话，在夏令营前提前联系好是最好的。如果，拿到入营资格后，再选老师的话，建议多群发。因为很多老师是不会回你邮件的。还有老师答应面试和联系你，结果你等了他几天的时间，他又突然不和你联系，或者告知你名额已经满了的现象也是非常常见的。所以，我建议一定要群发，老师3个小时不回邮件，估计是永远不会回你了。如果没有找到心仪的老师，可以提交空表。只要开学前，找到愿意接收你的老师都可以。但是，我觉得要小心，也有可能老师口头答应了你，却又突然反悔的现象。这还是挺常见的，大家还是多加注意。如果开学前没有找到老师，学院会为你进行分配，可能就不是你想继续读的方向了。所以，多报几个学校也是必要的，学校内换导师很难，但是换学校还是可以的。</p>
<h2 id="南大软院夏令营流程"><a href="#南大软院夏令营流程" class="headerlink" title="南大软院夏令营流程"></a>南大软院夏令营流程</h2><h3 id="大致情况-1"><a href="#大致情况-1" class="headerlink" title="大致情况"></a>大致情况</h3><p>今年，南大软院入营的人数非常多。有700多个人入营，第一轮机试筛选之后，还剩下180个人左右。一切消息通过QQ群通知，邮件中也强调要尽快联系导师。</p>
<h3 id="机试部分"><a href="#机试部分" class="headerlink" title="机试部分"></a>机试部分</h3><p>机试是采用南大的慕测平台，可以采用任意语言。机试时间为两个小时，五道题，一共500分。分几批参加测试，每个人的题目都不一样，题目的类型与leetcode类型相同。注意，每行答案输出末尾要加回车，不然会报presentation error。还有就是，今年线上考试，不允许使用本地IDE，只允许在南大开发的慕测平台上，在输入框内手敲代码。（没有自动补全，没有控制台输出，只会报提交的编译错误）。但是在提交代码之后，可以立即看到自己代码的得分。</p>
<p><img src="/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/%E6%88%AA%E5%B1%8F2020-11-20%2019.40.59.png" alt="截屏2020-11-20 19.41.12"></p>
<p><img src="/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/%E6%88%AA%E5%B1%8F2020-11-20%2019.41.12.png" alt="截屏2020-11-20 19.40.59"></p>
<h3 id="面试部分-1"><a href="#面试部分-1" class="headerlink" title="面试部分"></a>面试部分</h3><p>机试通过之后，将近一个多星期才出面试分组。也是每组形式不太一样，有的时间长，有的时间短。我的面试时间大概是5分钟，一个是英文自我介绍，再一个是老师会让你介绍一下你最熟悉的一个项目，并提一些简单的问题。</p>
<h3 id="老师选择"><a href="#老师选择" class="headerlink" title="老师选择"></a>老师选择</h3><p>南大软院的组比较少，在软院官网上可以看到，多数偏向开发方向。一般老师要求大四跟着进行毕设，研一研二出成果，研三会允许实习。适合想选择就业的同学。值得注意的是，今年南大专硕是不提供宿舍的。</p>
<h2 id="计算所vipl智信夏令营流程"><a href="#计算所vipl智信夏令营流程" class="headerlink" title="计算所vipl智信夏令营流程"></a>计算所vipl智信夏令营流程</h2><p>计算所联系老师还是比较重要的，老师和实验室决定的权力比较大。我只参加了智信实验室，竞争比较大。</p>
<h3 id="笔试加机试部分"><a href="#笔试加机试部分" class="headerlink" title="笔试加机试部分"></a>笔试加机试部分</h3><p>今年计算所进了非常多西电的学生，如果想去计算所的西电的同学，建议一定要好好复习线代，概率论，高等数学的知识，笔试会考。</p>
<p>我在vipl的笔试就没有通过，当时也没有保存题目。</p>
<p>数学基础知识 考试时间一小时，主要为基础的线性代数，概率论和高等数学的知识。</p>
<p>算法 考试时间30分钟。 涉及算法与分析部分课程内容，主要为基础算法，部分动态规划的内容，以及让你设计算法。</p>
<p>研究方法基础知识 30分钟 主要为计算机视觉方面的基础知识（虽然我都不太会，感兴趣的同学建议大三打好机器学习和视觉方面的知识）</p>
<p>综合能力测试 20分钟 主要为脑筋急转弯类，和找规律。比如说，移动一根火柴棒使得等式成立，给出一组数字，找出下一个数类似的。（这种网上可能会有不少，平时没训练过，当场纯靠灵感。）</p>
<p>下午为机试 考试时间1小时，可以选择python和纯C。C语言必须使用微软的VS作为IDE，不然不满足他的试题包。试题比较简单，分为两类题型。第一种程序填空，第二种是常见oj类型。</p>
<h3 id="北邮预推免"><a href="#北邮预推免" class="headerlink" title="北邮预推免"></a>北邮预推免</h3><p>北邮没有夏令营，在暑假的时候就可以自己联系北邮的老师，老师的权力比较大，之后每个组会自行组织面试。</p>
<p>我联系老师的时间比较迟，几乎保研快结束了。老师临时多出一个专硕名额联系了我。面试问题，介绍你自己。根据简历提问。然后询问是否有计算机类比赛或者获奖。然后是算法题考查，我是和老师一对一腾讯会议共享桌面的。考查了现场写二分查找元素，upper_bounder，由于很长时间没做算法题了，我没能一下子写出来。老师人比较好，给我很长的时间调试程序。</p>
<p>然后是，给出一篇英文paper的摘要，然后要求读一遍，之后翻译每一句话。一般是为老师相关方向的简单论文或者这方面比较经典的论文，并不是很难。需要对相关专业词汇有一定的熟悉。</p>
<p>最后询问你现在的保研状态如何，未来研究生的规划是怎么样的（感觉老师比较喜欢，自己有明确想干什么方向，然后要发论文的学生）。你为什么要读研？（我回答了，为了提升自己和锻炼自己的能力，感觉老师不是很满意。大家最好回答，对科研有浓厚的兴趣，一心想科研之类）。</p>
<h2 id="西交人工智能学院预推免"><a href="#西交人工智能学院预推免" class="headerlink" title="西交人工智能学院预推免"></a>西交人工智能学院预推免</h2><p>感觉西交人工智能学院比较重视title，初筛都是211往上。</p>
<p>西交人机所采取的是群面的机制，5，6个老师面5，6个学生。依次会让每一个人进行自我介绍，自我介绍的时候，老师会看你在网站上填写的简历信息。之后，老师会对简历中有兴趣点的进行提问。我那组有几个西交的学生，老师对自己的学生感兴趣的问题比较多。群面一定要多多展示自己，不要就说一点点话，该吹还是吹，并没有问技术细节的东西。</p>
<p>问了我，你的动手能力怎么样？我就说了一点，凉凉。</p>
<h2 id="哈工大深圳预推免"><a href="#哈工大深圳预推免" class="headerlink" title="哈工大深圳预推免"></a>哈工大深圳预推免</h2><p>我只参加了笔试部分，笔试考的范围很广。基本为选择题和判断题，有人考了一两个填空题。主要考察范围，离散数学，数据库，操作系统，计算机网络。题目可以自行搜索，我记得CSDN有人上传。</p>
<p>哈工大深圳对预推免举行了好几轮的笔试和面试，每一轮排在前面的同学有机会进入面试。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后给大家推荐计算机保研交流群（605176069）。</p>
]]></content>
  </entry>
  <entry>
    <title>ITK-SNAP使用方法简介</title>
    <url>/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>最近在准备毕设，基于CT影像来对胃癌肿瘤进行分割。首先要打开<code>.nii</code>格式的CT影像。在软件选择方面，简单查阅后了解到，可以使用ITK-SNAP，MITK（貌似是VTK和ITK的综合），Pairs（一个国内开发的软件，在导师朋友圈里看到，还没有下）。</p>
<h2 id="几种医学影像文件的格式"><a href="#几种医学影像文件的格式" class="headerlink" title="几种医学影像文件的格式"></a>几种医学影像文件的格式</h2><p><a href="https://www.jiqizhixin.com/articles/2017-07-31">使用深度学习进行医疗影像分析：文件格式篇</a></p>
<p><a href="https://wenku.baidu.com/view/0660f81e48d7c1c708a14579.html">常见医学图像格式</a></p>
<span id="more"></span>
<p>针对常见医学影像格式，我参照了上面的两篇文章。DICOM和NIFTI（.nii文件）是最常见的两种格式。据我自己的理解，这两种格式的主要差别为，NIFTI是包含头文件和一个图像文件，而且图像是三维的。DICOM是文件头部，以及每层的二维图像都存储为一个单独的文件。</p>
<h2 id="ITK-SNAP软件的简单使用"><a href="#ITK-SNAP软件的简单使用" class="headerlink" title="ITK-SNAP软件的简单使用"></a>ITK-SNAP软件的简单使用</h2><p>ITJ-SNAP文件的官网为<a href="http://www.itksnap.org/pmwiki/pmwiki.php?n=Main.HomePage">http://www.itksnap.org/pmwiki/pmwiki.php?n=Main.HomePage</a>选择右上角DOWNLOADS即可下载，支持windows,Macos和Linux三大平台。</p>
<p>其中官方的文档为<a href="http://www.itksnap.org/pmwiki/pmwiki.php?n=Documentation.SNAP3">http://www.itksnap.org/pmwiki/pmwiki.php?n=Documentation.SNAP3</a></p>
<h3 id="调整以及查看图像信息"><a href="#调整以及查看图像信息" class="headerlink" title="调整以及查看图像信息"></a>调整以及查看图像信息</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.05.17.png" alt="截屏2021-03-29 23.05.17"></p>
<p>调整窗宽窗位，level与windows，即大于max均为max的值，小于min均为min的值<img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.05.56.png" alt="截屏2021-03-29 23.05.56"></p>
<p>查看图像信息，箭头1 Dimensions，表示x方向有512张图片，y方向有512张图片，z方向有60张图片 </p>
<p>箭头2Voxel Spacing表示，一个体素，x方向代表0.7031毫米，其余方向类似</p>
<p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.13.06.png" alt="截屏2021-03-29 23.13.06"></p>
<h3 id="工具栏1——十字架"><a href="#工具栏1——十字架" class="headerlink" title="工具栏1——十字架"></a>工具栏1——十字架</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.17.02-7031098.png" alt="截屏2021-03-29 23.17.02"></p>
<p>按照他提示中的功能：左键移动十字，右键并进行拖拽可以进行放大缩小（zoom），option键+鼠标左键可以平移（pan）图像，滚动鼠标滚轮查看不同的slices</p>
<p>左侧面板中的<code>cursor position</code>可以查看当前十字在三维中的位置。<code>Intensity under cursor</code>显示当前灰度值的强度，如果当前图像有标注的话，<code>Label under cursor</code>可以显示是哪一种标注</p>
<h3 id="套索工具"><a href="#套索工具" class="headerlink" title="套索工具"></a>套索工具</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.27.57.png" alt="截屏2021-03-29 23.27.57"></p>
<p>这个套索工具的功能和photoshop中的几种套索功能几乎是完全一样的。</p>
<p><code>Smooth curve</code>模式，用连续的曲线勾画一个选区。</p>
<p><code>Polygon</code>模式，用鼠标左边的点击不断的选择点，最后勾画出选区。</p>
<p><code>Invert polygon</code>反转当前的选区</p>
<h3 id="画笔工具"><a href="#画笔工具" class="headerlink" title="画笔工具"></a>画笔工具</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.31.29.png" alt="截屏2021-03-29 23.31.29"></p>
<p>这个画笔和photoshop的魔术棒那一栏工具很相似，特别是最后一个画笔风格。按照他的说明，鼠标左键勾画选区，鼠标右键擦除选区。</p>
<p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.44.26.png" alt="截屏2021-03-29 23.44.26"></p>
<p>他提供了三种笔刷的格式，前两种只是形状不一样，一个正方形一个是圆形。</p>
<p><code>Brush Options</code>中的选项，<code>3D</code>代表，不止在当前这一个slices中建立选区，其他图层中也会建立选区。<em>但是3d功能，有一个坏处，他在每一个图层中的选区是一样的，而器官在不同的CT切片上是会变化的。</em><code>Cursor chases brush</code>在移动画笔时，十字也会跟着移动，这样在四个视图的情况下会比较有用。<code>Isotropic</code>的功能不是很清楚。</p>
<p>第三种笔刷是自适应的笔刷，类似photoshop中的魔术棒。他有两个特别的参数。Granularity类似容忍度，考虑当前灰度与周围灰度的差异。Smoothness确定了画笔的光滑度。</p>
<p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.52.02.png" alt="截屏2021-03-29 23.52.02"></p>
<h3 id="对标记进行管理"><a href="#对标记进行管理" class="headerlink" title="对标记进行管理"></a>对标记进行管理</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.58.26.png" alt="截屏2021-03-29 23.58.26"></p>
<p>箭头1——进行标记管理</p>
<p>箭头2——在3D窗口隐藏红色标记1</p>
<p>箭头3——在所有窗口隐藏红色标记2</p>
<p>箭头4——删除当前的标记</p>
<h3 id="其余小功能介绍"><a href="#其余小功能介绍" class="headerlink" title="其余小功能介绍"></a>其余小功能介绍</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-30%2000.02.55.png" alt="截屏2021-03-30 00.02.55"></p>
<p>箭头1——全屏显示当前角度</p>
<p>箭头2——更新3D图像</p>
<p>箭头3——调整label的不透明度</p>
<h3 id="如何载入已经标注好的label"><a href="#如何载入已经标注好的label" class="headerlink" title="如何载入已经标注好的label"></a>如何载入已经标注好的label</h3><p>可以直接将文件拖拽到ITK-SNAP的页面，选择load as segmentation</p>
<p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-30%2000.08.17.png" alt="截屏2021-03-30 00.08.17"></p>
<p>也可以选择load as additional image来和当前的图片进行一个比较</p>
]]></content>
  </entry>
  <entry>
    <title>LaTex在毕设论文中的简单使用</title>
    <url>/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近毕设论文准备利用LaTex模板来写，因此介绍一些LaTex的基础使用知识。（本篇的软件的使用均基于Mac os）。Windows下可以安装官方软件TexLive，Mac os可以安装官方软件MacTex 2019，也可以使用vscode或Texpad来进行LaTeX的书写。<br>如果你不愿意下载软件的话，也可以使用在线网站，overleaf来进行LaTeX的书写。</p>
<span id="more"></span>

<h2 id="LaTex的配置"><a href="#LaTex的配置" class="headerlink" title="LaTex的配置"></a>LaTex的配置</h2><h3 id="通过Vscode进行LaTex的书写（方法一）"><a href="#通过Vscode进行LaTex的书写（方法一）" class="headerlink" title="通过Vscode进行LaTex的书写（方法一）"></a>通过Vscode进行LaTex的书写（方法一）</h3><p>首先在Vscode的扩展市场中，下载两个插件LaTex Workshop，LTex。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic1.png" alt="两个扩展" title="两个扩展"><br>接着点击左下角的管理齿轮，选择设置（也可以使用<u>command + ,</u>)，点击右上角所示符号，进入json格式的配置。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic2.png" alt="vscode配置页面" title="vscode配置页面"></p>
<p>将以下配置粘入json配置文件的两个大括号之间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latex-workshop.latex.tools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-pdf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,          </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"><span class="string">&quot;latex-workshop.latex.recipes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex&quot;</span>,  </span><br><span class="line">          <span class="string">&quot;tools&quot;</span>: [  </span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,  </span><br><span class="line">          ]  </span><br><span class="line">        &#125;  </span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;latex-workshop.view.pdf.viewer&quot;</span>: <span class="string">&quot;browser&quot;</span>,  </span><br><span class="line"><span class="string">&quot;latex-workshop.latex.clean.fileTypes&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.out&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    ],</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这段是语法检查模块</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="string">&quot;ltex.enabled&quot;</span>: <span class="literal">true</span>, <span class="comment">// 设置语言，这里是德语</span></span><br><span class="line"><span class="comment">// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，新建一个文件夹（如latex_tutoial），用来测试Latex的书写。新建hello_world.tex文件，输入一个基本的LaTeX代码.</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">    Hello World</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<p>在新建一个.tex文件之后，vscode左侧边栏会出现图示Tex选项，点击该选项，选择Build LaTex project-&gt;Recipe xelatex。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic3.png" alt="vscode页面截图" title="pic3"><br>编译完成之后，latex_tutoial文件夹会出现编译生成的文件。接着选择uild LaTex project-&gt;Clean up auxiliary files。可以清除编译生成的多余的文件。<br>点击右上键的预览按钮，可以预览latex对应生成的pdf文件。</p>
<h3 id="通过付费软件Texpad来进行LaTex的书写（方法二）"><a href="#通过付费软件Texpad来进行LaTex的书写（方法二）" class="headerlink" title="通过付费软件Texpad来进行LaTex的书写（方法二）"></a>通过付费软件Texpad来进行LaTex的书写（方法二）</h3><p>Texpad为Mac上的付费软件。它有着更为简洁的页面，以下标注出几个重点区域。软件其他按键区域，在鼠标悬停时有相应的中文提示。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic4.png" alt="Texpad页面" title="Texpad页面"></p>
<p>以上内容参考了B站视频<a href="https://www.bilibili.com/video/BV1eQ4y1M7rQ">mac系统下LaTex快速配置与各种使用技巧</a></p>
<h2 id="LaTex的基本语法"><a href="#LaTex的基本语法" class="headerlink" title="LaTex的基本语法"></a>LaTex的基本语法</h2><p><code>待续。。。</code></p>
]]></content>
      <tags>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中赋值,浅拷贝,深拷贝理解</title>
    <url>/2021/07/25/Python%E4%B8%AD%E8%B5%8B%E5%80%BC-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文对查阅的相关资料做一个简单的总结，方便日后方便时查阅。  </p>
<p>首先，明确两个概念 <em>“可变对象类型”</em> 和 <em>不可变对象类型</em>。参考<a href="https://www.jianshu.com/p/b3157c9751d0">https://www.jianshu.com/p/b3157c9751d0</a>。可变对象类型，包括列表，字典，集合。不可变对象类型，包括元组，整形，浮点型，字符串。<br>对于可变对象，对对象内部的值进行改变时，对象的内存地址不会发生改变。（变量，也就是标签指向的内存地址，任然没有改变）如下： </p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; a.append(4)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br></pre></td></tr></table></figure>

<p>对于不可变对象，对象的值发生改变时。创建了一块新的内存，标签（变量名）指向这块新的内存。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>在了解赋值之前，先解释Python中的”is”与”==”<br>a is b 实际就是判断 id(a)与id(b)是否相同<br>a == b 判断a与b的值是否相同<br>如下例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; c = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(b)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(c)</span><br><span class="line">140305477663816</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is c</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a == c</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>赋值部分参考了<a href="https://www.jianshu.com/p/521bdd67790e">https://www.jianshu.com/p/521bdd67790e</a><br>先说一下结论:  </p>
<blockquote>
<p>1）<strong>“变量B=变量A”</strong>（变量A肯定已经指向某个对象了），对于变量之间的赋值，毫无悬念，两个变量最终指向同一个对象。<br>2）<strong>“变量A=对象”</strong>（如A = ‘python’），对于这种情况，如果对象在内存中不存在，那么将新建这个对象，然后将变量A指向该对象；如果对象已经存在了，那情况就稍微复杂了，部分情况是将变量指向原有的对象，部分情况会新建建一个对象（即使内存中已经有了一个值完全相同的对象），然后将变量指向这个新的对象！</p>
</blockquote>
<p>Python中的变量名，实际上为一个标签。每一个变量指向着内存中的一个对象。变量的类型、内存地址、值就是它指向对象的类型、内存地址、值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>该赋值语句做了三件事：1）开辟了一块内存（可用id(a)查看地址）；2）将该内存的值设为300；3）将变量a指向该内存。在重新将a指向其他对象之前，a就一直指向该内存，也就一直代表整数300。这里内存中的300是狭义“对象”，是个实实在在存在的东西。</p>
<h2 id="变量-对象"><a href="#变量-对象" class="headerlink" title="变量 = 对象"></a>变量 = 对象</h2><h3 id="赋值时，对象在内存中并不存在"><a href="#赋值时，对象在内存中并不存在" class="headerlink" title="赋值时，对象在内存中并不存在"></a>赋值时，对象在内存中并不存在</h3><p>这种情况只要遵循，开辟内存，将变量指向内存即可。</p>
<h3 id="赋值时，对象在内存中已经存在"><a href="#赋值时，对象在内存中已经存在" class="headerlink" title="赋值时，对象在内存中已经存在"></a>赋值时，对象在内存中已经存在</h3><p>这种情况，又要分变量类型来讨论。<u>具体情况请参考上述的参考链接。  </u><br>总结下来就是整型，在一定范围-5~256时，出现新的变量名时，会指向同一块内存区域。列表型，字典型，<strong>每次都开辟新的内存空间。</strong>元组型，除了空元组之外，每次也都开辟新的内存空间。  </p>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>拷贝参考了博客园的这篇文章<a href="https://www.cnblogs.com/eczhou/p/7860668.html">https://www.cnblogs.com/eczhou/p/7860668.html</a>，==写的非常好。==具体的示意图和解释，请移步该篇文章。</p>
<h3 id="赋值再解释"><a href="#赋值再解释" class="headerlink" title="赋值再解释"></a>赋值再解释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>总结：<strong>wilber is will，wilber[i] is will[i]</strong></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的几种情况：</p>
<ol>
<li>使用copy.copy()</li>
<li>使用切片[:]操作</li>
<li>使用工厂函数（如list/dir/set）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>总结: 浅拷贝换创建一个新的对象，也就是id(will)与id(willber)不同。<strong>wilber is not will，wilber[i] is will[i]</strong></p>
<h3 id="自己的一点补充"><a href="#自己的一点补充" class="headerlink" title="自己的一点补充"></a>自己的一点补充</h3><p>我觉得，一个改变，另一个跟着变。是因为该块内存区域，放置的是一个可变类型的对象。如果将此处标签指向其他内存块，做浅拷贝的对应地方并不会改变。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; a = [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; b = copy.copy(a)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; a[2] = 15</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 15]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝只有一种方式：使用copy.deepcopy()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>总结：对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）。<strong>wilber is not will，wilber[2] is not will[2]。</strong>因为特殊情况，wilber[0] is will[0];wilber[1] is will[1]</p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<br>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”<br>如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">books = (<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">coopies = copy.deepcopy(books)</span><br><span class="line"><span class="built_in">print</span>(books <span class="keyword">is</span> coopies)  <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">books = (<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>, [])</span><br><span class="line">coopies = copy.deepcopy(books)</span><br><span class="line"><span class="built_in">print</span>(books <span class="keyword">is</span> coopies)  <span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后引用文中的总结</p>
<blockquote>
<p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p>
</blockquote>
<ul>
<li>Python中对象的赋值都是进行对象引用（内存地址）传递</li>
<li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用<em>原始的引用.</em></li>
<li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li>
<li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li>
<li>如果元祖变量只包含原子类型对象，则不能深拷贝</li>
</ul>
<p>本文参考搬运了以下博客：<br><a href="https://www.jianshu.com/p/b3157c9751d0">https://www.jianshu.com/p/b3157c9751d0</a><br><a href="https://www.jianshu.com/p/521bdd67790e">https://www.jianshu.com/p/521bdd67790e</a><br><a href="https://www.cnblogs.com/eczhou/p/7860668.html">https://www.cnblogs.com/eczhou/p/7860668.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>markdown_writer</title>
    <url>/2020/09/09/markdown-writer/</url>
    <content><![CDATA[<h2 id="这是二级标题，front-matter里的值为一级标题"><a href="#这是二级标题，front-matter里的值为一级标题" class="headerlink" title="这是二级标题，front matter里的值为一级标题"></a>这是二级标题，front matter里的值为一级标题</h2><p>这是正文部分，如果想换行的话在每行后面敲两个空格再按回车<br>这是换行</p>
<p>如何换段落呢？如在第10行和第12行之间敲回车，这是换段落<br>第12行后面没有按回车，显示的是不换行的格式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">接下来<span class="emphasis">*这是斜体文字*</span>  </span><br></pre></td></tr></table></figure>

<p>接下来<em>这是斜体文字</em>  </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">接下来<span class="strong">**这是粗体文字**</span></span><br></pre></td></tr></table></figure>

<p>接下来<strong>这是粗体文字</strong></p>
<span id="more"></span>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">接下来 <span class="emphasis">* <span class="strong">**这是斜粗体文字**</span> *</span></span><br></pre></td></tr></table></figure>

<p>接下来**<em>这是斜粗体文字**</em></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是~~删除线~~</span><br></pre></td></tr></table></figure>

<p>这是<del>删除线</del></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是==高亮==</span><br></pre></td></tr></table></figure>

<p>这是==高亮==</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我是^上标^</span><br></pre></td></tr></table></figure>

<p>我是^上标^</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我是~下标~  </span><br></pre></td></tr></table></figure>

<p>我是<del>下标</del>  </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">下划线采用html语法<span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>hhh(command+u)<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>下划线采用html语法<u>hhh(command+u)</u></p>
<h2 id="这也是二级标题"><a href="#这也是二级标题" class="headerlink" title="这也是二级标题"></a>这也是二级标题</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">采取&lt;!--more--&gt;来隐藏本文中剩下的内容</span><br></pre></td></tr></table></figure>

<h3 id="如何建立列表"><a href="#如何建立列表" class="headerlink" title="如何建立列表"></a>如何建立列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表1</span><br><span class="line"><span class="bullet">2.</span> 列表2</span><br><span class="line"><span class="bullet">3.</span> 列表3</span><br><span class="line"><span class="bullet">   1.</span> 层次3.1</span><br><span class="line"><span class="bullet">      1.</span> 层次3.1.1</span><br></pre></td></tr></table></figure>

<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3<ol>
<li>层次3.1<ol>
<li>层次3.1.1</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="如何建立不带数字的列表"><a href="#如何建立不带数字的列表" class="headerlink" title="如何建立不带数字的列表"></a>如何建立不带数字的列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 列表1</span><br><span class="line"><span class="bullet">*</span> 列表2</span><br><span class="line"><span class="bullet">*</span> 列表3</span><br></pre></td></tr></table></figure>

<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
<h3 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">这是图片的替代文字</span>](<span class="link">markdown-writer/jienijieni.png &quot;这是图片的title&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/09/markdown-writer/jienijieni.png" alt="这是图片的替代文字" title="这是图片的title"></p>
<h3 id="如何进行latex公式的插入"><a href="#如何进行latex公式的插入" class="headerlink" title="如何进行latex公式的插入"></a>如何进行latex公式的插入</h3><p>快捷键command+m可以在文字中插入公式<br>快捷键command+两次m可以生成公式的段落，如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to \infin&#125;\frac&#123; sin(x) &#125; &#123; x &#125; = 1</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\lim_{x \to \infin}\frac{ sin(x) } { x } = 1<br>$$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 小红 | 小明 | 小白 |</span><br><span class="line">| :---- | :----: | ----: |</span><br><span class="line">| a    | b    | c    |</span><br><span class="line">| e    | f    | g    |</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">小红</th>
<th align="center">小明</th>
<th align="right">小白</th>
</tr>
</thead>
<tbody><tr>
<td align="left">a</td>
<td align="center">b</td>
<td align="right">c</td>
</tr>
<tr>
<td align="left">e</td>
<td align="center">f</td>
<td align="right">g</td>
</tr>
</tbody></table>
<h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个链接 [<span class="string">链接的描述，如百度</span>](<span class="link">www.baidu.com</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">www.baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这是一个链接 <a href="www.baidu.com">链接的描述，如百度</a></p>
<p>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p>
<h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如一段C++语言代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一段注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是<span class="emphasis">*斜体*</span>文字</span><br></pre></td></tr></table></figure>

<p>这是一个代码块<code>abcd 这是代码块</code></p>
<p>hexo中应该也能运用tag plugin来实现代码的添加  </p>
<figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用段落"><a href="#引用段落" class="headerlink" title="引用段落"></a>引用段落</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用</span></span><br><span class="line"><span class="quote">&gt; 22233344455</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一段引用<br>22233344455</p>
</blockquote>
<p>分隔线  </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器可视化和内网穿透</title>
    <url>/2021/11/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>很久没有更新博客了，开学两个多月一直太懒了，从大四的惰性大概延续了整整一年吧。<br>最近双十一在阿里云购置了一个100元3年的云服务器，简单介绍一下自己搜索的使用教程。  </p>
<h2 id="云服务器的可视化连接（VNC）"><a href="#云服务器的可视化连接（VNC）" class="headerlink" title="云服务器的可视化连接（VNC）"></a>云服务器的可视化连接（VNC）</h2><p>云服务器的可视化连接主要是参考了阿里云的这篇官方文档。<br><a href="https://help.aliyun.com/knowledge_detail/59330.html?spm=a2c6h.13066369.0.0.6b957f94089Pc8&userCode=28kqeewo">通过VNC搭建Ubuntu 18.04和20.04图形界面</a></p>
<span id="more"></span>

<h2 id="通过drp实现内网穿透"><a href="#通过drp实现内网穿透" class="headerlink" title="通过drp实现内网穿透"></a>通过drp实现内网穿透</h2><p>因为有在远端连接实验室电脑的需求，简单了解了一下frp的配置。首先要利用到具有公网ip的云服务器作为跳转，就可以访问在内网的实验室主机了。  </p>
<p>这是frp的官方文档<a href="https://gofrp.org/docs/examples/ssh/">通过 SSH 访问内网机器</a>  </p>
<ol>
<li><p>在服务器端（此处为阿里云），安装drps。在frp的github的release中，选择适合的版本的。我这里选择的是linux_amd64，右键复制链接。在合适的目录下，进行下载解压。或者手动下载和解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzvf frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> frp_0.38.0_linux_amd64 frp</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑服务器端的配置文件<code>frps.ini</code>。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure>

<p> 设置了 frp 服务器用户接收客户端连接的端口。<strong>记得在阿里云的安全组中，打开对应的端口</strong></p>
</li>
<li><p>启动服务器端。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来配置客户端，也就是要访问的远端服务器。下载解压重命名，同上操作，这里不再重复。</p>
</li>
<li><p>配置客服端文件<code>frpc.ini</code>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"> server_addr = x.x.x.x</span><br><span class="line"> server_port = 7000</span><br><span class="line"></span><br><span class="line"> [ssh]</span><br><span class="line"> <span class="built_in">type</span> = tcp</span><br><span class="line"> local_ip = 127.0.0.1</span><br><span class="line"> local_port = 22</span><br><span class="line"> remote_port = 6000</span><br></pre></td></tr></table></figure>

<p>frps 所在服务器的公网 IP 为 x.x.x.x。<br>local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。</p>
</li>
<li><p>启动客户端。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ssh -oPort=6000 test@x.x.x.x</code>.。通过访问，你设置的远端端口，即可访问到内网的主机。<strong>test为本机用户名，密码为本机密码!!</strong></p>
</li>
</ol>
<p>可以参考的b站配置视频<a href="https://www.bilibili.com/video/BV16441187zf">https://www.bilibili.com/video/BV16441187zf</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2020/08/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p>
<hr>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p>
<hr>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2>]]></content>
  </entry>
  <entry>
    <title>nnUnet的使用</title>
    <url>/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="开始的废话"><a href="#开始的废话" class="headerlink" title="开始的废话"></a>开始的废话</h2><p>刚放假的时候，满怀干劲的准备和师兄发一篇论文，准备用nnunet来跑一个baseline。虽然这篇论文现在黄了，但是好歹让我忙碌了一段时间，没有在假期一直浑浑噩噩，胡思乱想。在这里记录一下nnunet的主要流程和遇到的问题。</p>
<p>另外，使用nnunet并不需要看懂nnunet的论文。由于时间关系，我只看了一点点，可以直接根据作者的github仓库<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a>来做，不懂的地方可以提issue。作者回复的还是挺快的。</p>
<p>下面对github仓库中的内容，做一个简单的总结。</p>
<span id="more"></span>

<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>创建虚拟环境，安装pytoch（一般在pytorch官网选择自己想要的安装方式，conda， pip都是支持的，通常情况下pip的安装速度要快一点）</p>
</li>
<li><p>安装nnUnet，一般需要修改部分配置，选择第二种配置</p>
<p>For use as integrative <strong>framework</strong> (this will create a copy of the nnU-Net code on your computer so that you can modify it as needed)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/MIC-DKFZ/nnUNet.git</span><br><span class="line"><span class="built_in">cd</span> nnUNet</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据格式，以及在<code>~/.bashrc</code>中设置三个环境变量</p>
</li>
<li><p>可选步骤，输出拓扑图</p>
</li>
</ol>
<p>安装pytorch和nnunet算是非常简单了，在conda中可能需要换源（需要用到清华的镜像），在用git克隆仓库时，可能需要能够比较顺畅的连接github。下面，着重讲一下开始的阶段最耗时的第一步，将数据预处理为nnunet所需要的命名格式。</p>
<h3 id="nnUnet数据格式"><a href="#nnUnet数据格式" class="headerlink" title="nnUnet数据格式"></a>nnUnet数据格式</h3><p><a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a></p>
<ul>
<li>针对每一个Task（数据集）</li>
</ul>
<p><code>nnUNet_raw_data_base</code> 文件夹存放数据（==Tips==，我开始以为这个文件夹的名字必须为nnUNet_raw_data_base，其实不是的，在环境变量中合理设置即可）。但是<code>nnUNet_raw_data</code>这个文件夹的名字是写死的。</p>
<p>每一个==数据集(dataset)==叫一个独立的<code>Task</code></p>
<p>每一个数据集有一个<code>Task_id</code></p>
<p>每个数据集表示的文件夹命名格式为<code>Taskxxx_name</code>（xxx为三位，name随便你取），如<code>Task001_BrainTumour</code>,<code>Task002_Heart</code></p>
<p>每一个Task存放在文件夹<code>nnUNet_raw_data_base/nnUNet_raw_data/</code></p>
<p>文件排布如下：</p>
<blockquote>
<p>nnUNet_raw_data_base/nnUNet_raw_data/<br>├── Task001_BrainTumour<br>├── Task002_Heart<br>├── Task003_Liver<br>├── Task004_Hippocampus<br>├── Task005_Prostate<br>├── …</p>
</blockquote>
<p>==在本例中，只使用新冠数据，因只有一个文件夹，为了避免和已有的数据集冲突，我将自己的数据集ID设为101（官方现在好像又推荐到500之后了，反正101我试了没问题）Task101_CovidInfection==</p>
<ul>
<li><p>针对每一个Task文件夹内部，格式应该为：</p>
<blockquote>
<p>Task001_BrainTumour/<br>├── dataset.json<br>├── imagesTr<br>├── (imagesTs)<br>└── labelsTr</p>
</blockquote>
<p><code>imagesTr</code>存放==训练集==，<code>imagesTs</code>存放==测试集==，<code>labelsTr</code>存放==标签数据==。</p>
<p>只有预测和算最后的精度用到了<code>imagesTs</code>,训练的时候完全没有用。（在训练时，这是可选项）。</p>
<p><code>dataset.josn</code>可以用程序生成，也可以参考example中很多自己直接写的，其实就几个参数，还是比较容易看懂的。</p>
<p>==训练数据可以有任意的灰度值，标签数据0代表背景，1代表类别1…直到类别n==（注意，标注的数据需要连续，比如brast2019中的标注的四个区域不连续，需要修改）</p>
<p>命名规则：</p>
<p>一个训练CT：<code>casename_identifier_XXXX.nii.gz</code></p>
<p>对应标签CT：<code>casename_identifier.nii.gz</code></p>
<p><del><code>casename</code>自己取得名字，<code>identififier</code>从001，002，003…，表示的是不同的病人例子的编号。</del>（==注意，删除线的说法是错误的。<code>case_identifier</code>可以任意取，只要不同即可，可参考brats的官方命名方式==</p>
<p><code>XXXX</code>表示的是同一个病人模态的标号，如CT，不同形式的核磁，从0000，0001…开始</p>
<p>例子如下：</p>
<p>Task001脑肿瘤分割任务，对于第一个case001有4个模态，FLAIR (0000), T1w (0001), T1gd (0002) and T2w (0003)。对应的label文件，BRATS_001.nii.gz</p>
<blockquote>
<p>nnUNet_raw_data_base/nnUNet_raw_data/Task001_BrainTumour/<br>├── dataset.json<br>├── imagesTr<br>│   ├── BRATS_001_0000.nii.gz<br>│   ├── BRATS_001_0001.nii.gz<br>│   ├── BRATS_001_0002.nii.gz<br>│   ├── BRATS_001_0003.nii.gz<br>│   ├── BRATS_002_0000.nii.gz<br>│   ├── BRATS_002_0001.nii.gz<br>│   ├── BRATS_002_0002.nii.gz<br>│   ├── BRATS_002_0003.nii.gz<br>│   ├── BRATS_003_0000.nii.gz<br>│   ├── BRATS_003_0001.nii.gz<br>│   ├── BRATS_003_0002.nii.gz<br>│   ├── BRATS_003_0003.nii.gz<br>│   ├── BRATS_004_0000.nii.gz<br>│   ├── BRATS_004_0001.nii.gz<br>│   ├── BRATS_004_0002.nii.gz<br>│   ├── BRATS_004_0003.nii.gz<br>│   ├── …<br>├── imagesTs<br>│   ├── BRATS_485_0000.nii.gz<br>│   ├── BRATS_485_0001.nii.gz<br>│   ├── BRATS_485_0002.nii.gz<br>│   ├── BRATS_485_0003.nii.gz<br>│   ├── BRATS_486_0000.nii.gz<br>│   ├── BRATS_486_0001.nii.gz<br>│   ├── BRATS_486_0002.nii.gz<br>│   ├── BRATS_486_0003.nii.gz<br>│   ├── BRATS_487_0000.nii.gz<br>│   ├── BRATS_487_0001.nii.gz<br>│   ├── BRATS_487_0002.nii.gz<br>│   ├── BRATS_487_0003.nii.gz<br>│   ├── BRATS_488_0000.nii.gz<br>│   ├── BRATS_488_0001.nii.gz<br>│   ├── BRATS_488_0002.nii.gz<br>│   ├── BRATS_488_0003.nii.gz<br>│   ├── BRATS_489_0000.nii.gz<br>│   ├── BRATS_489_0001.nii.gz<br>│   ├── BRATS_489_0002.nii.gz<br>│   ├── BRATS_489_0003.nii.gz<br>│   ├── …<br>└── labelsTr<br>   ├── BRATS_001.nii.gz<br>   ├── BRATS_002.nii.gz<br>   ├── BRATS_003.nii.gz<br>   ├── BRATS_004.nii.gz<br>   ├── …</p>
</blockquote>
<p>在本次实验中，没有多个模态。因此数据应为：</p>
<blockquote>
<p>nnUNet_raw_data_base/nnUNet_raw_data/Task101_CovidInfection/<br>├── dataset.json<br>├── imagesTr<br>│   ├── COVID_001_0000.nii.gz<br>│   ├── COVID_002_0000.nii.gz<br>│   ├── …<br>├── imagesTs<br>│   ├── COVID_409_0000.nii.gz<br>│   ├── COVID_410_0000.nii.gz<br>│   ├── …<br>└── labelsTr<br>   ├──COVID_001.nii.gz<br>   ├──COVID_002.nii.gz<br>   ├── …</p>
</blockquote>
<p>==For each training case, all images must have the same geometry to ensure that their pixel arrays are aligned. Also make sure that all your data is co-registered!==所有的图片都要有一样的形状，并且配准了。</p>
</li>
</ul>
<ul>
<li><p>生成datasets.json（对于==整个数据集==来说）</p>
<p>还没看，用程序生成<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a></p>
<p>很简单看例子即可。</p>
<p>也可以参考nnUnet/nnunet.dataset_conversion中的例子，那里面有很多公开数据集的手动数据转换。</p>
</li>
</ul>
<ul>
<li><p>How to use 2D data with nnU-Net</p>
<p>Essentially, all images must be converted to pseudo 3D images (so <strong>an image with shape (X, Y).</strong> When loading the images with SimpleITK, the resulting numpy array **shape should be (1, x, y). **We recommend you save your images with SimpleITK so that the correct shape is guaranteed. </p>
</li>
</ul>
<h3 id="配置环境变量How-to-set-environment-variables"><a href="#配置环境变量How-to-set-environment-variables" class="headerlink" title="配置环境变量How to set environment variables"></a>配置环境变量How to set environment variables</h3><p>上述的过程是配置了<code>nnUNet_raw_data_base/nnUNet_raw_data/</code>文件夹，我们仍然需要其余的两个文件夹<code>nnUNet_preprocessed</code>,<code>RESULTS_FOLDER</code>两个文件夹。</p>
<ul>
<li><code>nnUNet_preprocessed</code>用于存放预处理生成的文件，==一定==放在一块==SSD上==。（<em>个人感觉这个文件夹生成的东西还是很大的，我个人的数据集生成了200G的数据</em>)。用机械盘真的处理的，非常非常非常的慢。</li>
<li><code>RESULTS_FOLDER</code>用来存放模型的结果，也可以存放<strong>预处理的模型</strong></li>
</ul>
<p><a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/setting_up_paths.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/setting_up_paths.md</a></p>
<p>设置这三个环境变量。</p>
<ol>
<li><p><code>cd</code></p>
<p>cd到home目录下</p>
</li>
<li><p>编辑<code>.bashrc</code></p>
<p>感觉直接用vscode编辑即可。如果没有<code>.bashrc</code>，可以<code>touch /home/usrname/.bashrc</code>来生成</p>
</li>
<li><p>添加相关的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> nnUNet_raw_data_base=<span class="string">&quot;/media/fabian/nnUNet_raw_data_base&quot;</span></span><br><span class="line"><span class="built_in">export</span> nnUNet_preprocessed=<span class="string">&quot;/media/fabian/nnUNet_preprocessed&quot;</span></span><br><span class="line"><span class="built_in">export</span> RESULTS_FOLDER=<span class="string">&quot;/media/fabian/nnUNet_trained_models&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reload the <code>.bashrc</code>。用命令来使得环境变量生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/fabian/.bashrc</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>也可以设置暂时的环境变量，只在当前的终端中有用。不是很建议使用，这里就不写了。</p>
<hr>
<h2 id="数据预处理Experiment-planning-and-preprocessing"><a href="#数据预处理Experiment-planning-and-preprocessing" class="headerlink" title="数据预处理Experiment planning and preprocessing"></a>数据预处理Experiment planning and preprocessing</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity</span><br></pre></td></tr></table></figure>



<p><code>nnUNet_plan_and_preprocess</code>该命令进行预处理和提取数据特征</p>
<p><code>XXX</code>指的是Tash任务的编号<code>TaskXXX_MYTASK</code>，在这里是<code>000</code>对应着<code>Task000_CovidInfection</code></p>
<p><code>--verify_dataset_integrity</code>验证数据是否正确，必须在第一次运行时使用。</p>
<p>当内存不够时候，可以使用<code>-tl</code>和<code>-tf</code>选项</p>
<p>在完成此行命令后，a preprocessed copy of the data will be located at <code>nnUNet_preprocessed/TaskXXX_MYTASK</code></p>
<h3 id="预处理中遇到的问题"><a href="#预处理中遇到的问题" class="headerlink" title="==预处理中遇到的问题=="></a>==预处理中遇到的问题==</h3><p>开始的时候在实验室的机子上跑，总是会遇到程序’stuck’住的现象。<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/common_problems_and_solutions.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/common_problems_and_solutions.md</a>，主要的原因还是因为内存耗尽了。解决方案，仍然参考文档。</p>
<ol>
<li><code>-tl</code>和<code>-tf</code>可以调整为2，实在不行可以调整为1。可以通过<code>-h</code>查看具体参数的意思</li>
<li>拿出SSD的空间，作为swap的区域。<a href="https://blog.csdn.net/weixin_37532614/article/details/119239715">https://blog.csdn.net/weixin_37532614/article/details/119239715</a></li>
</ol>
<p>我采取的是方法1，把线程数变成2之后，处理速度相当慢。预处理的时间其实也还是蛮长的。(这个也是看数据的，brats数据处理起来就非常的快，大概10几分钟就处理完的，我的私有数据处理整整一天)</p>
<h3 id="预处理后pre文件中应该有的文件"><a href="#预处理后pre文件中应该有的文件" class="headerlink" title="预处理后pre文件中应该有的文件"></a>预处理后pre文件中应该有的文件</h3><ul>
<li>下图为brats19预处理结果</li>
</ul>
<p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt="截屏2022-02-07 19.26.10"></p>
<p>其中，<code>splits_final.pkl</code>可以用程序打开看一看，保存的是五折交叉验证，对训练集和验证集的划分。</p>
<p>其实，也可以<strong>自己修改数据的划分</strong>，可以在<code>common_question</code>中找到。（这样的话，假如只训练一折，可以直接将测试集作为本次实验的验证集，可以直接在训练后得到，不用再预测和计算了）</p>
<ul>
<li>下图为私有数据集的预处理结果</li>
</ul>
<p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.29.27.png" alt="截屏2022-02-07 19.29.27"></p>
<p>不知道为什么多了一个<code>nnUNetData_plans_v2.1_stage1</code></p>
<p>根据我个人的理解，含有2D的文件夹是训练2d模型需要的，其他是训练3D模型需要的。如果磁盘空间不够大的话，可以考虑删除部分文件夹的内容。</p>
<p>（其实利用<code>-h</code>可以查看该命令的更多帮助信息，应该是可以在预处理的时候，不准备3D模型的，但是我嫌麻烦，具体没有尝试。）</p>
<hr>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>感觉70%的工作已经完成了，剩下来的训练和预测步骤，多使用<code>-h</code>查看帮助即可。</p>
<p>训练采取的是五折交叉验证，如果要进行postprocessing and ensembling（我并没有做），是<strong>必须</strong>把五折交叉做完的。在这里，我只跑一折。</p>
<p>命令结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_train CONFIGURATION TRAINER_CLASS_NAME TASK_NAME_OR_ID FOLD  --npz (additional options)</span><br></pre></td></tr></table></figure>

<p><code>--npz</code>参数也是需要用在后处理中，我也没加。并不影响跑完一折的预测。</p>
<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p>这里还是举两个具体例子吧</p>
<p>2D模型</p>
<p>For FOLD in [0, 1, 2, 3, 4], run:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2 TaskXXX_MYTASK FOLD --npz</span><br></pre></td></tr></table></figure>

<p>注意，==FOLD==的取值为0，1，2，3，4</p>
<p>下面为跑一折2d的模型，在我自己修改的类<code>nnUNetTrainerV2_mine</code>上， 101为我的数据集的id，即前文中取得名字。用<code>tee</code>来保存print打印的数据到指定的文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2_mine 101 0 | <span class="built_in">tee</span> nnunet_train_200epoch_01_27_15_55.log</span><br></pre></td></tr></table></figure>

<p>跑3D模型同理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_train 3d_fullres nnUNetTrainerV2_mine 102 0 | <span class="built_in">tee</span> xxx.log</span><br></pre></td></tr></table></figure>



<h3 id="修改属于自己的类"><a href="#修改属于自己的类" class="headerlink" title="修改属于自己的类"></a>修改属于自己的类</h3><p>在<code>nnUNet/nnunet/training/network_training</code>文件夹中有大量的类，大多数情况下使用的是<code>nnUNetTrainerV2</code>这个类。在这里我只对epoch数进行修改，所以直接将<code>nnUNetTrainerV2_fp32.py</code>的内容复制一下，修改一下epoch即可。==注意==,记得修改类的名字为自己取的名字，并在上面的命令中替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nnunet.training.network_training.nnUNetTrainerV2 <span class="keyword">import</span> nnUNetTrainerV2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nnUNetTrainerV2_mine</span>(<span class="title class_ inherited__">nnUNetTrainerV2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Info for Fabian: same as internal nnUNetTrainerV2_2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plans_file, fold, output_folder=<span class="literal">None</span>, dataset_directory=<span class="literal">None</span>, batch_dice=<span class="literal">True</span>, stage=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 unpack_data=<span class="literal">True</span>, deterministic=<span class="literal">True</span>, fp16=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(plans_file, fold, output_folder, dataset_directory, batch_dice, stage, unpack_data,</span><br><span class="line">                         deterministic, fp16)</span><br><span class="line">        self.max_num_epochs = <span class="number">101</span>  <span class="comment"># 这是我做的修改</span></span><br></pre></td></tr></table></figure>



<h3 id="训练结束"><a href="#训练结束" class="headerlink" title="训练结束"></a>训练结束</h3><p>应该会在print中输出done。你设定的epoch数跑完之后，训练并没有完成。据我观察，接下来是对验证集的一些计算，在<code>validation_raw</code>文件夹中生成相关的文件，其中<code>.nii.gz</code>应该包换所有的验证集的数据。<code>summay.json</code>可以查看具体的在验证集中的训练精度。官方文件树机构如下</p>
<p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.55.05.png" alt="截屏2022-02-07 19.55.05"></p>
<p>我的文件结构</p>
<p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.55.51.png" alt="截屏2022-02-07 19.55.51"></p>
<p>其中<code>fold_0</code>文件夹</p>
<p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.56.20.png" alt="截屏2022-02-07 19.56.20"></p>
<p>在这里我只关注了<code>summary.josn</code>文件中的进度信息。</p>
<hr>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>如果寻找了最优参数，按照其提示进行预测。</p>
<p>我跳过了寻找最优参数，直接对一折的训练结果进行预测。</p>
<p>预测的每一个case的命名方式与之前一致</p>
<p>还是推荐查看<code>-h</code>来选择适合的参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_predict -i INPUT_FOLDER -o OUTPUT_FOLDER -t 101 -m 2d -<span class="built_in">tr</span> nnUNetTrainerV2_mine -f 0 </span><br></pre></td></tr></table></figure>

<p><code>-t</code>选择具体的任务,<code>-m</code>选择训练的模型，我进行的是2d，<code>-tr</code>选择训练的类，<code>-f</code>选择对第几折的结果进行预测（按照帮助，好像是可以自动的选择的）</p>
<hr>
<h2 id="计算精度"><a href="#计算精度" class="headerlink" title="计算精度"></a>计算精度</h2><p>在这里我计算的是预测结果的进度。</p>
<p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_evaluate_folder -ref FOLDER_WITH_GT -pred FOLDER_WITH_PREDICTIONS -l 1 2 3 4</span><br></pre></td></tr></table></figure>

<p>其中1,2,3,4代表有4个前景，如果你是做二分类，只需要写1即可。</p>
<p>==注意==，由于数据的问题，可能会有部分的预测结果为0，在<code>summary.json</code>中很明显，要注意及时查看数据的问题，或者删除相关的数据。</p>
<h3 id="具体文件的实现"><a href="#具体文件的实现" class="headerlink" title="具体文件的实现"></a>具体文件的实现</h3><p>在<code>nnUNet/nnunet/evaluation/metrics.py</code>中nnunet几乎实现了所有的指标，我需要使用到三个指标<code>Dice, sensitivity, HD95</code>，注意==recall==就是sensitivity。</p>
<p>具体的计算是调用了<code>nnUNet/nnunet/evaluation/evaluator.py</code>，默认的实现是没有输出hd95的结果的。</p>
<p>我将<code>&quot;Hausdorff Distance 95&quot;</code>加入了<code>37</code>行的列表<code>default_metrics</code>中，并在下面的<code>default_advanced_metrics</code>中注释掉了。结果是可行的，应该将下面的一个False改为True，也可以计算<code>default_advanced_metrics</code>中的HD95，不过我没有尝试。</p>
<p>在这里nnunet应该是开了多个线程来计算这一结果，比我自己写的一个个计算的代码快了很多倍。针对我的100多个数据，很快就得到了结果。</p>
<hr>
<h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol>
<li><p>检查病人ct的标注的范围，nnunet要求0为背景，其余前景要求<strong>连续</strong>为1,2,3….（如，在brats19中，前景值为1，2，4，需要做对应的修改，可参考nnunet的官方对brast19的转换）。</p>
</li>
<li><p>数据的移动和重命名。前文中提到，nnunet只对原始数据的尾缀，有要求。为0000,0001,0002…来代表不同的模态。对之前的<code>case_identifier</code>并没有要求。</p>
<p>常见的python中移动文件操作</p>
<ol>
<li><p>直接执行cp命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;cp -r &#x27;</span> + case_path + <span class="string">&#x27; &#x27;</span> + test_path)</span><br></pre></td></tr></table></figure>
</li>
<li><p>shutil.copyfile</p>
<p>文件到文件的移动</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copyfile(old_file, new_file)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>预处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity</span><br></pre></td></tr></table></figure>

<p>必要时调整<code>-tf</code>，<code>-tl</code>。针对内存不足的情况，可以修改swap。不过还是在几百个G大内存的服务器上跑舒服。</p>
</li>
<li><p>训练</p>
<p>如2d模型，跑<strong>第0折</strong>训练</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2_mine 101 0 | <span class="built_in">tee</span> nnunet_train_200epoch_01_27_15_55.log</span><br></pre></td></tr></table></figure>

<p>等待<code>summart.josn</code>文件生成之后，训练应该基本结束了。而且结尾应该也会答应done。</p>
</li>
<li><p>预测</p>
<p>预测时，注意选择自己需要的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_predict -i INPUT_FOLDER -o OUTPUT_FOLDER -t 101 -m 2d -<span class="built_in">tr</span> nnUNetTrainerV2_mine -f 0 | <span class="built_in">tee</span> nnunet_inference_01_28_16_11.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>评估</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nnUNet_evaluate_folder -ref FOLDER_WITH_GT -pred FOLDER_WITH_PREDICTIONS -l 1 2 3 4</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h2><p>在使用的时候可能会遇到各种各样的问题，可以多阅读作者写个答疑文档。也可以翻阅其他人提出的issue，如果还是没有解决，可以向作者提issue，他在一天之内，就回复了我提出的issue，在这里非常感谢Fabian无私地奉献。</p>
<p>我遇到的问题都是程序卡住的问题。</p>
<p>第一次程序卡住，是在预处理时程序卡住，开始以为是screen或者是nohup的问题，后来发现应该是内存耗尽了。可以在程序卡住的附近，注意观察。</p>
<p>==Tips==，在运行程序时，可以通过<code>htop</code>来查看CPU，内存和相关进程的情况。鼠标点击右下角退出。</p>
<p>使用<code>watch -n 0.1 nvidia-smi</code>来每隔0.1秒观察GPU的使用情况。</p>
<p>在预处理阶段，我建议使用<code>-tf</code>和<code>-tl</code>设置成1或者2的方式来解决卡住的问题。</p>
<p>第二次程序卡住，是在训练阶段。生成验证集数据并计算的时候，我的程序在生成了一个<code>npz</code>文件之后，呆在那长达数小时。由于我有300G的内存，并没有考虑内存的问题。可能是原始数据过大，我所使用的服务器小文件IO速度非常慢的原因造成。只需要耐心一点，一两天之后再回来看看，估计就有新的进展了。</p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu下挂载的机械硬盘写权限问题</title>
    <url>/2022/02/08/Ubuntu%E4%B8%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%86%99%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>实验室主机下有一块4T机械盘，设置成了exfat格式，平时只能以<code>root</code>用户的权限来跑，现在想设置成usr权限可以操作。使用了<code>chmod -R 777</code>和<code>chown usrname</code>均不成功，<code>chmod</code>运行结束后，使用<code>ls -al</code>查看权限并没有修改；<code>chown usrname</code>直接提示没有权限。记录一下，解决的过程。</p>
<span id="more"></span>
<p>==通过查资料发现<code>ntfs,exfat,fat32</code>等文件系统都是windows下的文件系统，因此有不能用过chmod来改权限的问题。==这个问题还是挺久远的，google上十几年前就有人问了，又要吐槽一下CSDN，大家抄来抄去，还有百度搜索一个问题，直接给你推荐一个不相关的CSDN合集，真是有够恶心人的。</p>
<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>（说一点废话，不想看的可以看下一段）因为，今天跑程序固态硬盘不够用，想在机械盘中存数据来跑nnunet，但是nnunet使用的不是如<code>python xxx.py</code>d的形式运行数据，而是用<code>nnUnet_</code>开头的命令行形式运行。因为使用<code>sudo</code>运行命令时，使用的是root用户下的环境变量，所以<code>sudo nnUnet_</code>命令虽然解决了写权限的问题，但是环境变量的设置又出错了。因此，想到了解决方法</p>
<ol>
<li>把usr下的<code>.bashrc</code>复制到<code>/root</code>下，再<code>source</code>，感觉后续有其他的问题，没有试。</li>
<li>解决硬盘的写权限问题</li>
</ol>
<h2 id="解决写权限"><a href="#解决写权限" class="headerlink" title="解决写权限"></a>解决写权限</h2><p>首先在CSDN这个垃圾堆找了一圈，跳转到了一篇知乎的文章<a href="https://www.zhihu.com/people/ni-da-pao-46%EF%BC%8C%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E5%8F%82%E8%80%83%E4%BB%B7%E5%80%BC%EF%BC%8C%E5%89%8D%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%9D%87%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E8%BF%99%E4%B8%AA%E8%BF%9B%E8%A1%8C%E3%80%82">https://www.zhihu.com/people/ni-da-pao-46，有一定的参考价值，前序的步骤均可以按照这个进行。</a></p>
<h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>

<p>查看已经挂载的硬盘的信息，第一列我理解为硬盘名，如<code>/dev/sda2</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>

<p>查看所有硬盘的信息，有可能自己的硬盘还没挂载</p>
<h3 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sda2 /mnt  <span class="comment">#sda2后面不要加/，那mnt后面也别加吧，不知道为什么</span></span><br></pre></td></tr></table></figure>

<p>补充一下，卸载硬盘的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /dev/sda2</span><br></pre></td></tr></table></figure>

<p>如果显示硬盘正忙，无法卸载，最好就是重启再弄</p>
<h3 id="查看硬盘分区id"><a href="#查看硬盘分区id" class="headerlink" title="查看硬盘分区id"></a>查看硬盘分区id</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure>

<p>找到对应硬盘的<code>UUID=XXXX-XXXX</code>和<code>TYPE=&quot;exfat&quot;</code>，每个人的type可能不一样，关系到后面的的修改</p>
<h3 id="编辑-etc-fstab文件"><a href="#编辑-etc-fstab文件" class="headerlink" title="编辑/etc/fstab文件"></a>编辑<code>/etc/fstab</code>文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line"><span class="comment"># 在启动或在终端中输入mount -a时自动挂载，或者为noauto</span></span><br><span class="line"><span class="comment"># user 允许任何用户挂载设备,可选nouser，这样仅仅允许root用户挂载</span></span><br><span class="line"><span class="comment"># rw 挂载为读写权限，可选ro挂载为只读权限</span></span><br><span class="line">UUID=xxx /mnt/disk1 ext4 auto,user,rw,uid=1000,gid=1000 0 0</span><br></pre></td></tr></table></figure>

<p>我在作者的基础上加了另一个方法的解决方案<a href="https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive">https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive</a>，加上了<code>uid=1000</code>,<code>gid=1000</code></p>
<p>如果你不知道你的<code>uid</code>，可以通过下面的命令来获得</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">id</span> yourusername</span><br><span class="line">uid=1000(yourusername) gid=1000(yourusername) <span class="built_in">groups</span>=1000(yourusername),4(adm),24(cdrom),...</span><br></pre></td></tr></table></figure>





<p>其他方法中的<code>umask=000</code>在我的实验中，并不好用</p>
<p>如果你的分区硬盘还没接触挂载，先执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount /dev/sda2 <span class="comment">#你的硬盘名</span></span><br></pre></td></tr></table></figure>

<p>Make systemd happy（我的理解，就是激活了/etc/fstab等这些开机启动程序的配置)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>重新挂载硬盘即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure>

<hr>
<p>最后纪念一下几个失败的修改（注释中全部失败了)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共享的机械盘，挂载在/mnt下</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /mnt exfat auto,user,rw 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw,umasks=000 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat defaults,umasks=000 0 0</span></span><br><span class="line">UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw,uid=1000,gid=1000 0 0</span><br></pre></td></tr></table></figure>





<h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p>==成功的解决方案==<a href="https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive">https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive</a></p>
<p>失败的，但是很有参考价值的一篇<a href="https://www.zhihu.com/people/ni-da-pao-46">https://www.zhihu.com/people/ni-da-pao-46</a></p>
<p>指出为什么不能写的原因的一篇<a href="https://askubuntu.com/questions/1111542/cant-change-ownership-of-mounted-device">https://askubuntu.com/questions/1111542/cant-change-ownership-of-mounted-device</a></p>
<p>指出为什么不能用<code>chomod</code>在ubuntu下修改NTFS(or FAT32)分区的很多解决方案<a href="https://askubuntu.com/questions/11840/how-do-i-use-chmod-on-an-ntfs-or-fat32-partition/956072#956072">https://askubuntu.com/questions/11840/how-do-i-use-chmod-on-an-ntfs-or-fat32-partition/956072#956072</a></p>
<p>这是介绍了umask=000解决方案的，对我失效<a href="https://askubuntu.com/questions/1255907/20-04-chmod-not-working-on-exfat-mount">https://askubuntu.com/questions/1255907/20-04-chmod-not-working-on-exfat-mount</a></p>
<p>一个人的非常的多尝试，可以看看<a href="https://www.reddit.com/r/linux4noobs/comments/kbpsex/cant_get_write_permissions_on_mounted_usb_hdd/">https://www.reddit.com/r/linux4noobs/comments/kbpsex/cant_get_write_permissions_on_mounted_usb_hdd/</a></p>
]]></content>
  </entry>
  <entry>
    <title>ssh断开保持程序运行</title>
    <url>/2022/02/08/ssh%E6%96%AD%E5%BC%80%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>ssh断开后，程序运行的进程就会中断了，因此要在后台保持运行。中文的资料查阅，有两种方法。1. nohup &amp;命令 2. screen命令</p>
<span id="more"></span>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>先介绍screen的用法吧，具体原理也不是很清楚，拿来就用。</p>
<p>比较实用的一点</p>
<ol>
<li>在非计算节点上screen -S gpu新建session，然后再里面申请到GPU节点后，再screen -S train训练节点</li>
<li>在最内层train上面, ctrl a d返回的事最外层非计算节点，按<code>crtl a a d</code>即可从最内层返回上一层</li>
</ol>
<h3 id="screen的常见操作"><a href="#screen的常见操作" class="headerlink" title="screen的常见操作"></a>screen的常见操作</h3><p><a href="https://www.vpser.net/manage/screen.html">https://www.vpser.net/manage/screen.html</a></p>
<p>创建一个 screen: <code>screen -S screen_name</code><br>删除一个 screen: <code>screen -S screen_name -X quit</code></p>
<p>或者在其中<code>exit</code>来退出当前的会话</p>
<p>回到一个 screen: <code>screen -x screen_name</code></p>
<p>或者 <code>screen -r screen_name</code></p>
<p>当然也可以通过<code>screen -ls</code>查看每个回话的id号，以及是否attach。</p>
<p>可以通过<code>id</code>来替换<code>screen_name</code>，如<code>screen -r 11791</code></p>
<p>从 screen 返回 <code>ctrl+a</code>+<code>d</code>,先按下ctrl a再按下d即可</p>
<p>如何上下滚动鼠标</p>
<p>Ctrl + a然后按[，进入复制模式，就可以用鼠标滚轮了</p>
<p><a href="https://ubuntuqa.com/article/6360.html">https://ubuntuqa.com/article/6360.html</a></p>
<p><code>ctrl + a</code>+<code>ctrl + a</code>可以切换当前会话下的不同窗口，莫名奇妙在一个会话下，弄了两个窗口来申请了GPU节点，在这里记录一下这个切换。</p>
<h4 id="一种常见的情况，screen的嵌套"><a href="#一种常见的情况，screen的嵌套" class="headerlink" title="一种常见的情况，screen的嵌套"></a>一种常见的情况，screen的嵌套</h4><p>如，我遇到的情况是，在使用服务器时，首先新建一个screen的会话，在其中利用<code>srun -n16 --gres=gpu:V100:1 --pty bash </code>申请一个GPU节点。再在当前的GPU节点的主机上，新建一个screen会话，再其中运行程序。这样就可以返回上一级GPU节点，使用<code>htop</code>和<code>nvidia-smi</code>查看相关的信息。</p>
<p>但是，直接使用<code>ctrl a d</code>回直接返回最外面一层的会话。正确的方法应该为<code>ctrl a </code> + <code>a d</code>这样可以从最内侧来返回上一层的会话。</p>
<p>参考链接为ssh嵌套的情况<a href="https://wiki.archlinux.org/title/GNU_Screen">https://wiki.archlinux.org/title/GNU_Screen</a></p>
<blockquote>
<p>It is possible to get stuck in a nested screen session. A common scenario: you start an SSH session from within a screen session. Within the SSH session, you start screen. By default, the outer screen session that was launched first responds to <code>Ctrl+a</code> commands. To send a command to the inner screen session, use <code>Ctrl+a</code> <code>a</code>, followed by your command. For example:</p>
<p><code>Ctrl+a</code> <code>a</code> <code>d</code> Detaches the inner screen session.</p>
<p><code>Ctrl+a</code> <code>a</code> <code>K</code> Kills the inner screen session.</p>
</blockquote>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>除了使用screen之外，也可以使用nohup来保持程序在ssh断开之后的持续运行。查询到常见命令如下。</p>
<p><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp; </code></p>
<p>在使用<code>command</code>之后，将输出的相关日志信息重定向到<code>myout.file</code>。其中，<code>&gt;</code>为覆盖式的写入，<code>&gt;&gt;</code>为在文件后面继续写入。如，使用nohup运行一测试程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> /home/ubuntu-4/anaconda3/bin/python3.8 /home/ubuntu-4/COVID19/test_nohup.py &gt;&gt; hello.log 2&gt;&amp;1 &amp; </span><br></pre></td></tr></table></figure>

<p>可以通过<code>tail hello.log</code>来查看输出的信息。但是，如果使用hello.log来保存python中的print信息的话，由于python中使用缓存机制，所输出的语句并不会实时显示。可以通过在print语句中加入flush来实现实时的输出。</p>
<p>==最后会显示Done==（not sure），在测试程序中实验的时候，在程序跑完之后确实可以看到进程打印了Done。但是，在ssh断开之后，父进程丢失。运行程序的进程变成了孤儿进程，我也不知道怎么恢复，只能从log信息中来获取。由于，我是在nnunet程序上做的实验，没有成功，这个方法就作罢了。</p>
<p>nnUNet_plan_and_preprocess -t 101 -tf 2 -tl 2 –verify_dataset_integrity | tee nnunet_pre_2nd.log</p>
<p>nohup nnUNet_plan_and_preprocess -t 101 –verify_dataset_integrity &gt;&gt; nnunet_pre.log 2&gt;&amp;1 &amp;</p>
<p>==最后执行完会显示Done==</p>
<p>nohup nnUNet_plan_and_preprocess -t 101 –verify_dataset_integrity &gt;&gt; /home/ubuntu-4/COVID19/nnunet_pre.log 2&gt;&amp;1 &amp;</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一般的情况而言，我觉得使用<strong>screen</strong>加上，python中的<strong>logger</strong>输出到指定文件中是比较好的方法，直接使用print进行打印，并不是一个很好的方法。</p>
<p>但是在nnunet中，由于我不是很懂这份代码，我采用的策略是，新建一个screen会话，将程序中的print结果保留到result.log当中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python xxx.py | <span class="built_in">tee</span> result.log</span><br></pre></td></tr></table></figure>

<p>我最后并没有采用<code>nohup</code>和<code>tmux</code>，简单地掌握了<code>screen</code>的这几个命令，应该足够使用了，再遇到新的问题的时候，再去谷歌查screen的用户手册吧。</p>
]]></content>
  </entry>
  <entry>
    <title>dfs中的状态变量（全局还是局部，当层还是下一层）</title>
    <url>/2022/12/16/dfs%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E8%BF%98%E6%98%AF%E5%B1%80%E9%83%A8%EF%BC%8C%E5%BD%93%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%8B%E4%B8%80%E5%B1%82%EF%BC%89/</url>
    <content><![CDATA[<p>如标题所示。我们主要讨论了两个问题，本文中是以二叉树为例子（dfs中也是等价）。</p>
<blockquote>
<ol>
<li>状态变量是作为全局变量来写，还是作为局部变量来写</li>
<li>无论作为全局变量，还是局部变量而言，状态变量的意义，是当前层函数的状态，还是下一层函数的状态（类比DFS中问题的写法，如八皇后）</li>
</ol>
</blockquote>
<p>首先解答第一个问题，两种写法都可以，我们将框架分为如下</p>
<p><img src="/2022/12/16/dfs%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E8%BF%98%E6%98%AF%E5%B1%80%E9%83%A8%EF%BC%8C%E5%BD%93%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%8B%E4%B8%80%E5%B1%82%EF%BC%89/image-20221216154210641.png" alt="image-20221216154210641"></p>
<span id="more"></span>

<p>我们使用全局的状态变量或者局部的状态变量都是可行的，这两种方法其实是等价的（我们在dfs中其实讨论过，在函数参数里局部变量的加法，蕴含了出函数之后，局部变量的减法）。</p>
<p>我们仍然以，一棵树的最深深度为例子。</p>
<p>首先是，全局状态变量，且是记录本层状态。这里初始化为0，且在记录本层状态之前++。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;  <span class="comment">// 状态变量对于本层而言</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root  == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        depth++;  <span class="comment">// 注意这一行</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;  <span class="comment">// 记录本层值</span></span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// print是当前的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>全局状态变量记录下一层，初始化为1，在记录本层状态之后++.  注意，这里要特判空的情况，上一种情况不用。（为什么，我叫这种情况为记录下一层位置，因为和dfs中一样，这里的第14行depth++之后，比如从1变为了2，对应的是下一层的值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;  <span class="comment">// 状态变量对于下一层而言</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root  == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;</span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 如果不先减减的话，print是下一层的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 因为默认有根，我要让状态变量相对于下一层</span></span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然，把这种情况理解成记录当前层情况也行（毕竟，采取局部变量时，也进行了特判，和初始化为1）==毋容置疑的是，第11行if所处的位置，记录的一定是当前函数的状态值，其他地方，这两种方法是存在差异的。==如，在中序的位置，前一种方法打印depth，确实是对应当前的值，而当前方法，打印depth，对应的是下一层的值，这样的说法可能更为妥当一点。</p>
<p>当我们使用局部变量时，往往是<strong>已经可以做出一个选择了，</strong>如这里是默认存在根节点（并把根节点的值，作为函数的局部变量），==所以需要进行特判，并传入第一个值（节点蕴含的值，或者节点的地址）==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这次我们把状态变量写在函数里面取</span></span><br><span class="line">    <span class="comment">// 这里的话，状态变量写成当层的，比较make sense一点，先写当层的吧</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;</span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 中序的位置print，depth仍然为本层的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 状态变量写成当层，需要特判断</span></span><br><span class="line">        <span class="built_in">traverse</span>(root, <span class="number">1</span>);  <span class="comment">// 这里写成当前层，我们传入反而是1？</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与全局变量的第二种情况不同，因为局部变量自动蕴含了<code>--</code>的含义，所以这里的位置位置，打印depth，仍然是当前的一个深度状态。</p>
<ul>
<li><p>在使用全局变量时，我们需要在中序的位置对全局变量先<code>--</code>再<code>++</code>吗？</p>
<p>  如果我们想要在中序的位置打印当前变量的深度</p>
<ol>
<li><p>如果全局变量记录的是本层的值，我们可以直接打印（为什么？因为我们从子节点回来时，已经对全局变量经过先加加，再减减了）</p>
</li>
<li><p>如果全局变量记录的事下一层的值，我们需要先<code>--</code>再<code>++</code>。这里的做法和dfs里for循环里的做法一直</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">depth++;  <span class="comment">// 下一层的层深</span></span><br><span class="line"><span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">depth--;</span><br><span class="line"><span class="built_in">print</span>(depth);  <span class="comment">// 本层的层深</span></span><br><span class="line">depth++;</span><br><span class="line"><span class="built_in">travese</span>(root-&gt;right);</span><br><span class="line">depth--;  <span class="comment">// 恢复本层</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>我们需要使用if特判是否存在左右子树吗</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left) traverse(root-&gt;left);</span><br></pre></td></tr></table></figure>

<p>  这里是一个提前的剪枝，使得叶子节点无需再往下走一步了。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>一类题型，以对两棵子树的遍历来产生结果</title>
    <url>/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="一类题型，以对两棵子树的遍历来产生结果"><a href="#一类题型，以对两棵子树的遍历来产生结果" class="headerlink" title="一类题型，以对两棵子树的遍历来产生结果"></a>一类题型，以对两棵子树的遍历来产生结果</h1><p>这一类问题的特点是对树进行递归遍历时，往往是对两棵树同时递归，这就产生了，同一时刻会有对应关系的两个节点，针对不同的题意，采取对两棵树的不同遍历顺序（或者叫对两个节点的不同选择策略），入口如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(TreeNode* l, TreeNode* r)</span><br></pre></td></tr></table></figure>

<h2 id="leetcode-101-迭代法"><a href="#leetcode-101-迭代法" class="headerlink" title="leetcode 101 迭代法"></a>leetcode 101 迭代法</h2><p>首先以<a href="https://leetcode.cn/problems/symmetric-tree/description/">leetcode 101. 对称的树为例子</a></p>
<p>按照上面的说法，这题的本质，是判断一对对对应位置的节点是否是一致的。如题目中的示例树，一共要判断3对节点位置是否相等，<code>2-&gt;2</code>，<code>3-&gt;3</code>，<code>4-&gt;4</code></p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221225216709.png" alt="image-20221221225216709"></p>
<span id="more"></span>

<p>先说一个容易帮助我们理解的方法，类似层序法。利用两个队列（其实一个队列也行），分别取两个子树中的对应节点对，首先应该将左子树节点压入队列1，右子树节点压入队列2。这是图中两个黄色节点，已经压入两个对应的队列中，在while循环中，先出队，对两个节点进行比较</p>
<blockquote>
<p>对两个节点的比较有三种情况</p>
<ol>
<li>其中一个节点为空，另一个不空，这是已经可以返回false</li>
<li>两个节点都空（由于这两个节点没有子节点了，我们可以continue了）</li>
<li>两个节点都不空，但是值不等，显然可以判断不对称了</li>
</ol>
<p>两个节点相等，默认继续往下走</p>
</blockquote>
<p>两个输入的左右节点的判断逻辑很简单，如何判断图中的蓝色节点和红色节点的位置呢。</p>
<p><strong>这里的逻辑是整个题目的关键。</strong>队列1压入左节点的左节点，队列2压入右节点的右节点；（这两个节点，在队列里有对应关系）；队列1压入左节点的右节点，队列2压入右节点的左节点。（同样形成了对应关系）</p>
<p>这样不仅保证了，两个队列每次取出的元素是期望的对应位置的，而且也保证了遍历到了所有的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 队列法，其实比较直观的</span></span><br><span class="line">    <span class="comment">// 用一个队列就行了，我还用了两个队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">push</span>(root-&gt;left);  <span class="comment">// 左节点压入队列1</span></span><br><span class="line">        q2.<span class="built_in">push</span>(root-&gt;right); <span class="comment">// 右节点压入队列2</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* n1 = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* n2 = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>((!n1 &amp;&amp; n2) || (n1 &amp;&amp; !n2)) &#123;  <span class="comment">// 有一个是空的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n1 &amp;&amp; n2 &amp;&amp; (n1-&gt;val)!=(n2-&gt;val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!n1 &amp;&amp; !n2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q1.<span class="built_in">push</span>(n1-&gt;left);</span><br><span class="line">            q1.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">            q2.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            q2.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221231000499.png" alt="image-20221221231000499"></p>
<p><strong>这个方法是迭代法，接下来介绍递归的方法</strong>.</p>
<p>递归法我习惯按照labuladong的想法<a href="https://labuladong.gitee.io/algo/1/6/">labuladong二叉树</a>，将二叉树的问题分为自顶向下遍历解决的问题，和后序遍历，要获取子节点信息后才能解决的问题。</p>
<h2 id="leetcode-101-前序遍历法"><a href="#leetcode-101-前序遍历法" class="headerlink" title="leetcode 101 前序遍历法"></a>leetcode 101 前序遍历法</h2><p>我们先不讨论剪枝的问题（这里的剪枝即为，遇到了不匹配的情况，接下来的树，我们并不需要遍历了，结束即可），剪枝的情况与dfs中只找到一种满足条件的解类似。</p>
<p>我们先对左右两棵树做完整的遍历，遍历的顺序完全与上面一致。</p>
<p>左子树遍历顺序为<strong>中左右</strong>，右子树遍历顺序为<strong>中右左</strong>，在两棵树的同时遍历体现在<code>traverse</code>的调用上。同样的，我们还是要先在前序的位置判断本层的情况。这里我们设置了一个全局的变量来存储是否对称</p>
<blockquote>
<p>两个节点的情况与上面几乎完全一样</p>
<ol>
<li>其中一个节点为空，另一个不空，变量为false，返回。<strong>注意，这里的返回并不是一路直接返回到根节点，只是返回上一层，当前节点的后续的遍历步骤不做了，上一层未做完的遍历还是要做的，如，继续遍历上一层的右子树（显示这步没有意义）</strong></li>
<li>两个节点都空，直接return，没有子节点了，不必往下</li>
<li>两个节点都不空，但是值不等，还是遍历为false，返回。</li>
</ol>
<p>两个节点相等，暗含在没写的else里，相等就要继续往下走了。</p>
</blockquote>
<p>下一层如何遍历，按照我们刚刚提到的。左子树先遍历左节点，右子树先遍历右节点。左子树再遍历右节点，右子树再遍历左节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(l-&gt;left, r-&gt;right);  <span class="comment">// 这两行是这题的本质</span></span><br><span class="line"><span class="built_in">traverse</span>(l-&gt;right, r-&gt;left);</span><br></pre></td></tr></table></figure>

<p>为了更直观的看出dfs的遍历顺序，如下图，我们用一颗更深的树</p>
<p>先展示一下，递归法入队列的节点顺序</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221232819926.png" alt="image-20221221232819926"></p>
<p>dfs的遍历顺序</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221233046877.png" alt="image-20221221233046877"></p>
<p>通过对遍历顺序的设置，我们得到了左右两棵子树，在对称位置的一个节点对应关系，还遍历了整棵树。完整代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用前序的遍历来实现</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;  <span class="comment">// 对左右子树来遍历，只不过遍历顺序不同</span></span><br><span class="line">        <span class="keyword">if</span> ((!l &amp;&amp; r) || (l &amp;&amp; !r)) &#123;  <span class="comment">// 其中一个空</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l-&gt;val) != (r-&gt;val)) &#123;  <span class="comment">// 这时已经非空了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(l-&gt;left, r-&gt;right);  <span class="comment">// 这两行是这题的本质</span></span><br><span class="line">        <span class="built_in">traverse</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 题目保证了，一定会有一个节点</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如果要进行剪枝呢，如果不感兴趣，可以直接看下一节。剪枝（dfs中只取一个满足条件的情况），要设置返回值。在期望的地方return true。<em>注意，这里的return值，并不是判断是不是对称树的return值</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用前序的遍历来实现</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;  <span class="comment">// 对左右子树来遍历，只不过遍历顺序不同</span></span><br><span class="line">        <span class="keyword">if</span> ((!l &amp;&amp; r) || (l &amp;&amp; !r)) &#123;  <span class="comment">// 其中一个空</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l-&gt;val) != (r-&gt;val)) &#123;  <span class="comment">// 这时已经非空了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(l-&gt;left, r-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 一路往上</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(l-&gt;right, r-&gt;left)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 题目保证了，一定会有一个节点</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="leetcode-101-后序遍历法"><a href="#leetcode-101-后序遍历法" class="headerlink" title="leetcode 101 后序遍历法"></a>leetcode 101 后序遍历法</h2><p>其实我这里不太愿意称呼这种方法为后序遍历法，因为与前序遍历的代码几乎是一模一样的，不过为函数添加了返回值。<strong>只有在后续的位置通过&amp;操作，得到“对应节点对”是否对称之后，才能判断本棵树是否对称</strong>。也就是说，本方法只能在遍历完所有的节点才能得到结果。</p>
<p>这里先看完整代码，在前序位置，判断节点的三种情况一样，就是在后序的位置修改了代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实际上还是labuladong说的遍历法的应用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!left &amp;&amp; right) || (left &amp;&amp; !right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;  <span class="comment">// 其实叶子蕴含在里面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 这里要好好理解</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &amp;&amp; right &amp;&amp; (left-&gt;val)!=(right-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么值相等的情况不return ture呢？</span></span><br><span class="line">        <span class="comment">// 因为这样没法继续往下走了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="built_in">cmp</span>(left-&gt;left, right-&gt;right);  <span class="comment">// 左； 右</span></span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="built_in">cmp</span>(left-&gt;right, right-&gt;left);  <span class="comment">// 右； 左</span></span><br><span class="line">        <span class="keyword">return</span> flag1 &amp;&amp; flag2;  <span class="comment">// 这其实是在后续遍历的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>return的结果，代表以<code>l</code>为根的这棵树，和以<code>r</code>为根的这棵树是否是镜像（对称关系）.</p>
<p>这是宏观上的一个理解，也就是说，以1为根的树是否对称，取决于以2为根的两棵树是否是镜像关系。而以2为根的两棵树是否镜像，取决于以1的左节点的左节点为根的树和以1的右节点的右节点为根的树镜像，以及1的左节点的右节点为根的树和以1的右节点的左节点为根的树镜像，如图</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221235831445.png" alt="image-20221221235831445"></p>
<p>本质上我觉得还是在比较对应的节点对，特别是在前序位置的比较。</p>
<p>这里还有一个问题，为什么不在前序的位置做相等的比较，然后return true呢？一个直观的回答是，即使两个节点值相同，也不能代表接下来的也相同。也可以理解为，相等这个判断已经隐式表现在了三个if中，这三个if都不是，肯定就相等了，接下来还得满足上图中，树的对称关系（也就是最后的与操作，相等就是&amp;true）</p>
<p>解决这一题并不是本次讲解的核心，本笔记的核心，<strong>是如何通过有效的递归（遍历的一个顺序），取到期望的节点对。</strong></p>
<p>==我们核心代码那两行的顺序是可以交换的，只不过会造成遍历的顺序不一样，不会影响结果。==</p>
<p>接下来，以<a href="https://leetcode.cn/problems/same-tree/">leetcode 100 相同的树</a>为例子，讲解如何取到两棵树完全一样的位置。</p>
<h2 id="leetcode-100"><a href="#leetcode-100" class="headerlink" title="leetcode 100"></a>leetcode 100</h2><p>这题写迭代法，用两个队列当然也是可行的，和上面的代码变化不大，不再写了。</p>
<p>前序法其实变化和上面的方法也不大，只改动了两行核心代码。</p>
<p>也就是左子树的遍历顺序是<strong>中左右</strong>，右子树保持完全一样的遍历顺序<strong>中左右</strong>。这里其实非常简单啊，就是对两棵树同时进行前序遍历即可。判断函数本层的三种情况，仍然如上。<strong>着重注意20行修改的部分</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 按前序的方法来写写看，这样可以剪枝</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!p &amp;&amp; q) || (p &amp;&amp; !q)) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;val) != (q-&gt;val)) &#123;  <span class="comment">// 这时候已经可以确保非空了</span></span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(p-&gt;left, q-&gt;left);  <span class="comment">// 修改的部分</span></span><br><span class="line">        <span class="built_in">traverse</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序法，我也不写了，也是同上，只要修改两行核心代码即可。展示一下，遍历的图，有人可能疑惑，这个遍历图一眼都会。我画的目的是强调，我们这里每次取到的是对应的节点对</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221222001340003.png" alt="image-20221222001340003"></p>
<p>同样，核心代码那两行也是可以交换的。</p>
<h2 id="leetcode116-填充每个节点的下一个右侧节点指针"><a href="#leetcode116-填充每个节点的下一个右侧节点指针" class="headerlink" title="leetcode116. 填充每个节点的下一个右侧节点指针"></a>leetcode116. 填充每个节点的下一个右侧节点指针</h2><p>接下来，我介绍这一题，我认为也完全可以归结到取左右子树的节点对这一题型里来。</p>
<p>这一题最直观的方法，使用层序遍历，保存每一层的第一个节点作为头节点，这样就可以像链表一样串起来了。这里我就不详细介绍这一个方法了。</p>
<h3 id="leetcode-116-遍历法"><a href="#leetcode-116-遍历法" class="headerlink" title="leetcode 116 遍历法"></a>leetcode 116 遍历法</h3><p>注意我这里没有叫他前序或者后序之类，因为按照labuladong的理解，这是一棵三叉树。</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/2022-12-2222.15.06.png" alt="截屏2022-12-22 22.15.06"></p>
<p>其实我们也可以按照上面的思路来考虑。这里的题意其实可以理解为，每次取一个节点对，让左节点的next指针指向右节点。按照这样的思路，我们还是同样先画一下取节点的示意图：</p>
<p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221222222358349.png" alt="image-20221222222358349"></p>
<p>按照三叉树的遍历，或者按照取节点对的方式来理解都可以，最关键的部分，还是核心代码，在这里核心代码为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(p-&gt;left, p-&gt;right);  <span class="comment">// 对应三叉树最左边的节点</span></span><br><span class="line"><span class="built_in">traverse</span>(p-&gt;right, q-&gt;left);  <span class="comment">// 对应三叉树中间节点</span></span><br><span class="line"><span class="built_in">traverse</span>(q-&gt;left, q-&gt;right);  <span class="comment">// 对应三叉树最右边的节点</span></span><br></pre></td></tr></table></figure>

<p>开始第一遍看到这个代码，我其实是没有理解的，但是从节点对的角度，按照遍历顺序模拟一遍应该会好很多。这里和之前两题不同的是，这里取节点出现了同时在一棵树上的情况，要好好理解。</p>
<p>类似的，这题当然能用队列来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; q1;</span><br><span class="line">        queue&lt;Node*&gt; q2;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) q1.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) q2.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node* n1 = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            Node* n2 = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            n1-&gt;next = n2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(n1-&gt;left);  <span class="comment">// 这里对应核心代码部分</span></span><br><span class="line">                q2.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q1.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q2.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">                q1.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">                q2.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实这些题目的本质，还是dfs，或者说还是二叉树的前序遍历，但是在这里是在两棵树同时遍历。</p>
<h2 id="leetcode-617同种题型"><a href="#leetcode-617同种题型" class="headerlink" title="leetcode 617同种题型"></a>leetcode 617同种题型</h2><p>补充：</p>
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">leetcode 617 合并二叉树</a>同种题型</p>
]]></content>
  </entry>
</search>
