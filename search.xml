<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js中var和let的区别</title>
      <link href="/2023/06/06/js%E4%B8%ADvar%E5%92%8Clet%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/06/06/js%E4%B8%ADvar%E5%92%8Clet%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/379326208">https://zhuanlan.zhihu.com/p/379326208</a></p><p><a href="https://blog.csdn.net/qq_43145310/article/details/125737211">https://blog.csdn.net/qq_43145310/article/details/125737211</a></p><p>《JavaScript高级程序设计》</p><p>我觉得主要有四点，作用域问题，变量提升，重复声明，挂载全局对象。</p><span id="more"></span><h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><p>let的作用域，是<strong>块作用域。</strong>任意一个花括号包裹起来，（比如<code>if, else, while中的花括号等</code>）就是一个块作用域。（块作用域是函数作用域的子集，也就是说函数作用域也属于块作用域）。对于let，就和c++中的使用感觉是一样的。</p><hr><p>var的作用域是<strong>函数作用域。</strong></p><p>函数作用域就是<code>function name() &#123;&#125;</code>这个花括号里面，才是函数的作用域。函数作用域里，用var声明变量，效果就和let一样。例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 出错!</span></span><br></pre></td></tr></table></figure><p>==在这里的使用就和使用let定义一样==（但是如果不使用var，会使得message变成一个全局变量，可以在外部访问到）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 删除var，全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 出错!</span></span><br></pre></td></tr></table></figure><p>如果在if中，也就是非函数作用域，这是块级作用域。在块级作用域用var声明的变量，可以在外部访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);   <span class="comment">// Matt，这里可以访问到</span></span><br></pre></td></tr></table></figure><hr><p>for循环的例子，也是一个作用域差异的例子。</p><p>var声明，可以在块作用域之外访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="comment">// 循环逻辑</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>let声明，不能在块作用域之外访问到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="comment">// 循环逻辑</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>还有一点差异。对于for循环，var变量每一轮循环引用到的，都是同一个<code>i</code>变量。</p><p>而在使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。</p><p>所以在异步的任务中，如<code>setTimeout()</code>，会有差异。因为异步任务会在所有的同步任务执行完之后再执行。</p><p>在这里对于let，每个 setTimeout 引用的都是不同的变量实例。对于var，每个定时器引用的都是同一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">0</span>)</span><br><span class="line">&#125; <span class="comment">// 你可能以为会输出 0、1、2、3、4 // 实际上会输出 5、5、5、5、5</span></span><br></pre></td></tr></table></figure><p>let</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">0</span>)</span><br><span class="line">&#125; <span class="comment">// 会输出 0、1、2、3、4</span></span><br></pre></td></tr></table></figure><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>在一个函数作用域里，var就提升到这个函数作用域最顶上。</p><p>在一个<code>.js</code>文件中，var就直接提升到文件最顶上。</p><p>对函数作用域中，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); </span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>第二行被正常执行了，并没有报错。因为这段代码，和下面这段代码是等价的。】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> age; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">age = <span class="number">26</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">foo</span>();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>这一点比较简单，var是允许重复声明的，而let是不允许的。会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">200</span>    <span class="comment">// 不会报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 输出 200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">200</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>对于作用域来说。var的作用域是函数作用域。</p><p>  函数作用域就是<code>function name() &#123;&#125;</code>这个花括号里面，才是函数的作用域。函数作用域里，用var声明变量，效果就和let一样。==函数作用域下，使用var，也是局部的。其它情况下，使用var是全局的。==</p><p>  <code>if, else, for</code>这些花括号里面的作用域不是函数作用域。</p><p>  let的作用域为块级作用域。==块级作用域，是函数作用域的子集。任意一个花括号，都是块级作用域。==</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode远程ssh反复输入密码连接不上</title>
      <link href="/2023/06/04/vscode%E8%BF%9C%E7%A8%8Bssh%E5%8F%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/"/>
      <url>/2023/06/04/vscode%E8%BF%9C%E7%A8%8Bssh%E5%8F%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>用vscode连接远程服务器时，经常过段时间就出现一个现象。</p><p>可以通过终端的命令行正常的连接远程的服务器；</p><p>但是通过vscode连接时，需要反复的输入密码无法连接。重启vscode，删除<code>.ssh</code>文件夹下的内容也都不好使。</p><p>解决方法：<a href="https://blog.csdn.net/weixin_43937790/article/details/128039464">https://blog.csdn.net/weixin_43937790/article/details/128039464</a></p><p>有效策略：通过终端ssh链接服务器。在home目录下：<code>rm -rf ./.vscode-server</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯问题总结</title>
      <link href="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>排列组合问题总结：</p><p><img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20221209103541562.png" alt="image-20221209103541562"></p><p>注意，**图写错了，是<code>!used[i-1]</code> **，其实在组合数里也可以用这种剪枝手段</p><span id="more"></span><h4 id="剪枝手段总结"><a href="#剪枝手段总结" class="headerlink" title="剪枝手段总结"></a>剪枝手段总结</h4><ol><li><p>**图写错了，是<code>!used[i-1]</code> **，其实==在组合数里也可以用这种剪枝手段==</p><p> 这种剪枝手段利用的是，两个数相同的数必须按照规定的顺序出现，否则就剪枝。如$2^{1}, 2^{2}$，这两个$2$，必须按照上标为1的2先出现，否则就剪枝</p></li><li><p><strong>还有一点，还有一种剪枝手段，和组合里剪枝一样，对同一个树枝分叉来剪，也就是同一级的。或者说，前一个（具体看labuladong说的读者的做法</strong></p><p> 这种剪枝手段就是我们写的<code>i &gt; start &amp;&amp; nums[i] == nums[i-1]</code>。我觉得这在树状图上更好理解，也就是说for循环里的是树的同一层，不允许树的同一层中，右边的节点和左边的节点相同。</p></li><li><p>不允许事先排序的剪枝，<a href="https://leetcode.cn/problems/non-decreasing-subsequences/solutions/">491. 递增子序列</a>，因为要保持序列的顺序，和我们第二种取子集的手段不同。</p><p> <strong>这里的本质是，同一层，不允许出现相同值的元素，于是引入一个set，记录本层中已经出现过元素的值，如果for循环里，又再次出现了这个值，则不允许</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unorder_set&lt;<span class="type">int</span>&gt; st; <span class="comment">// 每一层拥有一个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (set.<span class="built_in">count</span>(nums[i]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这里与《算法笔记》的选/不选的写法不同，那样写可以保证输出的顺序。而leetcode里的输出顺序是任意的，我也没有再继续往下思考了。</p></blockquote><p>今天又看到求组合数中，进一步剪枝的思路。也就是n个数，求K个数的组合。当第一层对K叉树回溯的时候，靠后的节点根本建不出一个到叶子节点长度为K的树，可以进一步剪掉。<a href="https://www.programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">https://www.programmercarl.com/0077.组合优化.html#其他语言版本</a></p><p><a href="https://labuladong.gitee.io/algo/1/8/">labuladong回溯算法套路框架</a></p><p>回溯，dfs，与递归。我觉得，回溯算法和dfs算法基本是一致的，但是labuladong说，<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong>，==暂时没有理解。==对于多叉树的遍历，也有区别</p><p><img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2511.28.03.png" alt="截屏2022-10-25 11.28.03"></p><p>我的理解，回溯算法本质上是对一颗K叉树的遍历，在遍历时会利用约束条件进行剪枝（如，没有重复数字的全排列，要求数字不能重复出现），最终到达叶子节点时，就是到达了递归的边界。从根节点，到叶子节点，所经过的节点，就是最终选择的路径，题目中时常要求输出（如，全排列中的节点，代表一种全排列组合）。</p><p>回溯算法框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择  <span class="comment"># 前序遍历</span></span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择  <span class="comment"># 后序遍历</span></span><br></pre></td></tr></table></figure><p>这里要理解的几个点：</p><ul><li><p>满足结束条件，我的理解是到达了叶子节点，全排列问题中，是一颗n叉树，n颗子树代表，这一层（也就是第i位），选择哪一个数字。n位数，每次都为第i位选个数字，选到第n个数时（从0开始），即到达叶子节点。</p><p>  八皇后问题，是一颗n叉树，n颗子树代表，这一层（也就是第i行），选择在哪一列放皇后。如果按照从上到下，为每一行选择列来看，选完n行即为到达叶子节点。</p><p>  背包问题的回溯写法==？==是一颗二叉树，左子树代表选择，右子树代表不选择。同样也是选完n个物品，即到达了叶子节点。（这里我疑惑的是，能不能按照for循环的方法来写这个选或者不选的dfs==？==</p><p>  总结步骤，<strong>按照题意构造出K叉树，找到每一层选择的意义，和到达叶子节点的条件</strong></p></li><li><p><code>for 选择 in 选择列表:</code>，在这里选择列表表面意义上是动态更新的，实际实现时，是在做选择之前，进行剪枝。剪枝可以通过两种方式，一种是可以继续，就往下。第二种，不可继续，则continue。</p></li><li><p>对<code>做选择</code>和<code>撤销选择的理解</code></p><p>  <img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2511.28.45.png" alt="截屏2022-10-25 11.28.45"></p><p>  <code>做选择</code>实际上是<code>前序遍历</code>，<code>撤销选择</code>是<code>后序遍历</code></p><p>  <strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。==值得注意的是，这里是相对即将进入的节点而言，按照对当前节点理解的话，代码又会做出改变==</p><p>  在即将进入节点之前，如设置isVisited[i]为true，将children节点代表的值，添加进当前遍历的路径之中就可以理解了。</p></li></ul><h4 id="如果只想要一个合法的结果"><a href="#如果只想要一个合法的结果" class="headerlink" title="如果只想要一个合法的结果"></a>如果只想要一个合法的结果</h4><p>好好理解，为什么加上true的返回值，以及何时加。在递归终点加？true的原因，是想就在这里结束了。后面两个加true和false的原因呢？if之后返回true，也就是代表了出这个节点，出这个节点之后，一般要撤销选择的状态，然后继续for循环，在这里直接打断了for循环。最后一个return false，是为了让上一级的for循环继续？？？（==看上面的解释吧==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 函数找到一个答案后就返回 true</span><br><span class="line"><span class="built_in">bool</span> backtrack(vector&lt;string&gt;&amp; board, <span class="built_in">int</span> row) &#123;</span><br><span class="line">    // 触发结束条件</span><br><span class="line">    <span class="keyword">if</span> (row == board.size()) &#123;</span><br><span class="line">        res.push_back(board);</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        </span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于for-选择-in-选择列表这一点"><a href="#关于for-选择-in-选择列表这一点" class="headerlink" title="关于for 选择 in 选择列表这一点"></a>关于for 选择 in 选择列表这一点</h4><p>可以把for循环拆分，因为全排列和八皇后写For循环，本质是因为下面要用到诸如w[i]这样的东西。这样我写成n个拆开的trackback(index+1)，本质上应该是一样的。我们再考虑到dfs中，选与不选的二叉树问题，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);  <span class="comment">// 不选第index</span></span><br><span class="line"><span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]); <span class="comment">//选</span></span><br></pre></td></tr></table></figure><p>这就是展开的写法，在这里如果想要<em>参数列表</em>，变得更加简单，我觉得如下的写法也是等价的，这样我们的框架就变得更加的统一了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DFS</span>(index + <span class="number">1</span>);  <span class="comment">// 不选， 前后不需要进行操作，进出节点，都不需要操作</span></span><br><span class="line">sumW += w[index];</span><br><span class="line">sumC += c[index];</span><br><span class="line"><span class="built_in">DFS</span>(index + <span class="number">1</span>);  <span class="comment">// 选</span></span><br><span class="line">sumW -= w[index];</span><br><span class="line">sumC -= c[index];</span><br></pre></td></tr></table></figure><p>其实将这两项写在参数里，<strong>隐式</strong>地表明了出操作的意思，出节点时，sum其实自动地减掉了，就不用再手动写了。</p><h4 id="关于有多个边界条件"><a href="#关于有多个边界条件" class="headerlink" title="关于有多个边界条件"></a>关于有多个边界条件</h4><p>有多个边界条件，或者说是约束，什么条件作为最终的输出条件，什么条件作为剪枝的条件呢？也就是说，到达叶子节点并不是唯一，或者说最终的条件。</p><p>如果题中明确指出了，结束的条件，如选择K个数，且和为sum，那么一般这个就是最终的结束条件。其他的边界条件，可以放在最终条件下面那个if判断后return，就是一个剪枝的过程，和在For循环里continue是一个意思。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><a href="https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">leetcode题解的总结</a></p><p>这个总结，我觉得说的不错。可以好好看看</p><p>做题的时候，建议<strong>先画树形图</strong> ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>在画图的过程中思考清楚：</p><ul><li><p>分支如何产生；</p></li><li><p>题目需要的解在哪里？是在<strong>叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？</strong></p></li><li><p>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</p></li></ul><h4 id="回溯算法中的排列，组合，子集问题"><a href="#回溯算法中的排列，组合，子集问题" class="headerlink" title="回溯算法中的排列，组合，子集问题"></a>回溯算法中的排列，组合，子集问题</h4><p><a href="https://labuladong.gitee.io/algo/1/9/">回溯算法秒杀所有排列-组合-子集问题</a></p><p>主要问题是在，目前遇到了两种写法，体现在树的构造不同上。主要有三个问题。</p><ol><li><p>无重复元素，且不可重复选取</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>有重复元素，不可重复选取（这里的难点在剪枝上</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span><span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>无重复元素，但是可以重复选取</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li></ol><h5 id="无重复元素且不可重复选取"><a href="#无重复元素且不可重复选取" class="headerlink" title="无重复元素且不可重复选取"></a>无重复元素且不可重复选取</h5><p>还是以<code>a = [1, 2, 3]</code>为例子，每个类型基本都是三个问题，子集(subset)，组合(combine)，排列(permute)。</p><ol><li><p>子集</p><p> a的子集有 $2^n$ 个，分别是<code>[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]</code>。</p><p> 第一步，构造树，树的构造方法有两种，一种是基于For循环的，一种是基于选与不选的二叉树的。</p><p> <img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2717.13.58.png" alt="截屏2022-10-27 17.13.58"></p><p> Q: 为什么要这么构造树</p><blockquote><p>因为<code>[1, 2]</code>和<code>[2, 1]</code>是同一子集，为了避免重复。我们可以在枚举的时候，保持原序列的<strong>顺序不变</strong>。即，我们当枚举到2时，只会从3开始往后枚举，不会再看之前的元素。在这里是在for循环时，使用了<code>start</code>来实现</p></blockquote><p> Q: 答案在哪里？</p><blockquote><p>答案是根节点到所有节点的路径，或者说，答案是所有的节点都行</p></blockquote><p> Q: 边界在哪？</p><blockquote><p>代码中并没有像之前的模板一样，在边界处进行返回。这里的边界（并不是答案的边界）暗藏在for循环里，如果不写if返回语句，仍然会在for循环结尾遇到n时，自动返回上一级。</p></blockquote><p> 第二种构造方法，基于选或者不选的二叉树</p><p> <img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/image-20221027191620910.png" alt="image-20221027191620910"></p><p> 不同之处在于，边界（答案边界）在叶子节点</p></li><li><p>组合</p><p> 组合的结果$C_{n}^{k}$，同样是会出现和子集一样的重复枚举的问题，在这种情况下，只需要在子集的情况下，加一个约束k，作为结果的边界来返回。</p><p> <img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2719.09.44.png" alt="截屏2022-10-27 19.09.44"></p><p> 方法二</p><p> 也是基于二叉树的，同样引入约束k，在k=2时返回答案，k&gt;2时剪枝</p></li><li><p>全排列</p><p> 全排列不能像子集和组合一样，它需要看到在a[i]之前的元素。所以不需要<code>start</code>来帮助，同前文中说的一样，这是一颗n叉树，使用<code>used[i]</code>来进行剪枝。</p></li></ol><h5 id="有重复元素且不可重复选取"><a href="#有重复元素且不可重复选取" class="headerlink" title="有重复元素且不可重复选取"></a>有重复元素且不可重复选取</h5><p>需要记住的重要的一点，==重复元素下的剪枝，需要先排序==</p><ol><li><p>子集/组合</p><p> 与前文中所说的无重复元素且不可重复选取不同点在于，对于<strong>重复元素的剪枝</strong>。我们仍然保留，<code>start</code>来进行剪枝，因为都是子集，不需要回头看。接下来，我们需要解决的是，$2$和$2^{‘}$带来的重复问题。也就是说，$[1, 2]$和$[1, 2^{‘}]$是同一个集合。</p><p> <img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2818.36.01.png" alt="截屏2022-10-28 18.36.01"></p><p> 注意剪枝条件中的<code>i &gt; start</code>，这一点非常重要，前万不要写成<code>i &gt; 0</code></p></li><li><p>全排列</p><p> 全排列问题，主要是为了解决在一般排列基础上所带来的的相同数字本身的一个排列所带来的重复问题。如$[1, 2, 2^{‘}]$和$[1, 2^{‘}, 2]$所带来的重复。对于，有三个数字的全排列个数为$\frac{A_{3}^{3}}{A_{2}^{2}}=3$。</p><p> <strong>只要我们保证，$2, 2^{‘}, 2^{‘’}$**只按这个</strong>顺序**出现，那么就可以避免重复的问题。</p><p> ![截屏2022-10-28 18.46.21](回溯问题总结/截屏2022-10-28 18.46.21.png)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ol><p>在保留前文<code>used[i]</code>对一般情况全排列剪枝的前提下，新增加的剪枝。</p><p>如果没有<code>!used[i-1]</code>，这一条件对顺序的约束，那么会出现什么情况</p><p><img src="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E6%88%AA%E5%B1%8F2022-10-2818.47.09.png" alt="截屏2022-10-28 18.47.09"></p><h5 id="元素不重复可复选"><a href="#元素不重复可复选" class="headerlink" title="元素不重复可复选"></a>元素不重复可复选</h5><ol><li><p>子集/组合问题</p><p> 这同样是在元素不重复可复选的基础上，将每次<code>i + 1</code>来控制<code>start</code>，转化为<code>i</code>即可</p></li><li><p>全排列</p><p> 这个全排列问题感觉没有什么意义，就是$2^{n}$枚举</p></li></ol><h5 id="二叉树的建树方式"><a href="#二叉树的建树方式" class="headerlink" title="二叉树的建树方式"></a>二叉树的建树方式</h5><p>树的每一级代表选不选这个元素，左边是不选，右边是选。相对于前面的建树方式，<strong>这种建树方式应该可以保证</strong>==字典序==的输出。这么说来，算法笔记针对PAT用这种建树方式也是可以理解了。</p><ol><li><p>元素不重复不可复选</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS(index + <span class="number">1</span>, <span class="built_in">sum</span>)  //不选</span><br><span class="line"></span><br><span class="line">trace.push_back(num[i])</span><br><span class="line">DFS(index + <span class="number">1</span>, <span class="built_in">sum</span> + num[i]) //选</span><br><span class="line">trace.pop_back()</span><br></pre></td></tr></table></figure></li><li><p>元素重复不可复选</p><p> 这里我暂时没有想好，用二叉树的方式怎么进行剪枝去除重复</p></li><li><p>元素不重复可复选</p><p> 同前文，将<code>index + 1</code>改为<code>index</code>即可</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DFS(index + <span class="number">1</span>, <span class="built_in">sum</span>)  //不选</span><br><span class="line"></span><br><span class="line">trace.push_back(num[i])</span><br><span class="line">DFS(index, <span class="built_in">sum</span> + num[i]) //选</span><br><span class="line">trace.pop_back()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swift programming language笔记</title>
      <link href="/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>官方swift文档<a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutswift">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutswift</a></p><p>自己不太熟的地方，做了一点总结</p><h2 id="The-Basic"><a href="#The-Basic" class="headerlink" title="The Basic"></a>The Basic</h2><ul><li><p>使用<code>let</code>关键字声明常量，<code>var</code>来声明变量。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximum <span class="operator">=</span> <span class="number">10</span>  <span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">var</span> current <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// 变量</span></span><br></pre></td></tr></table></figure></li><li><p>声明带上变量的类型，这篇文章里叫，<code>type annotations</code>。swift里面的变量名，通常是大写字母开头的。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure><p>  NOTE：在多数情况下不用写明类型，因为提供初值之后，编译器会自动推断，有点像C++的auto。</p></li></ul><span id="more"></span><ul><li><p>打印<code>print(_:separator:terminator:)</code>有默认参数分离符，应该是空格吧，终止符换行，可以自己设置，想要同时打印string和变量的值，英文叫采取<code>string interpolation</code>的方式。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The current value of friendlyWelcome is Bonjour!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>只有在一行写多句语句才需要写分号(semicolons)</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="number">1</span>; <span class="built_in">print</span>(cat)</span><br></pre></td></tr></table></figure></li><li><p>不需要显示声明常量和变量的类型，swift会自动做类型推断。</p></li><li><p>类型别名<code>typealias</code>，类似C里面的<code>typedef</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br></pre></td></tr></table></figure></li><li><p>tuple类型和python类型，里面可以存放任意类型的变量，如下</p><p>  decompose操作和python 类似</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">// http404Error is of type (Int, String), and equals (404, &quot;Not Found&quot;)</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="keyword">_</span>) <span class="operator">=</span> http404Error</span><br></pre></td></tr></table></figure><p>  访问元组中元素的方式和C中不一样</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http404Error.<span class="number">0</span></span><br><span class="line">http404Error.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>  你可以在定义元组时，为元组中单个的元素命名。也可以通过元素名字取访问这些值。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http2000Status <span class="operator">=</span> (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">http2000Status.statusCode</span><br><span class="line">http2000Status.description</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>optional==类型==是swift==特性==。主要用于一个变量或者常量，有些值可能会缺失的情况。它有==两种状态==，一种是含有值，一种是不含有值。如<code>Int()</code>可以将String”123”转化为Int类型，但是不能将String”abc”转化为Int类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber is inferred to be of type &quot;Int?&quot;, or &quot;optional Int&quot;</span></span><br></pre></td></tr></table></figure><p>  <code>convertedNumber</code>类型为optional Int，也可以叫<code>Int?</code>。含义是，<code>convertNumber</code>可能包含一个<code>Int</code>类型的值，也有可能包含<code>no value</code>，不包含任何值。 (It can’t contain anything else, such as a <code>Bool</code> value or a <code>String</code> value. It’s either an <code>Int</code>, or it’s nothing at all.)</p><ul><li><p>可以给optional类型的变量赋no value，<code>nil</code></p><p>  定义了一个optinal Int型的变量，含有值404。我们也可以使他变为no vaule。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode contains an actual Int value of 404</span></span><br><span class="line">serverResponseCode <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode now contains no value</span></span><br></pre></td></tr></table></figure><p>  如果如定义，默认就是no value的</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer is automatically set to nil</span></span><br></pre></td></tr></table></figure></li><li><p>通过与<code>nil</code>比较，判断optional内是否有值，通过<code>!</code>后缀强制取出（Forced Unwrapping）optinal类型变量的值（前提是要有值才取，不然会报错）</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;convertedNumber has an integer value of 123.&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>optional binding</p><p>  我觉得是利用<code>if</code>和<code>let</code>/<code>var</code>，将optional里的值暂时取出来，不使用上面描述的force unwrapping，也就是感叹号</p><p>  ==注意一下==，<code>actualNumber</code>是==局部变量==，只在if后的第一个大括号里有效。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The string <span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> has an integer value of <span class="subst">\(actualNumber)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The string <span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> couldn&#x27;t be converted to an integer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The string &quot;123&quot; has an integer value of 123&quot;</span></span><br></pre></td></tr></table></figure><p>  其实下面这个例子，更好的说明了optional binding</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// Here, myNumber is an optional integer</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myNumber <span class="operator">=</span> myNumber &#123;</span><br><span class="line">    <span class="comment">// Here, myNumber is a non-optional integer</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My number is <span class="subst">\(myNumber)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;My number is 123&quot;</span></span><br></pre></td></tr></table></figure><p>  第一行<code>myNumber</code>的类型为<code>Int?</code>，第三行的同名<code>myNumber</code>在if的作用域里的不是optional类型，就是常规的constant类型。</p><p>  由于经常取同名在if里覆盖上一级变量，所以有了更简化的写法。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myNumber &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My number is <span class="subst">\(myNumber)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;My number is 123&quot;</span></span><br></pre></td></tr></table></figure><p>  可以同时写多个optional bindings，但是只有一个不含有值，则整个if语句判断为false。==这里不写&amp;&amp;，写逗号<code>,</code>==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Implicitly Unwrapped Optionals</p><p>  上文介绍了两种打开optional类型变量里的值，一种，使用<code>!</code>；第二种，使用optional binding</p><p>  Implicitly Unwrapped Optionals适用于，一个变量在第一次设置了值后，就一直有值了（其实没有太理解），这样就不用判断是不是<code>nil</code>了</p><p>  使用类似<code>Int!</code>来定义此种类型，如下</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;An optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> <span class="operator">=</span> possibleString<span class="operator">!</span> <span class="comment">// requires an exclamation point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> <span class="operator">=</span> assumedString <span class="comment">// no need for an exclamation point</span></span><br></pre></td></tr></table></figure><p>  一个理解，对于<code>implicitly unwrapped optional</code>类型，编译器首先会使用基础optional类型来进行尝试，如果尝试失败，则会将optional里面的值取出来使用。如下</p><p>  <code>optionalString</code>的类型是<code>String？</code>，而<code>implicitString</code>的类型是显示声明的<code>String</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalString <span class="operator">=</span> assumedString</span><br><span class="line"><span class="comment">// The type of optionalString is &quot;String?&quot; and assumedString isn&#x27;t force-unwrapped.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>assertion和precondition</p><p>  和C中使用一样</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;age need larger than 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">precondition</span>(index <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure><p>  区别assert只在<code>debug buliding</code>中有效，precondition在<code>debug</code>和<code>production</code>中都有效。</p></li></ul><ul><li><p>error handing</p><p>  我们用<code>throw</code>关键字定义一个可能会抛出错误的函数</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">canThrowAnError</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在执行这个函数时，我们要把他包裹在do-catch里，并加上<code>try</code>关键字</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们看一个例子吧</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeASandwich</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.outOfCleanDishes &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.missingIngredients(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  函数<code>makeASandwich()</code>可能会抛出错误，如果不排除错误，就可以执行之后的语句<code>eatASangwich()</code>。如果抛出错误，看与catch语句中哪一个错误匹配，哪一个错误匹配就执行catch花括号里的语句。</p></li></ul><h2 id="Basic-Operators"><a href="#Basic-Operators" class="headerlink" title="Basic Operators"></a>Basic Operators</h2><ul><li><p>tuple也能进行比较，从左到右进行比较，只要但凡有一个有比较结果，就出结果（对于不等号），其实C++里的vector也是能比较的</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; aren&#x27;t compared</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) <span class="operator">&lt;</span> (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.</p><p>想在tuple中比较超过7个元素，需要自己重载运算符</p></blockquote></li><li><p>Range operator</p><p>  <code>a...b</code>意味着<code>[a, b]</code>；<code>a..&lt;b</code>意味着<code>[a, b)</code></p><p>  <code>names[2...]</code>,<code>names[..&lt;2]</code>忽略一侧的写法，有一点像python</p></li></ul><ul><li><p>Nil-coalescing operator(<code>a ?? b</code>)</p><blockquote><p>The <em>nil-coalescing operator</em> (<code>a ?? b</code>) unwraps an optional <code>a</code> if it contains a value, or returns a default value <code>b</code> if <code>a</code> is <code>nil</code>. The expression <code>a</code> is always of an optional type. The expression <code>b</code> must match the type that’s stored inside <code>a</code>.</p></blockquote><p>  <code>a ?? b</code>用于<code>a</code>是一个optional 类型，b是对应类型的一个值，如果a这个变量里面非空有值，则取a里面的值，如果是nil，则取b的值。（注意b的值的类型要和a的对应的类型对应）相当于</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> a<span class="operator">!</span> : b</span><br></pre></td></tr></table></figure><p>  举例，userDefinedColorName是nil，所以取了defaultColorName的值red</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName is nil, so colorNameToUse is set to the default of &quot;red&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Strings-and-Characters"><a href="#Strings-and-Characters" class="headerlink" title="Strings and Characters"></a>Strings and Characters</h2><ul><li><p>跨越多行的String字面量</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;  // 下一行为开始</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span></span><br><span class="line"><span class="string">please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span></span><br><span class="line"><span class="string">till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  <span class="comment">// 上一行为结束</span></span><br></pre></td></tr></table></figure><p>  底下两个是相同的，也就是说是没有换行符的</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleLineString <span class="operator">=</span> <span class="string">&quot;These are the same.&quot;</span></span><br><span class="line"><span class="keyword">let</span> multilineString <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">These are the same.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>当你在string中因为一行内容过长而要换行，但是不想输出换行符，可以使用bcakslash(\)，这样2,3行在输出中就是为一行内容</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> softWrappedQuotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin, <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>关于多行字面量的缩进，最后的多引号之前的indent，在每一行中都会被忽略，之后的才会记录，如下图所示</p><p>  <img src="/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/multilineStringWhitespace_2x.png" alt="../_images/multilineStringWhitespace_2x.png"></p></li></ul><ul><li><p>初始化空字符串</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString <span class="operator">=</span> <span class="string">&quot;&quot;</span>               <span class="comment">// empty string literal</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString <span class="operator">=</span> <span class="type">String</span>()  <span class="comment">// initializer syntax</span></span><br><span class="line"><span class="comment">// these two strings are both empty, and are equivalent to each other</span></span><br></pre></td></tr></table></figure><p>  通过属性<code>isEmpty</code>判断字符串是否为空</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nothing to see here&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Nothing to see here&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>String type is a <code>value types</code>。对于这段话的理解是，在函数里，对字符串的传递是传值传递，也就是拷贝值，会传递一个新的版本，修改它并不会影像原来的字符串。编译器会保证在</p></li><li><p>与python类似，用<code>for-in</code>访问字符串中的每一个元素。</p><p>  可以通过<code>String()</code>将array数组转化为String，将<code>Character</code>数组传递给初始化器，==有没有发现Character，他也是用双引号初始化的==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] <span class="operator">=</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> catString <span class="operator">=</span> <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// Prints &quot;Cat!🐱&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串String通过加号+连接新的字符串，通过<code>append()</code>添加字符<code>Character</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用属性<code>count</code>计算String中字符的个数，但是由于String支持unicode编码的，所以String中添加了东西，仍然有可能字符个数未改变，如下：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word <span class="operator">=</span> <span class="string">&quot;cafe&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in cafe is 4&quot;</span></span><br><span class="line"></span><br><span class="line">word <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;301&#125;</span>&quot;</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in café is 4&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Each <code>String</code> value has an associated <em>index type</em>, <code>String.Index</code>, which corresponds to the position of each <code>Character</code> in the string.</p></li><li><p>==因为String对于每一个Character的存储空间不同，所以String不能通过下标来访问。==通过属性，或者<code>index()</code>来访问</p><p>  <code>startIndex</code>属性对应String的第一个位置，<code>endIndex</code>属性对应String最后一个位置的下一个，和其他语言类似，还是左闭右开的。<code>offsetBy</code>的用法，注意是不包括当前的位置，数n个。==通过offsetBy可以实现类似的下标访问。==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Guten Tag!&quot;</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]  <span class="comment">// 这里相当于greeting[7]</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>  Use the <code>indices</code> property to access all of the indices of individual characters in a string.但是我感觉，既然这么做了，为什么不用for-in来访问每一个元素呢？</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.indices &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;G u t e n   T a g ! &quot;</span></span><br></pre></td></tr></table></figure></li><li><p>插入和删除，用的时候再查吧，感觉用的时候很少</p></li><li><p>子串（<code>Substring</code>）有自己独特的type.子串类型一般用于临时使用，当准备长期存储结果时，需要将子串转化为String类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) <span class="operator">??</span> greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning <span class="operator">=</span> greeting[<span class="operator">..&lt;</span>index]</span><br><span class="line"><span class="comment">// beginning is &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the result to a String for long-term storage.</span></span><br><span class="line"><span class="keyword">let</span> newString <span class="operator">=</span> <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否有相关前缀或者后缀<code>hasPrefix(), hasSuffix()</code>，返回Boolean类型</p></li></ul><h2 id="Collection-Types"><a href="#Collection-Types" class="headerlink" title="Collection Types"></a>Collection Types</h2><p>三种类型，数组，集合，字典</p><ul><li><p>数组的类型为<code>Array&lt;Int&gt;</code>，也可以速记为<code>[Int]</code>。==这里和C还是一样的，数组里只允许有一种类型==</p><p>  创建一个空数组，<strong>创建空数组时，需要显式声明变量类型，如[Int]</strong></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInts is of type [Int] with <span class="subst">\(someInts.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInts is of type [Int] with 0 items.&quot;</span></span><br></pre></td></tr></table></figure><p>  使用<code>append()</code>添加元素</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>  也可以初始化有重复元素的数组</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure><p>  可以和python一样，使用<code>+</code>连接两个列表</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br></pre></td></tr></table></figure><p>  可以使用常数字面量初始化数组</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br><span class="line"><span class="comment">// 由于自动推断</span></span><br><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br></pre></td></tr></table></figure><p>  如果切片和替换的数组字面量长度不一致，仍然可以进行替换</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shop[<span class="number">4</span><span class="operator">...</span><span class="number">6</span>] <span class="operator">=</span> [<span class="string">&quot;bananas&quot;</span>, <span class="string">&quot;apples&quot;</span>]  <span class="comment">// 左边长度为3，右边长度为2</span></span><br></pre></td></tr></table></figure><p>  <code>insert</code>和<code>remove</code>，与String类似</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">&quot;Maple Syrup&quot;</span>, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList now contains 7 items</span></span><br><span class="line"><span class="comment">// &quot;Maple Syrup&quot; is now the first item in the list</span></span><br></pre></td></tr></table></figure><p>  删除函数会返回被删除的那个值</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup <span class="operator">=</span> shoppingList.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// the item that was at index 0 has just been removed</span></span><br><span class="line"><span class="comment">// shoppingList now contains 6 items, and no Maple Syrup</span></span><br><span class="line"><span class="comment">// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string</span></span><br></pre></td></tr></table></figure><p>  <code>enumerated()</code>方法和python类似</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item <span class="subst">\(index <span class="operator">+</span> <span class="number">1</span>)</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>字典，这里也与python不一样，key要求同一类型，value要求同一类型（这里有点像C++的unordered_map）。同样的，键是不能重复的。</p><p>  字典类型为<code>Dictinary&lt;type1, type2&gt;</code>，可以简写为<code>[type1: type2]</code>。</p><p>  创建一个空字典</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers: [<span class="type">Int</span>: <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"><span class="comment">// namesOfIntegers is an empty [Int: String] dictionary</span></span><br></pre></td></tr></table></figure><p>  使用字典字面量，创建字典</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure><p>  可以直接使用下标更新值，也可以使用方法<code>updateValue(_:forKey:)</code>如果字典含有某个键，则更新他的值。如果没有那个键，则创建。实际上和通过下标访问的做法是一样的，但是这个方法会返回一个optional类型，也就是老的值，如果没有老的值，就返回nil</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue <span class="operator">=</span> airports.updateValue(<span class="string">&quot;Dublin Airport&quot;</span>, forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The old value for DUB was <span class="subst">\(oldValue)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The old value for DUB was Dublin.&quot;</span></span><br></pre></td></tr></table></figure><p>  对于某个键，字典中可能会不存在，这样会返回optinal类型。==其实直接访问airport[“DUB”]，不管存不存在这个键，都是返回的optional类型==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName <span class="operator">=</span> airports[<span class="string">&quot;DUB&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The name of the airport is <span class="subst">\(airportName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That airport isn&#x27;t in the airports dictionary.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The name of the airport is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure><p>  移除值的两种方法</p><ol><li><p>设置值为<code>nil</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Apple International&quot;</span></span><br><span class="line"><span class="comment">// &quot;Apple International&quot; isn&#x27;t the real airport for APL, so delete it</span></span><br><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL has now been removed from the dictionary</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>removeValue(forKey:)</code>，利用键的值移除键值对，如果存在的话，返回移除的value，如果不存在的话，返回<code>nil</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue <span class="operator">=</span> airports.removeValue(forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The removed airport&#x27;s name is <span class="subst">\(removedValue)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary doesn&#x27;t contain a value for DUB.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The removed airport&#x27;s name is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure><p>迭代字典的方法也和python类似，同时迭代键-值对，==其中airportCode, airportName是常量==</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br></pre></td></tr></table></figure><p>利用属性<code>keys</code>或<code>values</code>迭代</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport code: <span class="subst">\(airportCode)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport name: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br></pre></td></tr></table></figure><p>还可以将<code>d.keys</code>转化为array，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes <span class="operator">=</span> [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes is [&quot;LHR&quot;, &quot;YYZ&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames <span class="operator">=</span> [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames is [&quot;London Heathrow&quot;, &quot;Toronto Pearson&quot;]</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p>set</p><p>  集合中的数据或者字典的key值，必须满足<code>hashable</code>。swift中的基础类型，比如String,Int,Double,Bool都是可哈希的，除此之外</p><p>  Enumeration case values without associated values are also hashable by default.</p><p>  当然你也使用你自己定义的类型作为集合的数据或者字典key的值，只需要他满足<code>Hashable</code>协议。</p><p>  建立空的集合</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</span></span><br></pre></td></tr></table></figure><p>  使用<code>insert</code>插入数据，注意，再次把letters变空时，它仍然是Set&lt;Character&gt;类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// letters now contains 1 value of type Character</span></span><br><span class="line">letters <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span></span><br></pre></td></tr></table></figure><p>  使用数组字面量来创建集合</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br><span class="line"><span class="comment">// favoriteGenres has been initialized with three initial items</span></span><br></pre></td></tr></table></figure><p>  使用<code>remove()</code>来删除set中的元素，当然和字典一样，返回的是optional</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre <span class="operator">=</span> favoriteGenres.remove(<span class="string">&quot;Rock&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(removedGenre)</span>? I&#x27;m over it.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I never much cared for that.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Rock? I&#x27;m over it.&quot;</span></span><br></pre></td></tr></table></figure><p>  使用<code>contains()</code>判断是否包含某个元素</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.contains(<span class="string">&quot;Funk&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I get up on the good foot.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s too funky in here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;It&#x27;s too funky in here.&quot;</span></span><br></pre></td></tr></table></figure><p>  做集合操作略</p></li></ul><h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><ul><li><p>类似python中，有步长的range范围</p><p>  半开半闭[0, 60)，步长为5</p><p>  <code>stride(from: 开始,to: 结束, by: 步长)</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minuteInterval <span class="operator">=</span> <span class="number">5</span>, minutes <span class="operator">=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  全闭</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hours <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> hourInterval <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 3 hours (3, 6, 9, 12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>switch</p><p>  这里和C有点不一样，没有break。与C中不同的是，Swift并没有implicit fallthrough，==只要找到第一个匹配的case，就跳出去==</p><p>  Every <code>switch</code> statement must be <em>exhaustive</em>，也就是说必须在case里找到一个可以<em>匹配</em>的选项，如果没有任何一种情况匹配，就会报错。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;z&quot;</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;z&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The last letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Some other character&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The last letter of the alphabet&quot;</span></span><br></pre></td></tr></table></figure><p>  case中必须至少包含一条可以执行的语句，下面的例子，<code>case:&quot;a&quot;</code>中没有执行语句，然而我们选择的又是<code>a</code>。按上述两条，也就是必须匹配，而且case中必须有执行语句。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="comment">// Invalid, the case has an empty body</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This will report a compile-time error.</span></span><br></pre></td></tr></table></figure><p>  case中可以判断多种情况（多个值），用逗号分隔，满足其中一种即可</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The letter A&quot;</span></span><br></pre></td></tr></table></figure><p>  switch中还有一些独有特性，大致看了一下，感觉很少用switch</p><p>  通过<code>fallthrough</code>强制<code>switch</code>在匹配继续往下匹配一个？(<strong>fallthrough只是强制继续往下看一个，不管是否匹配，比如这里只看到了default，如果case 2,3… 之后有一个case 20，他仍然会执行case20的代码</strong>)。不知道这样写法的意义何在？</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// Prints &quot;The number 5 is a prime number, and also an integer.&quot;</span></span><br></pre></td></tr></table></figure><p>  switch的值绑定，使用临时的常量或者变量来绑定对应的值。临时在于，只在这个case的作用域内有效。这个值绑定，还是和enum的值绑定很像的，那个也是通过switch</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;on the x-axis with an x value of 2&quot;</span></span><br></pre></td></tr></table></figure><p>  switch中还可以使用where来进行匹配，感觉也是挺少见的，见例子</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;(1, -1) is on the line x == -y&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>这里取的标题是early exit</p><p>  像 <code>if</code> 语句一样，<code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码。</p><p>  <code>guard</code>作用和if类似，不同的地方是，1, 他一定要跟else，而且else中需要return 或者 throw(必须使用在函数内部？) 2, 作用域问题。if条件中定义的变量只能花括号里使用，guard在花括号之外还能使用，如下面的打印</p><blockquote><p>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the <code>guard</code> statement appears in.</p></blockquote>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> person[<span class="string">&quot;name&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location <span class="operator">=</span> person[<span class="string">&quot;location&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice near you.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice in <span class="subst">\(location)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>])</span><br><span class="line"><span class="comment">// Prints &quot;Hello John!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;I hope the weather is nice near you.&quot;</span></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;location&quot;</span>: <span class="string">&quot;Cupertino&quot;</span>])</span><br><span class="line"><span class="comment">// Prints &quot;Hello Jane!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;I hope the weather is nice in Cupertino.&quot;</span></span><br></pre></td></tr></table></figure><p>  如果 <code>guard</code> 语句的条件被满足，则继续执行 <code>guard</code> 语句大括号后的代码。将变量或者常量的可选绑定作为 <code>guard</code>语句的条件，都可以保护 <code>guard</code> 语句后面的代码。</p></li></ul><ul><li><p>检查API可用性</p><p>  有点不太理解。感觉就是一个if或者guard语句，判断当前版本是否能调用这个API。</p></li></ul><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>Every function in Swift has a type, consisting of the function’s parameter types and return type. You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions. </p><p>每一个函数都有一个type，由参数的类型和返回类型组成。你可以把他当做swift中的任意其他类型，这样方便了函数作为一个参数传递，或者作为返回值返回</p><p><em>形参是parameter</em>，实参是argument</p><ul><li><p>定义函数</p><p>  参数类型String，返回类型String</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ==调用函数的时候，必须写明label person，不然报错==，也就是说<code>greet(person: &quot;Sam&quot;)</code>，person不能省略</p></li><li><p>两个函数变量名相同，但是参数返回类型不同，编译器还是可以区分的。这是多态？忘了</p></li><li><p>使用tuple来返回多个值，不同的是，返回的多个值，可以带上label（==也可以不取名字和其他返回类型一样，直接写<code>(Int, Int)</code>==），方便后续的访问。和之前第一章定义tuple的内容类似，在这里<code>bounds</code>是一个tuple。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;min is -6 and max is 109&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>返回optional tuple类型，有可能返回tuple，也有可能返回nil，如</p><p>  <code>(Int, Int)?</code></p><blockquote><p>(Int, Int)?的意思就是我上面说的，有可能返回tuple，也有可能返回nil</p><p>(Int?, Int?)的意思不同，这是两个单独的值</p></blockquote>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>)<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>隐式返回值，这个要求整个函数体只有一行，这个也太少见了吧</p></li><li><p>The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label.</p><p>  很奇怪的做法，每个函数都有<code>argument label</code>实参的标注，在调用函数的时候，必须注明label。每个函数还有<code>parameter name</code>形参的名字，用于在函数体内实现相关行为。通常情况下，形参使用名字作为对应的label</p><p>  这一点比较有意思，不明白意义在哪里。每一个函数的参数，有<code>argument label</code>和<code>parameter name</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">argumentLabel</span> <span class="params">parameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// In the function body, parameterName refers to the argument value</span></span><br><span class="line">    <span class="comment">// for that parameter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>argument label</code>用在Call这个函数，<code>parameter name</code>用在函数内部。默认情况下，<code>argument label</code>被<code>parameter name</code>代替</p></li><li><p>我们可以用下划线来忽略<code>argument label</code>，==这样在调用函数时，就不用写label名字啦==，如下：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="keyword">_</span> <span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></span><br><span class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>默认参数值(Default Parameter Values)</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// If you omit the second argument when calling this function, then</span></span><br><span class="line">    <span class="comment">// the value of parameterWithDefault is 12 inside the function body.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault is 12</span></span><br></pre></td></tr></table></figure></li><li><p>可变形参(variadic parameters)，用<code>Int...</code>表示，输入的多个值，被作为constant的Array传入</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></span><br></pre></td></tr></table></figure></li><li><p>==注意点==，在这里十分傻逼的是，函数的参数是==常数类型==，不能再body里面改变</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">change</span>(<span class="params">a</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    a <span class="operator">=</span> <span class="number">36</span>  <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(a: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>  如果你想改变值（==这里同时改变了传入的实参的值，这样我们的实参只能是变量，不能是常量和字面量==），在类型前面加上<code>inout</code>，如交换两个数的值</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  而且只能传入可以修改的变量，传入时候还要加上<code>&amp;</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span></span><br></pre></td></tr></table></figure><p>  这像指针又不像，像引用又不像。<strong>而且，如果我们想要不修改外部的变量，就不能用inout了，把形参强制设置为常数真的很傻</strong></p></li><li><p>函数类型</p><p>  函数类型由参数的类型和返回的类型所决定：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这两个函数的类型都为<code>(Int, Int) -&gt; Int</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个函数类型为<code>() -&gt; Void</code></p></li><li><p>==注意==函数类型和其他任何类型，在swift中都一样的使用，你可以用它来定义变量，并assgin一个合适的函数。==那也可以理解成，其实函数也是一个变量？赋给另一个变量，相当于别名？==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br></pre></td></tr></table></figure><p>  你可以用它来调用函数</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 5&quot;</span></span><br></pre></td></tr></table></figure><p>  还可以用其他函数来改变它的值，并且调用</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 6&quot;</span></span><br></pre></td></tr></table></figure><p>  ==当然，和其他变量一样，你可以让swift自己去推断变量的类型==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction <span class="operator">=</span> addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span></span><br></pre></td></tr></table></figure></li><li><p>函数类型还可以用作参数的类型（？？？说实话，不是很理解这样的用途</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 8&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>函数类型还能作为返回类型</p><p>  首先定义两个函数</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  将<code>(Int)-&gt;Int</code>作为返回类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套函数(nested function)，在函数里嵌套定义函数，他的作用域只在花括号里有效</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>之前没看懂，开头的话跳过了。</p><p>全局和嵌套函数也是一种特殊的闭包。</p><blockquote><p>全局函数是一个有名字但不会捕获任何值的闭包</p><p>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</p><p>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</p></blockquote><p>应该和lambda函数类似</p><p>以<code>sorted</code>函数举例子，这个和C++里的库函数差不多，需要接收一个函数返回布尔值来帮助排序。常规方法，构造一个普通的函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames is equal to [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure><p>这样写有点复杂，闭包的格式如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序函数中传入闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>==注意这种写法，其实和函数的写法是相似的==。同样拥有<code>(s1: String, s2: String) -&gt; Bool</code>，只不过写在了花括号里面，而且没有了名字，多了<code>in</code></p><blockquote><p>The start of the closure’s body is introduced by the <code>in</code> keyword. This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</p></blockquote><p><code>in</code>意味着参数和返回类型已经结束，函数体开始了。</p><ul><li><p>推断闭包中参数的返回值的类型，让编译器自己推断，所以去掉了参数两侧的括号，以及返回类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure><blockquote><p>It’s always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</p></blockquote><p>  ==？当一个闭包被用作函数或者方法的实参时，不需要写完整的定义，如参数类型，返回值，只需像上面那么写就行==</p></li><li><p>==只有单句表达式==的闭包，可以隐式蕴含了<code>return</code>语句。相比上面去掉参数和返回类型，这里进一步去掉了<code>return</code>关键字</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure></li><li><p>还可以进一步简化，去掉整个参数列表和<code>in</code>，<strong>只有这种简化写法的时候，可以去掉参数列表</strong></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure></li><li><p>更进一步简化</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>尾部闭包</p><p>  <strong>感觉主要两个点，第一个尾闭包可忽略label，作为唯一参数时可以忽略括号</strong></p><p>  函数参数可以接受函数类型，当闭包作为<del>最后一个</del>英文是last参数（其实，好像是后面的就可以）传递时，可以用尾部闭包。写在函数调用的括号之外。一次函数调用，可以包含多个尾部闭包，第一尾部闭包可以不写argument label？</p><blockquote><p>If you need to pass a closure expression to a function as the function’s <strong>final</strong> argument and the closure expression is long, it can be useful to write it as a <em>trailing closure</em> instead. You write a trailing closure <strong>after the function call’s parentheses</strong>, even though the trailing closure is still an argument to the function. When you use the trailing closure syntax, you <strong>don’t write the argument label for the first closure</strong> as part of the function call. A function call can include multiple trailing closures; however, the first few examples below use a single trailing closure.</p></blockquote>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数，参数类型为函数类型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该函数</span></span><br><span class="line"><span class="comment">// Here&#x27;s how you call this function without using a trailing closure:</span></span><br><span class="line"><span class="comment">// 这是常规闭包调用的方法</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// closure&#x27;s body goes here</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用尾部闭包的方式调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// trailing closure&#x27;s body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上文中的排序就可以用尾部闭包来写</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure><p>  如果闭包表达式作为函数的==唯一参数==，而且写作尾部闭包时，==可以把函数调用的括号去掉==。其实不唯一的也去了括号，如lec2里的button。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure><p>  尾闭包用在Array类型的方法<code>map(_:)</code>里，自己看吧，不想理了。（主要内容就是作为唯一参数的尾部闭包，去掉了括号，调用写在外部）相当于，实现了对数组中的某一个对象做的操作，但是调用时会对每一个对象按顺序做一遍操作。<strong>这里有意思的一点是，和上文中的说法不同，闭包作为函数的参数时，不用写全完整的形式，但是这里删掉返回值类型，报错，不能推断</strong></p><p>  可以写多个尾部闭包，但是==第一个尾部闭包的label可以省略不写==，再注意一下函数调用时，括号里的参数列表。</p><p>  如下，这个函数，最后两个参数是函数类型，可以传入尾部闭包</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadPicture</span>(<span class="params">from</span> <span class="params">server</span>: <span class="type">Server</span>, <span class="params">completion</span>: (<span class="type">Picture</span>) -&gt; <span class="type">Void</span>, <span class="params">onFailure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> picture <span class="operator">=</span> download(<span class="string">&quot;photo.jpg&quot;</span>, from: server) &#123;</span><br><span class="line">        completion(picture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onFailure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用该函数，==第二个label还是要写的==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(from: someServer) &#123; picture <span class="keyword">in</span></span><br><span class="line">    someView.currentPicture <span class="operator">=</span> picture</span><br><span class="line">&#125; onFailure: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t download the next picture.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>值捕获 capturing values</p><p>  感觉有点复杂，这里是以嵌套函数的捕获为例子的。</p><blockquote><p>A closure can <em>capture</em> constants and variables from the surrounding context in which it’s defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</p></blockquote><p>  闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p><p>  嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。看下面的例子吧</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  嵌套函数 <code>incrementer()</code> 从上下文中捕获了两个值，定义在外面这个函数作用域里的变量<code>runningTotal</code> 和 外面函数的形参<code>amount</code>。</p><blockquote><p> It does this by capturing a <em>reference</em> to <code>runningTotal</code> and <code>amount</code> from the surrounding function and using them within its own function body. Capturing by reference ensures that <code>runningTotal</code> and <code>amount</code>don’t disappear when the call to <code>makeIncrementer</code> ends, and also ensures that <code>runningTotal</code> is available the next time the <code>incrementer</code> function is called.</p></blockquote><p>  这是因为它从外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的==引用==。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p><p>  例子，重要</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure><p>  每次调用这个函数，<code>runningTotal</code>的值都会增加，并不是每次都初始化为0！这和C里面有很多的差别。</p><p>  如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure><p>  再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中捕获的变量没有任何联系：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>闭包是引用类型，感觉这一点和说的class类似</p><p>  上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是==常量==，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p><p>  无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的<em>引用</em>。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p><p>  这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50,值继续增加</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>逃逸闭包看不懂</p><p>  一个闭包作为实参传递给函数，但是要在函数返回之后才调用这个闭包，称为这个闭包逃逸了。如果你允许一个闭包逃逸，在写函数的参数时，要加上<code>@escaping</code>关键字。</p><p>  然后之后需不需要隐式地调用self，又没看懂。应该和会形成引用有关系。也就是说，逃逸闭包捕获了self，但是需要在函数执行之后不知道什么时候才调用。这样这个引用就会一直存在。类对象，必须显示引用self。</p><p>  如果self是一个结构体和枚举类型类型的self，你可以隐式的引用他，但是不能修改他。</p></li></ul><h2 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h2><p><strong>枚举类型起初并没有和什么值绑定，他就是他自己作为值。可以用switch判断，也可以用CaseIterable来创建collection。然后引入了，关联的值，为每个case关联值。</strong></p><p>==可以确定的是，他也是一个<strong>TYPE</strong>==，可以理解成和struct类似？</p><p>枚举类型的格式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> &#123;</span><br><span class="line">    <span class="comment">// enumeration definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个定义枚举类型的例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用逗号分隔多个case</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与在C中不同的是，这些case并没有绑定默认的值，我的理解是，他的值就是定义在case的右边的本身</p><ul><li><p>Each enumeration definition defines a new type. Like other types in Swift, their names (such as <code>CompassPoint</code> and <code>Planet</code>) start with a capital letter.</p><p>  每一个枚举类型定义了一个新的类型，他们的类型名字用大写字母开头。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br></pre></td></tr></table></figure><p>  The type of <code>directionToHead</code> is inferred when it’s initialized with one of the possible values of <code>CompassPoint</code>. Once <code>directionToHead</code> is declared as a <code>CompassPoint</code>, you can set it to a different <code>CompassPoint</code> value using a shorter dot syntax:</p><p>  既然已经确定了变量<code>directionToHead</code>是类型<code>CompassPoint</code>，再为他赋值时，可以使用更简单的方式</p><p>  <code>directionToHead is CompassPoint</code>返回的是true</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead <span class="operator">=</span> .east</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用switch匹配枚举类型，略。只有一个注意点，就是要匹配到枚举类型里所有的case才能保证完备。</li></ul><ul><li><p>迭代枚举类型</p><p>  首先要在枚举类型的名字后面加上<code>CaseIterable</code>，这样在访问属性<code>allCases</code>时，就创建了一个含有枚举类型中所有case的collection，可以使用for-in对collection进行访问</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Beverage</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices <span class="operator">=</span> <span class="type">Beverage</span>.allCases.count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(numberOfChoices)</span> beverages available&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;3 beverages available&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>associated value</code></p><p>  可以把每个case存储相关的值，这样更有意义。而且每个case可以有不同的值类型。</p><p>  他的举例为，一个一维条形码upc，和二维码qrcode</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“Define an enumeration type called <code>Barcode</code>, which can take either a value of <code>upc</code> with an associated value of type (<code>Int</code>, <code>Int</code>, <code>Int</code>, <code>Int</code>), or a value of <code>qrCode</code> with an associated value of type <code>String</code>.”</p></blockquote><p>  定义一个枚举类型叫做<code>Barcode</code>，要么是值<code>upc</code>同时有一个associated value是类型<code>(Int, Int, Int, Int)</code>，要么是值<code>qrCode</code>同时有一个associated value是类型<code>String</code></p><blockquote><p>This definition doesn’t provide any actual <code>Int</code> or <code>String</code> values—it just defines the <em>type</em> of associated values that <code>Barcode</code> constants and variables can store when they’re equal to <code>Barcode.upc</code> or <code>Barcode.qrCode</code>.</p></blockquote><p>  这个定义并没有提供一个实际的<code>Int</code>或者<code>String</code>值，他只是定义了associated value的类型，当他们与<code>Barcode.upc</code>或<code>Barcode.qrCode</code>相等时，一个<code>BarCode</code>变量可能存储的值。</p><p>  还是看例子吧</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>  定义了一个变量，而且assigns it a value of <code>Barcode.upc</code> with an associated tuple value of <code>(8, 85909, 51226, 3)</code>.</p><p>  同样和上文一样，可以修改这个变量为其他的case</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><ul><li>还是可以用switch判断类型，但是可以提取associated value，这里就不写了。</li></ul><ul><li><p>Raw Values</p><p>  除了用关联值为一个case关联值，类似类和结构体的初始化，枚举类型这里也可以使用原始值预填充，每个原始值的类型必须是一致的。如下，==<strong>注意</strong>第一行后面写了类型==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ASCIIControlCharacter</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  原始值之间必须是<strong>不相同的</strong>。</p><p>  <code>ASCIIControlCharacter.tab</code>仍然是<code>ASCIIControlCharacter</code>枚举类型，<code>ASCIIControlCharacter.tab.rawValue</code>才是对应的原始值类型。具体见我们再cs193笔记开头写的代码例子。</p></li></ul><ul><li><p>当使用Int或者String作为原始值时，会存在着隐式的赋值。这一点和C很像。</p><p>  当使用整数作为原始值时，隐式赋值的值依次递增 <code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为 <code>0</code>。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在上面的例子中，<code>Plant.mercury</code> 的显式原始值为 <code>1</code>，<code>Planet.venus</code> 的隐式原始值为 <code>2</code>，依次类推。</p><p>  当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span>: <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  面例子中，<code>CompassPoint.south</code> 拥有隐式原始值 <code>south</code>，依次类推。</p><p>  使用枚举成员的 <code>rawValue</code> 属性可以访问该枚举成员的原始值：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 &quot;west&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用原始值初始化枚举实例 initializing from raw value感觉有点鸡肋</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet is of type Planet? and equals Planet.uranus</span></span><br></pre></td></tr></table></figure><p>  就是用原始值，找到对应的case来初始化一个变量。==注意==，返回的是对应的枚举optional类型，因为可能找不到。</p></li><li><p>递归枚举，有点绕，但是能看懂，估计用处不大，这里不写了</p></li></ul><h2 id="Structures-and-Classes"><a href="#Structures-and-Classes" class="headerlink" title="Structures and Classes"></a>Structures and Classes</h2><p><strong>总结，结构体和其他大多数类型是值类型，传递时，先做复制，彼此之间的修改相互独立。类类型是引用类型，和python类似，都指向同一个对象，而且有点像存储地址的意思？虽然文档说不是，但是可以这么理解</strong></p><p>类型名字大写驼峰命名，如<code>SomeStructure</code>和<code>SomeClass</code>。属性名和方法名，小写驼峰命名，如<code>frameRate</code>和<code>incrementCount</code></p><ul><li><p>Structures and enumerations are value type. 结构体和枚举类型是值类型。</p><blockquote><p>A <em>value type</em> is a type whose value is <em>copied</em> when it’s assigned to a variable or constant, or when it’s passed to a function.</p></blockquote><p>  值类型是一种类型，当传递给变量或者常量时，或者传递给函数时，它只是将值做一遍拷贝。</p><blockquote><p>all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</p></blockquote><p>  swift中几乎所有的基础类型，整数，浮点，布尔，字符串，数组，字典都是值类型，都是使用结构体实现的。</p></li></ul><ul><li><p>Classes are reference types. 类是引用类型。</p><p>  也就是说，将一个变量a赋给变量b时，两个变量指向同一个内存区域。这个和python里一样。</p><p>  Effectively, they’re just two different names for the same single instance</p><p>  还一个有意思的现象，==这里变量貌似存储的是一个地址？==，因为我可以修改一个常量类变量属性的值。对此文档的解释是，属性的值改变，并没有改变实例。 they both <em>refer</em> to a <code>VideoMode</code> instance behind the scenes. It’s the <code>frameRate</code> property of the underlying <code>VideoMode</code> that’s changed, not the values of the constant references to that <code>VideoMode</code>.我觉得，大概的意思是，就是地址。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resolution</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoMode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hd <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tenEighty <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution <span class="operator">=</span> hd</span><br><span class="line">tenEighty.interlaced <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tenEighty.name <span class="operator">=</span> <span class="string">&quot;1080i&quot;</span></span><br><span class="line">tenEighty.frameRate <span class="operator">=</span> <span class="number">25.0</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用三个等于号</p><p>  <code>===</code>来判断两个变量是否指向同一个示例</p><p>  <code>!==</code>指向不同的示例</p></li></ul><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul><li><p>stored properties感觉就和C中的属性类似</p><p>  由于结构体是value type，所以与上文中的class不同，不能对常量类型的结构体的属性进行修改，如下，==但是定义成变量的结构体，是可以修改属性的==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// this range represents integer values 0, 1, 2, and 3</span></span><br><span class="line">rangeOfFourItems.firstValue <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// this will report an error, even though firstValue is a variable property</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>lazy stored properties. 利用<code>lazy</code>修饰器，修饰一个存储变量属性（只能修饰变量），使得当这个属性第一次被使用时，才会真正的初始化。适用于，初始化消耗比较多的场景。</p><blockquote><p>必须将延时加载属性声明成变量（使用 <code>var</code> 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而<strong>常量属性在构造过程完成之前必须要有初始值</strong></p></blockquote>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataImporter</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter is a class to import data from an external file.</span></span><br><span class="line"><span class="comment">    The class is assumed to take a nontrivial amount of time to initialize.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> filename <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property hasn&#x27;t yet been created</span></span><br></pre></td></tr></table></figure><p>  如上，创建DataManager实例后，其中的属性importer并没有创建实例，直到它第一次被使用。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.filename)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has now been created</span></span><br><span class="line"><span class="comment">// Prints &quot;data.txt&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Computed properties</p><p>  举几个例子，<code>var body</code>还有<code>viewModel</code>里返回<code>cards</code>的变量都是计算属性，不过他们是只读的，其实计算类型很好理解的。</p><p>  <strong>计算类型一定要设置为变量</strong>，他们并不存储值，通过<code>get</code>中返回一个与定义的变量类型相同的值来获取值，同时他也能通过<code>set</code>来影响其他的属性。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter <span class="operator">=</span> square.center</span><br><span class="line"><span class="comment">// initialSquareCenter is at (5.0, 5.0)</span></span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;square.origin is now at (10.0, 10.0)&quot;</span></span><br></pre></td></tr></table></figure><p>  最关键的代码就是第10-20行，这个计算变量<code>center</code>的代码。我们初始化这个正方体，只给了属性<code>origin</code>和<code>size</code>值，我们通过<code>get</code>计算出值来赋给<code>center</code>。同样，我们改变<code>center</code>的值，会自动的通过<code>set</code>来影响到其他属性。</p></li><li><p>简化setter声明，在上文中，我们对set设置了参数<code>set(newCenter)</code>，我们也可以不设置参数，使用简写的方式,默认的名字是<code>newValue</code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">    origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">    origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  getter简写，就是一行代码不写return，这个和函数也和闭包里面一样</p></li></ul><ul><li><p>read-only computed properties只读计算属性，没有setter的计算属性</p><p>  这个就是我们经常见到的<code>var body</code>啦。这次省略的更厉害，==把get，连同get的花括号全部省略了==</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot;</span></span><br></pre></td></tr></table></figure><p>  感觉这里return都能省略</p></li><li><p>type properties</p><p>  我觉得type stored properties就是C++中类里的静态类型，用<code>static</code>来声明。type computed properties应该就和copmuted properties类似，多了个关键字？</p><blockquote><p>Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself doesn’t have an initializer that can assign a value to a stored type property at initialization time.</p><p>Stored type properties are lazily initialized on their first access. They’re guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they don’t need to be marked with the <code>lazy</code> modifier.</p></blockquote><p>  必须给<strong>stored</strong> type properties一个默认值。然后stored type properties是lazy初始化的，只有第一次访问到他，才会用值初始化。</p></li></ul><ul><li><p>property obsevers</p><p>  这个和计算属性其实有点像，但是是有区别的。</p><blockquote><p>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p></blockquote><p>  每次属性值改变的时候，都是用属性观察者。</p><p>  你可以在以下位置添加属性观察器：</p><ul><li><p>自定义的存储属性</p></li><li><p>继承的存储属性</p></li><li><p>继承的计算属性</p><p>==区别1，属性观察者可以用在存储属性上。==区别2，这里使用的是<code>willSet</code>或者<code>didSet</code>，可以两者都用，或者只用其中之一。</p><p><code>willSet</code>在值被改变前调用，<code>didSet</code>在值被改变后调用。</p><p>如果你实现<code>willSet</code>的话，新值将会作为常量参数传入。你可以给参数名字，如果不给名字，默认就是<code>newValue</code></p><p>同样地，实现<code>didSet</code>的话，旧值作为常量参数传入。你可以给参数名字，如果不给名字，默认就是<code>oldValue</code></p><p>这里有一些关于继承的note，暂时不摘过来了。例子：</p></li></ul><p>  <strong>注意一下,didSet之后，你可以直接使用变量的名字，那里面放的就是新值</strong></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepCounter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;将 totalSteps 的值设置为 <span class="subst">\(newTotalSteps)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps <span class="operator">&gt;</span> oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;增加了 <span class="subst">\(totalSteps <span class="operator">-</span> oldValue)</span> 步&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 200</span></span><br><span class="line"><span class="comment">// 增加了 200 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">360</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 360</span></span><br><span class="line"><span class="comment">// 增加了 160 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">896</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 896</span></span><br><span class="line"><span class="comment">// 增加了 536 步</span></span><br></pre></td></tr></table></figure><p>  注意这个属性是存储属性。每次被赋予新值的时候，（即使新值等于旧值），willSet和didSet都会被调用。</p><blockquote><p>If you pass a property that has observers to a function as an in-out parameter, the <code>willSet</code> and <code>didSet</code> observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</p></blockquote><p>  如果将带有观察器的属性通过 in-out 方式传入函数，<code>willSet</code> 和 <code>didSet</code> 也会调用。这是因为 in-out 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p></li></ul><ul><li><p>property wrapper</p><p>  当使用属性包装器时，你只需在定义属性包装器时编写一次管理代码，然后应用到多个属性上来进行复用。</p><p>  为了定义一个property wrapper，你可以定义一个结构体，枚举，类，定义一个属性wrappedValue。<code>TwelveOrLess</code> 结构体确保它包装的值始终是小于等于 12 的数字。如果要求它存储一个更大的数字，它则会存储 12 这个数字。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TwelveOrLess</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number <span class="operator">=</span> <span class="built_in">min</span>(newValue, <span class="number">12</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里<code>wrappedValue</code>被定义为计算变量，set保证了设置的值不会超过12.</p><blockquote><p>You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute.</p></blockquote><p>  你可以应用一个包装器，通过把他的名称写在属性之前，如这里<code>@TwelveOrLess</code>。通过 <code>TwelveOrLess</code> 属性包装器来确保它的长宽均小于等于 12。==值得注意的一点，==The <code>height</code> and <code>width</code> properties get their initial values from the definition of <code>TwelveOrLess</code>, which sets <code>TwelveOrLess.number</code> to zero.这里height的初值应该还是来自12这个结构体的计算变量。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rectangle <span class="operator">=</span> <span class="type">SmallRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;12&quot;</span></span><br></pre></td></tr></table></figure><p>  下面这串代码和我们写属性包装器的效果是一样的。_height是一个<code>TwelveOrLess</code>实例，这个版本将其属性明确地包装在 <code>TwelveOrLess</code> 结构体中，而不是把 <code>@TwelveOrLess</code> 作为特性写下来：现在理解为什么叫属性包装器了吧。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _height <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _width <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _height.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _height.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _width.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _width.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ==因为属性包装器语法只是具有 getter 和 setter 的属性的语法糖==</p></li></ul><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>方法，我感觉就是定义在类，结构体，枚举类型里的函数？</p><p>分为<code>instance methods</code>，实例化后使用；和<code>type methods</code>，感觉和静态的类似？</p><ul><li><p>一个非常重要的理解，<strong>self是一个instance</strong>，这对报初始化错的理解有帮助</p></li><li><p><code>instance methods</code>就是C那一套，不多说了。</p><p>  一个instance method可以有隐式地访问其他的instance method和properties，只能由实例调用。再一个，可以重名写（参数类型不一样就可以？），如下。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>(<span class="params">by</span> <span class="params">amount</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        count <span class="operator">+=</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">        count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Every instance of a type has an implicit property called <code>self</code>, which is exactly equivalent to the instance itself. You use the <code>self</code> property to refer to the current instance within its own instance methods.</p></blockquote><p>  每一个类型的实例，有一个隐式的属性，叫做<code>self</code>。与类型本身完全一致，可以用self在method里作为本身的指代。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其实不需要显示的写<code>self</code>，swift会自己进行推断。例外在，method的参数和外部的参数冲突，可以使用self</p></li></ul><ul><li><p>上文中<strong>在method里对属性直接修改的是class</strong></p><blockquote><p>Structures and enumerations are <em>value types</em>. By default, the properties of a value type can’t be modified from within its instance methods.</p></blockquote><p>  这又是一个很奇怪的属性，由于结构体和枚举类型是value type。默认的他们的属性的值，不能够被instance method修改，要在method前使用<code>mutating</code>关键字。很奇怪的特性，因为对于变量结构体而言，他的属性可以在外部直接修改，在method里却不能直接改。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The point is now at (3.0, 4.0)&quot;</span></span><br></pre></td></tr></table></figure><p>  而且</p><blockquote><p>The method can also assign a completely new instance to its implicit <code>self</code> property, and this new instance will replace the existing one when the method ends.</p></blockquote><p>  这个方法会返回一个新的实例来替代<code>self</code>，所以有另一种写法。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x: x <span class="operator">+</span> deltaX, y: y <span class="operator">+</span> deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们之前在enum章节，已经介绍过在枚举类型的method里，可以用switch self。在这里也有一个应用，用在mutating的method里</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriStateSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight <span class="operator">=</span> <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .off</span></span><br></pre></td></tr></table></figure></li><li><p>type methods. 与instance methods不同，不需要实例化，基于类型调用。<strong>不能基于实例去调用</strong></p><blockquote><p>You indicate type methods by writing the <code>static</code> keyword before the method’s <code>func</code> keyword. Classes can use the <code>class</code> keyword instead, to allow subclasses to override the superclass’s implementation of that method.</p></blockquote><p>  在方法前加上<code>static</code>，就是type methods。但是在类里，可以使用<code>class</code>关键字，去允许子类覆盖超类中方法的实现。</p><p>  允许直接用类名去调用type methods</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">someTypeMethod</span>() &#123;</span><br><span class="line">        <span class="comment">// type method implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure><blockquote><p>Within the body of a type method, the implicit <code>self</code> property refers to the type itself, rather than an instance of that type. This means that you can use <code>self</code> to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</p></blockquote><p>  在type method里，==self属性指的是type本身，所以可以直击在里面直接使用静态的属性==并不是实例。所以如同上文一样，你可以用self来避免命名的重复。</p></li></ul><ul><li><p><code>type method</code>里使用其他的type method和type properties，而不用使用type名作为前缀。==实验了一下，非静态的属性不能用在type method里，会报错。Instance member ‘currentLevel’ cannot be used on type ‘LevelTracker’==</p><p>  同样在instance method中也不能直接访问静态的属性，要加上类或者结构体的名称。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LevelTracker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">unlock</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> level <span class="operator">&gt;</span> highestUnlockedLevel &#123; highestUnlockedLevel <span class="operator">=</span> level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">isUnlocked</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level <span class="operator">&lt;=</span> highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">advance</span>(<span class="params">to</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel <span class="operator">=</span> level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="subscripts"><a href="#subscripts" class="headerlink" title="subscripts"></a>subscripts</h2><p>access the elements of a collection</p><p>语法，使用subscipt关键字，后跟参数以及返回类型（有点像函数）。内部有点像计算变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的下标值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The type of <code>newValue</code> is the same as the return value of the subscript. <code>newValue</code>的类型和下标的返回值一致。下面的例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TimesTable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier <span class="operator">*</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable <span class="operator">=</span> <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;six times three is 18&quot;</span></span><br></pre></td></tr></table></figure><p>下标可以接受任意数量的参数，这些参数可以是任意类型的，返回值也可以是任意类型的。</p><h2 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h2><p>不继承自其它的类称为base class</p><p>子类可以为继承来的实例方法，类方法，实例属性，类属性，或下标提供自己定制的实现。如果要override，必须加上override关键字。</p><p>你可以提供定制的 getter（或 setter）来重写任何一个继承来的属性，无论这个属性是存储型还是计算型属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必须将它的名字和类型都写出来。</p><p>还可以为继承来的属性设置属性观察器，</p><p>把属性方法或者下标定义成final，来防止被重写。</p><h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2><ul><li><blockquote><p>Classes and structures <em>must</em> set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties can’t be left in an indeterminate state.</p></blockquote><p>  类和结构体的<code>存储属性</code>，在创建一个实例后，==必须有一个初始值。==可以通过初始化器，也可以通过赋默认的属性值。</p><p>  通过初始化器初始化</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The default temperature is 32.0° Fahrenheit&quot;</span></span><br></pre></td></tr></table></figure><p>  通过属性的默认值初始化</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自定义初始化，初始化器可以引入argument label和parameter name，==如果写了label，那么在调用时一定要进行调用，也就是说在目前这个例子里，<code>Celsius(30.0)来初始化是错的，因为两个初始化器都有label</code>==</p><p>  如下，温度转化的例子</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius is 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius is 0.0</span></span><br></pre></td></tr></table></figure><p>  如果不想写label，还是和之前函数章节描述的一样，使用下划线</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">celsius</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature <span class="operator">=</span> <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius is 37.0</span></span><br></pre></td></tr></table></figure><p>  但是值得注意的是，我如果把从开尔文的温度转化也去掉label名字，这样就会存在初始化器的冲突现象出现。<code>init(_ kelvin: Double)</code>和<code>init(_ celsius: Double)</code>被认为是一样的。</p></li></ul><ul><li><p>optional 类型的属性，在初始化时，会被自动的定义为nil，可以在实例化之后为其赋值。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese?&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// Prints &quot;Do you like cheese?&quot;</span></span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;Yes, I do like cheese.&quot;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>只要在初始化结束之前为常量属性赋值即可，一旦常量属性被赋了一个值，就不能再修改。对于类来说，常量属性只能被这一级的类修改，不能被子类修改。</li></ul><ul><li><blockquote><p>Structure types automatically receive a <em>memberwise initializer</em> if they don’t define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values.</p></blockquote><p>  即使你没有给结构体提供构造器和默认值，他也会自动有一个<code>memberwise initializer </code></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>  当你调用memberwise initializer时，可以忽略已有默认值的属性。如下，可以忽略<code>width</code>，也可以把<code>width</code>和<code>height</code>都忽略。</p></li></ul><ul><li><p>==注意一下，==对于结构体和类来说，如果为所有的属性提供了默认值，但又没有提供初始化器，就会获得一个<code>default initializer</code>，不需要任何参数。<strong>结构体除此之外，就算 他不给属性提供默认值，他也会获得一个默认的<code>memberwise initializer</code>，这个是需要写label的</strong>。这两者有一些细微的差距。当然对于结构体，前者也可以理解为后者的忽略已有值的简写。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default initializer</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Size</span>() <span class="comment">//没写参数</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">3</span>, height: <span class="number">5</span>)  <span class="comment">// memberwise</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>这是==两个==构造器，这种情况是允许存在的。就是label的名字不同，竟然编译器就认为这是两个构造器</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span>, height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        width <span class="operator">=</span> a</span><br><span class="line">        height <span class="operator">=</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">c</span>: <span class="type">Int</span>, <span class="params">d</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        width <span class="operator">=</span> c</span><br><span class="line">        height <span class="operator">=</span> d</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>initializer delegation for value type</p><p>  大概意思就是，在一个<code>init()</code>里可以调其他的构造器。</p><p>  构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为<em>构造器代理</em>，它能避免多个构造器间的代码重复。</p><p>  对于值类型，你可以使用 <code>self.init</code> 在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用 <code>self.init</code>。</p><p>  请注意，如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。</p><p>  我们还是看例子吧</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里提供了三个构造器。</p><p>  第一个<code>init()</code>，和什么参数都没有的默认构造器一样。会自动赋默认值。</p><p>  第二个<code>init(origin:size:)</code>，和memberwise的构造器一样</p><p>  第三个<code>init(center:size:)</code>，注意和因为label不一样，上面的构造器是不一样的。在这个构造器里使用<code>self.init</code>调用了上一个构造函数。</p></li></ul><ul><li><p>类的继承和初始化</p><p>  swift定义了两种初始化器，保证了所有的存储属性都有初始化值。<code>designated initializers</code>和<code>convenience intializers</code>指定构造器和便利构造器。</p><p>  <em>指定构造器</em>是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器==让构造过程沿着父类链继续往上进行。==</p><p>  每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p></li><li><p>指定构造器语法和便利构造器语法</p><p>  Designated initializer</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  便利构造器要加上<code>convenience</code>关键字</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类类型的构造器代理</p><p>  ==三条规则。==</p><p>  指定构造器必须调用其直接父类的的指定构造器。</p><p>  便利构造器必须调用<em>同</em>类中定义的其它构造器。</p><p>  便利构造器最后必须调用指定构造器。</p><blockquote><p>指定构造器必须总是<em>向上</em>代理</p><p>便利构造器必须总是<em>横向</em>代理</p></blockquote><p>  如图</p><p>  ![截屏2023-03-10 15.33.27](swift-programming-language笔记.assets/截屏2023-03-10 15.33.27.png)</p></li><li><p>两段式初始化</p><p>  第一阶段，每一个存储属性必须被赋予初值，通过引入他的类。在所有存储属性有初值之后，进入第二阶段，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p><p>  四条规则总结，1 2条对于指定构造器，必须先把本层类引入的存储属性初始化，然后这时候必须交给父类的构造器，然后才能修改继承来的属性。3 条 便利构造器，必须先调用同级的其他构造器，然后才能修改属性值。 4 条 在第一阶段完成之前，一个构造器不能访问self的值，或者instance方法。</p></li><li><p>构造的两个阶段</p><p>  自底向上调用父类的构造器</p><blockquote><p>类的某个指定构造器或便利构造器被调用。</p><p>完成类的新实例内存的分配，但此时内存还没有被初始化。</p><p>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</p><p>指定构造器切换到父类的构造器，对其存储属性完成相同的任务。</p><p>这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。</p><p>当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</p></blockquote><p>  第二阶段，</p><blockquote><ul><li>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access <code>self</code> and can modify its properties, call its instance methods, and so on.</li><li>Finally, any convenience initializers in the chain have the option to customize the instance and to work with <code>self</code>.</li></ul></blockquote><p>  自定向下所有的存储属性已经全部有值了。现在指定构造器能够自己修改实例了，构造器也能访问到self并且修改他了。便利构造器也可以自定义实例了。</p></li></ul><ul><li><p>Swift 中的子类默认情况下不会继承父类的构造器。</p><blockquote><p>父类的构造器仅会在安全和适当的某些情况下被继承。</p></blockquote><p>  当你写一个子类构造器匹配父类的<strong>指定</strong>构造器，你就是在override。</p><p>  当你重写一个父类的指定构造器时，你总是需要写 <code>override</code> 修饰符。</p><p>  当你写了一个子类匹配父类的<strong>便利</strong>构造器，由于子类不能直接调用父类的便利构造器，因此这不是重写，不用写override。</p><p>  例子，我们定义了一个行驶工具类</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  子类自行车继承并重写了默认的构造函数</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels <span class="operator">=</span> <span class="number">2</span>  <span class="comment">// 第二阶段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ==如果子类在第二阶段，不自定义操作，可以省略<code>super.init()</code>==，如下</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hoverboard</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">color</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.color <span class="operator">=</span> color</span><br><span class="line">        <span class="comment">// 隐式调用</span></span><br><span class="line">        <span class="comment">// super.init() implicitly called here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">super</span>.description)</span> in a beautiful <span class="subst">\(color)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>构造器的自动继承</p><p>  默认情况下，子类不会继承父类的构造器。但是，有两个规则会适用。</p><p>  规则1：如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</p><p>  规则2：If your subclass provides an implementation of all of its superclass designated initializers — either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition — then it automatically inherits all of the superclass convenience initializers.如果子类提供了<strong>所有</strong>超类的指定构造器的实现（不管是不是通过规则1继承来的），那么他将自动的实现超类所有的便利构造器</p></li></ul><ul><li><p>Failable initializers</p><p>  就是有时候传入无效的参数（如类型转化），或者缺少某种外部资源，构造器会失败。以return nil来表示构造器失败。</p><p>  这个例子类型转化就失败了，返回了nil。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wholeNumber: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12345.0</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> valueMaintained <span class="operator">=</span> <span class="type">Int</span>(exactly: wholeNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(wholeNumber)</span> conversion to Int maintains value of <span class="subst">\(valueMaintained)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;12345.0 conversion to Int maintains value of 12345&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> valueChanged <span class="operator">=</span> <span class="type">Int</span>(exactly: pi)</span><br><span class="line"><span class="comment">// valueChanged is of type Int?, not Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valueChanged <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(pi)</span> conversion to Int doesn&#x27;t maintain value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;3.14159 conversion to Int doesn&#x27;t maintain value&quot;</span></span><br></pre></td></tr></table></figure><p>  用<code>init?</code>表示表示构造器可能会失败，如下，当传入的字符串为空时，会触发构造器失败。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">species</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species <span class="operator">=</span> species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>required initializers</p><p>  在类中用required关键字修饰初始化器，要求该类的所有子类都要实现这个构造器</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在子类重写父类的必要构造器时，必须在子类的构造器前也添加 <code>required</code> 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubclass</span>: <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过闭包或者函数设置属性的<strong>默认值</strong></p><p>  这一章<strong>很新</strong></p><p>  ==这样可以避免了，我们使用property initilizer时无法调用一个内容与self无关的method，直接写一个闭包，同时也避免了写成全局太难看==</p><p>  我们可以使用闭包或者<strong>全局</strong>函数为==存储==属性提供默认值。（这和计算属性是有很大不同的）。通过闭包或者函数的返回值，来作为属性的默认值。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()  <span class="comment">// 这个花括号很重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ==注意闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。==</p><blockquote><p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 <code>self</code> 属性，或者调用任何实例方法。</p></blockquote></li></ul><ul><li><p>只读计算属性computated propertues 和 通过闭包设置存储属性的默认值的区别</p><p>  先总结一下区别：</p><ol><li><p>计算属性不需要初始化，闭包赋值针对是默认初始化的赋值</p></li><li><p>计算属性的花括号里可以访问self即其相关属性或方法，闭包赋值的花括号里是不能访问self的。（我的理解，property initializer里面都不能访问self）</p></li><li><p>计算属性后面没有<code>=</code>，也有末尾的<code>()</code></p><p>相同点，花括号里都能定义局部变量等。</p></li></ol></li></ul><h2 id="deinitialization"><a href="#deinitialization" class="headerlink" title="deinitialization"></a>deinitialization</h2><p>析构函数，只需用于类类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// perform the deinitialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类<strong>最多只有一个</strong>析构函数。Deinitializers are called automatically, just before instance deallocation takes place.在实例被释放前，将会被自动调用。</p><p>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation. Superclass deinitializers are always called, even if a subclass doesn’t provide its own deinitializer.</p><p>超类的析构函数会被子类继承，超类的析构函数会在子类析构函数实现的最后被自动调用。超类的析构函数总是会被调用，即使一个子类没有提供自己的析构函数。</p><h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><p>先简单说一点。一个optional 类型变量想要通过dot也就是点<code>.</code>来访问方法，属性或者访问下标 或者 通过下标来访问。但是，又不想通过强制解包或者optional binding来先判断这个optional 类型是否是<code>nil</code>，就是不管，直接往下继续访问。</p><blockquote><p>也就是说optional类型变量，后面加个问号，就能当做正常变量一样，继续往后写东西。如，<code>a?.xxx</code>，<code>a?[0]</code></p></blockquote><p>看两个简单例子起，变量<code>c</code>是<code>String</code>类型，它调用函数<code>hasPrefix()</code>返回的是bool值。也就是说，变量<code>d</code>的类型是<code>Bool</code>类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c.hasPrefix(<span class="string">&quot;e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>现在我们将变量<code>c</code>变为<code>String?</code>类型，按理说，他要是想要调用函数，只能强制解包后，才能调用。但是这样如果<code>c</code>是nil的话，就会引发运行时错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line">c<span class="operator">!</span>.hasPrefix(<span class="string">&quot;e&quot;</span>)  <span class="comment">// 强制解包</span></span><br></pre></td></tr></table></figure><p>我们可以通过optinal chaining，不解包就调用函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c<span class="operator">?</span>.hasPrefix(<span class="string">&quot;a&quot;</span>)  <span class="comment">// 注意这里的返回类型，为Bool?</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment">// Optional(true)</span></span><br></pre></td></tr></table></figure><p>但是由于<code>c</code>有可能是nil，所以最后返回的类型，是我们期望正常返回类型的optional类型。在这里是<code>Bool?</code>。如果<code>c</code>不是nil，那么<code>d</code>这个<code>Bool?</code>类型就有值。</p><p>如果<code>c</code>是nil，那么<code>d</code>这个<code>Bool?</code>类型就是<code>nil</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c<span class="operator">?</span>.hasPrefix(<span class="string">&quot;a&quot;</span>)  <span class="comment">// 注意这里的返回类型，为Bool?</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure><p>例子2，字典的下标访问</p><p>字典取值返回的是optional类型，如果key里放的是数组，想要进一步通过下标访问数组元素。同样的做法，optional chaining</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores <span class="operator">=</span> [<span class="string">&quot;Dave&quot;</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">&quot;Bev&quot;</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">&quot;Dave&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">91</span></span><br><span class="line">testScores[<span class="string">&quot;Bev&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">testScores[<span class="string">&quot;Brian&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">72</span></span><br><span class="line"><span class="comment">// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure><p>前两个调用成功。==第二个调用有点奇怪？？==我的理解是，optinal类型可以被赋值，但是能直接这么加1吗？普通变量这么加肯定是错的</p><ul><li><p>例子举完了。我们先说最后的总结吧</p><p>  optional chaining是可以连接很多很多层的，但是最后的返回类型只和最后一个调用的返回类型相关，并变成optional类型。</p><blockquote><p>也就是说：</p><ul><li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li><li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li></ul><p>因此：</p><ul><li>通过可选链式调用访问一个 <code>Int</code> 值，将会返回 <code>Int?</code>，无论使用了多少层可选链式调用。</li><li>类似的，通过可选链式调用访问 <code>Int?</code> 值，依旧会返回 <code>Int?</code> 值，并不会返回 <code>Int??</code>。</li></ul></blockquote></li></ul><ul><li><blockquote><p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回 <code>nil</code> 则说明调用失败。</p><p>这里需要特别指出，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是 <code>Int</code> 类型，则会变为 <code>Int?</code> 类型。</p></blockquote></li></ul><ul><li><p>看一个访问属性的简单例子</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">!</span>.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;  <span class="comment">// 使用optional chaining</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>除了可以访问属性，还可以为属性赋值，如</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress</span><br></pre></td></tr></table></figure><p>  上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，==等号右侧的代码不会被执行。==上面等号右边是常量，看不出来。假如改成函数调用，函数将不会调用，体现在没有执行中间的打印语句。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">createAddress</span>() -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function was called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">    someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> createAddress()</span><br></pre></td></tr></table></figure><p>  没有任何打印消息，可以看出 <code>createAddress()</code> 函数并未被执行</p></li></ul><ul><li><p>除了访问属性，为属性赋值。还可以调用method</p><p>  假如调用的方法是有返回值的，会返回对应的optional类型。如果没有返回值，即返回<code>Void</code>类型，那么也会返回对应的<code>Void?</code>.对于无返回值类型的，可以判断是否等于<code>nil</code>。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence<span class="operator">?</span>.printNumberOfRooms() <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure><p>  通过可选链式调用给属性赋值会返回 <code>Void?</code>，通过判断返回值是否为 <code>nil</code> 就可以知道赋值是否成功：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress) <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to set the address.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to set the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="error-handling"><a href="#error-handling" class="headerlink" title="error handling"></a>error handling</h2><p>一般用枚举类型来标记一组错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">VendingMachineError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> invalidSelection</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> outOfStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再代码里用<code>throw</code>抛出一组错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如下函数定义了跑出不同的错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">vend</span>(<span class="params">itemNamed</span> <span class="params">name</span>: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item <span class="operator">=</span> inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.price <span class="operator">&lt;=</span> coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price <span class="operator">-</span> coinsDeposited)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用这个函数时，也要写明try，因为这个函数有可能会抛出错误。嵌套有这个函数的函数，也要写明throw</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">buyFavoriteSnack</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">vendingMachine</span>: <span class="type">VendingMachine</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> snackName <span class="operator">=</span> favoriteSnacks[person] <span class="operator">??</span> <span class="string">&quot;Candy Bar&quot;</span></span><br><span class="line">    <span class="keyword">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用do-catch来捕获并处理错误。如果一条 <code>catch</code> 子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为 <code>error</code>的局部常量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">3</span>, pattern <span class="number">4</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Do-catch语句并不一定要处理所有的错误，如果是定义在有throw的函数里，可以继续把不能处理的错误向外传播。</p><p>将错误转化为optional类型，也就是转为nil。使用<code>try?</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someThrowingFunction</span>() <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> <span class="keyword">try?</span> someThrowingFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="keyword">try</span> someThrowingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x和y意义一致。使用<code>try?</code>调用可能会抛出错误的函数时，x的类型是返回值对应的optinal类型，这里是<code>Int?</code></p><h2 id="Nested-Types"><a href="#Nested-Types" class="headerlink" title="Nested Types"></a>Nested Types</h2><p>就是我们作业中，在结构体Model中，又定义了结构体Card。</p><p>类，枚举类型，结构体都可以进行嵌套。</p><h2 id="Extentions"><a href="#Extentions" class="headerlink" title="Extentions"></a>Extentions</h2><p><em>扩展</em>可以给一个现有的类，结构体，枚举，还有协议添加新的功能。</p><p>Swift 中的扩展可以：</p><ul><li>添加<strong>计算型</strong>实例属性和<strong>计算型</strong>类属性，注意不能定义存储属性</li><li>定义实例方法和类方法</li><li>提供新的构造器</li><li>定义下标</li><li>定义和使用新的嵌套类型</li><li>使已经存在的类型遵循（conform）一个协议</li></ul><ul><li><p>添加计算属性</p><p>  因为Doube, Int等都是struct实现的，这里为Double添加了计算类型。</p><blockquote><p>extention里是可以访问到self的，甚至能<strong>访问private属性</strong></p></blockquote>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure><p>  可以在浮点数字面量上，如<code>25.4</code>调用新的计算属性。当然也可以在字面常量或者变量上调用。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">25.4</span></span><br><span class="line">a.mm  <span class="comment">// 值为0.0254</span></span><br></pre></td></tr></table></figure><blockquote><p>注意</p><p>扩展可以添加新的计算属性，但是它们不能添加存储属性，也不能向现有的属性添加属性观察者。</p></blockquote></li></ul><ul><li><p>扩展构造器</p><p>  extension可以提供一个新的便利构造器，但是不能提供一个指定构造器和析构器给一个类。指定构造器和析构器必须由原始的类实现。</p><p>  如果一个结构体没写构造器，但是你扩展了，这样不会覆盖默认的构造器和memberwise的构造器。你可以在自己写的构造器里调用他们。</p><p>  我举个自己的例子吧，可以在扩展的构造器里，利用<code>self</code>调用已有的初始化器。举的例子适用于结构体，不适用于类，假如是类，会出现指定的构造器的错。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">e</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        a <span class="operator">=</span> e <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">b</span>: <span class="type">Int</span>, <span class="params">c</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(e: <span class="number">15</span>)  <span class="comment">// 调用了已有的初始化器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp <span class="operator">=</span> <span class="type">Size</span>(b: <span class="number">1</span>, c: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp.a)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>  如果结构体没有自己定义的初始化器，还可以在extension的初始化器里，调用Default的和memberwise的构造器。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">b</span>: <span class="type">Int</span>, <span class="params">c</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp <span class="operator">=</span> <span class="type">Size</span>(b: <span class="number">1</span>, c: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>扩展方法</p><p>  很简单的例子</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  可以在Int类型的字面量或者常量变量上调用</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure><p>  由于Int底层是struct，可以通过mutating方法来修改self</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">square</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 现在是 9</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>下标不熟，先跳过一下</li></ul><ul><li><p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型</p><p>  如下为Int添加新的枚举嵌套类型</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  通过计算属性kind，可以为Int类型变量提供枚举类型返回值</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printIntegerKinds</span>(<span class="keyword">_</span> <span class="params">numbers</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0 &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;+ &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, <span class="operator">-</span><span class="number">27</span>, <span class="number">0</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印“+ + - 0 - 0 + ”</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h2><p>属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型遵循协议，称为<em>conform</em>。</p><p>还能对协议进行拓展，也能对一个类型拓展，使它额外遵循某个协议。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>协议的定义，注意因为protocol也能看成是一种type，所以要==大写==命名。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line"><span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类型可以遵循多个协议，可以用都喊分隔开来。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span>: <span class="title class_">FirstProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line"><span class="comment">// 这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类有父类，因为要继承，要先写父类的名字再写协议的名字，还是用逗号分隔。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">FirstProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line"><span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议对属性的要求"><a href="#协议对属性的要求" class="headerlink" title="协议对属性的要求"></a>协议对属性的要求</h3><p>协议并不指明要求属性不要求属性是stored还是computated。</p><p>但他会要求是instance还是type，以及需要满足变量名name和type。还会要求满足set和get。</p><p>针对set get两种情况，<code>set get</code>可读可写，<code>set</code>可读。如果要求可读，但是实现时是可读可写也满足需求。</p><p>例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line"><span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;  <span class="comment">// 可读可写</span></span><br><span class="line"><span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议要求有type 属性。在类中实现时，也可以用class关键字代替static，以便可以被子类修改？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型想要conform协议FullyNamed，需要有一个名字叫fullname的String类型变量，且满足可读。</p><p>实现，类型Person conforms 协议FullyNamed。这里使用了stored属性，使用computed属性也是可以的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>(fullName: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// john.fullName 为 &quot;John Appleseed&quot;</span></span><br></pre></td></tr></table></figure><h3 id="协议对方法的要求"><a href="#协议对方法的要求" class="headerlink" title="协议对方法的要求"></a>协议对方法的要求</h3><p>同上，协议会要求方法是instance还是type的。会要求method的名字以及类型，会要求参数名，label名吗？但是<strong>不需要花括号以及方法的实现</strong>，不允许默认参数值</p><p>如下的例子，label名字必须一样，但是可以改parameter name。在这个例子里也就是，<code>from</code>和<code>to</code>必须一样，但是下面可以改成<code>c</code>和<code>d</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNum</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>(<span class="params">from</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">to</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>: <span class="title class_">RandomNum</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>(<span class="params">from</span> <span class="params">c</span>: <span class="type">Int</span>, <span class="params">to</span> <span class="params">d</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于结构体和枚举类型，如果协议期望的实现的方法需要改变值，需要加上mutating关键字。但是一个class conform这个协议，他实现这个方法时，不需要加上mutating</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OnOffSwitch</span>: <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, on</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .on</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch <span class="operator">=</span> <span class="type">OnOffSwitch</span>.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .on</span></span><br></pre></td></tr></table></figure><h3 id="协议对构造器的要求"><a href="#协议对构造器的要求" class="headerlink" title="协议对构造器的要求"></a>协议对构造器的要求</h3><p>如下，只需要给出构造器名字init以及参数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h3><p>作为类型，要用大写字母开头命名</p><p>协议可以像其他普通类型一样使用，使用场景如下：</p><ul><li>作为函数、方法或构造器中的参数类型或返回值类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器中的元素类型</li></ul><p>比如说，一个变量的类型是<code>RandomNumberGenerator</code>协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dice</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roll</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实例只要conform这个<code>RandomNumberGenerator</code>协议，都可以赋给这个变量。并且由于其类型是 <code>RandomNumberGenerator</code>，所以在 <code>Dice</code> 类中与 <code>generator</code> 交互的代码，必须适用于所有遵循该协议的 <code>generator</code> 实例。<strong>这意味着不能使用由 <code>generator</code> 的底层类型定义的任何方法或属性。</strong>如果要是判断底层类型，可以用<code>is</code>吗？还有后面的as?有点记不清了</p><h3 id="委托delegation"><a href="#委托delegation" class="headerlink" title="委托delegation"></a>委托delegation</h3><p>大概意思就是说用协议来实现委托的设计模式。</p><h3 id="使用extension为类型添加拓展"><a href="#使用extension为类型添加拓展" class="headerlink" title="使用extension为类型添加拓展"></a>使用extension为类型添加拓展</h3><p>就是说，原来的类型可能没有遵循某一个协议，仍然可以通过extension来添加协议，注意扩展是可以访问到self的，实验过，即使是private变量也能访问到</p><p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。</p><blockquote><p>注意</p><p>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p></blockquote><p>通过扩展遵循并采纳协议，和在原始定义中遵循并符合协议的效果完全相同。</p><p>如，下面新的扩展</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以令Dice类遵循这个新的扩展</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Dice</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A <span class="subst">\(sides)</span>-sided dice&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>就是使用where语句</p><p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 <code>where</code> 分句。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">TextRepresentable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure><h3 id="decalring-protocol-adoption-with-an-extension"><a href="#decalring-protocol-adoption-with-an-extension" class="headerlink" title="decalring protocol adoption with an extension"></a>decalring protocol adoption with an extension</h3><p>意思就是如果一个type已经满足了遵循一个protocol的条件（在这里是有了变量textualDescription），但是他却没有显示的声明要遵循这个协议。那么可以在extension中声明，却不需要在花括号里做任何的实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hamster</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Hamster</span>: <span class="title class_">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>经过extension之后，Hamster已经conform这个协议TextRepresentable</p><h3 id="adopting-a-protocol-using-a-synthesized-implementation"><a href="#adopting-a-protocol-using-a-synthesized-implementation" class="headerlink" title="adopting a protocol using a synthesized implementation"></a>adopting a protocol using a synthesized implementation</h3><p>Swift 可以自动提供一些简单场景下遵循 <code>Equatable</code>、<code>Hashable</code> 和 <code>Comparable</code> 协议的实现。也就是说，只要满足条件，你只需遵循这几个协议，但是却不需要自己取实现。</p><p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p><ul><li>遵循 <code>Equatable</code> 协议且只有存储属性的结构体。（结构体中只有存储属性，且存储属性的）</li><li>遵循 <code>Equatable</code> 协议且只有关联类型的枚举</li><li>没有任何关联类型的枚举</li></ul><p>满足<code>Equatable</code>类型也就是可以使用<code>==</code>和<code>!=</code></p><p>如下结构体的存储属性，全都满足<code>Equatable</code>，所以直接conform这个协议就好</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;These two vectors are also equivalent.&quot;</span></span><br></pre></td></tr></table></figure><p><code>Hashable</code>和<code>Equatable</code>用的场景一样</p><p>Swift 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。</p><p>这个例子其实没太看到，有关联值可以比较能够理解，为什么没有值的case也能排序？？？好像是按照从上到下的顺序排的？有什么意义呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SkillLevel</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> beginner</span><br><span class="line">    <span class="keyword">case</span> intermediate</span><br><span class="line">    <span class="keyword">case</span> expert(stars: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> levels <span class="operator">=</span> [<span class="type">SkillLevel</span>.intermediate, <span class="type">SkillLevel</span>.beginner,</span><br><span class="line">              <span class="type">SkillLevel</span>.expert(stars: <span class="number">5</span>), <span class="type">SkillLevel</span>.expert(stars: <span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> levels.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(level)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;beginner&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;intermediate&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 3)&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 5)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h3><p>协议也可以在数组或者字典这样的集合中使用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] <span class="operator">=</span> [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure><p>就是只要instance满足协议类型，即可加入到集合中去。</p><h3 id="protocol-inheritance"><a href="#protocol-inheritance" class="headerlink" title="protocol inheritance"></a>protocol inheritance</h3><p>协议的继承和类的继承类似，但是可以继承一个或者多个协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InheritingProtocol</span>: <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// protocol definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如一个type遵循这个协议，同时也必须要遵循他的父协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_">PrettyTextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> textualDescription <span class="operator">+</span> <span class="string">&quot;:<span class="subst">\n</span>&quot;</span>  <span class="comment">// 访问了父协议的属性？？</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▲ &quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake <span class="operator">&lt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▼ &quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;○ &quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrettyTextRepresentable，它继承自 <code>TextRepresentable</code> 协议。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。</p><h3 id="类专属协议class-only-protocols"><a href="#类专属协议class-only-protocols" class="headerlink" title="类专属协议class-only protocols"></a>类专属协议class-only protocols</h3><p>只能给类使用的协议，要继承一下<code>AnyObject</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_">AnyObject</span>, <span class="title class_">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="protocol-composition-协议组合"><a href="#protocol-composition-协议组合" class="headerlink" title="protocol composition 协议组合"></a>protocol composition 协议组合</h3><p>一个类型是可以遵循多个协议的，只需要用逗号分隔开就可以。协议组合的类型可以看成一个组合类型，使用 <code>SomeProtocol &amp; AnotherProtocol</code> 的形式。你可以列举任意数量的协议，用和符号（<code>&amp;</code>）分开。协议组合也能包含类类型，这允许你标明一个需要的父类。</p><p>例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">Named</span>, <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure><p><code>Person</code> 结构体采纳了这两个协议。<code>wishHappyBirthday(to:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>Named &amp; Aged</code>， 这意味着“任何同时遵循 Named 和 Aged 的协议”。它不关心参数的具体类型，只要参数遵循这两个协议即可。</p><p>刚刚提到了协议组合也可以包含class类型，代表继承父类。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.latitude <span class="operator">=</span> latitude</span><br><span class="line">        <span class="keyword">self</span>.longitude <span class="operator">=</span> longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>: <span class="title class_">Location</span>, <span class="title class_">Named</span> &#123;  <span class="comment">// 继承同时遵循协议</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(latitude: latitude, longitude: longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">beginConcert</span>(<span class="params">in</span> <span class="params">location</span>: <span class="type">Location</span> &amp; <span class="type">Named</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(location.name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> seattle <span class="operator">=</span> <span class="type">City</span>(name: <span class="string">&quot;Seattle&quot;</span>, latitude: <span class="number">47.6</span>, longitude: <span class="operator">-</span><span class="number">122.3</span>)</span><br><span class="line">beginConcert(in: seattle)</span><br><span class="line"><span class="comment">// 打印 &quot;Hello, Seattle!&quot;</span></span><br></pre></td></tr></table></figure><p><code>beginConcert(in:)</code> 函数接受一个类型为 <code>Location &amp; Named</code> 的参数，这意味着“任何 Location 的子类，并且遵循 Named 协议”。</p><h3 id="protocol-extension协议扩展"><a href="#protocol-extension协议扩展" class="headerlink" title="protocol extension协议扩展"></a>protocol extension协议扩展</h3><p>和上面对type扩展，使得type conforms新的协议不同。这里是对协议要求遵循的内容进行扩展。</p><p>扩展协议要同时把属性和方法实现了，不然怎么回到那些遵循协议的类型里去实现？</p><p>如下，值得注意的是，我可以再扩展协议里调用原有协议要求实现的方法或者属性，如下，调用了<code>random()</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">randomBool</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Here&#x27;s a random number: 0.3746499199817101&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;And here&#x27;s a random Boolean: true&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在协议扩展中，对协议要求的属性或者方法进行一个默认的实现。但是如果conforming type提供了自己的实现，就不会使用默认的实现。如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">PrettyTextRepresentable</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为协议扩展添加限制"><a href="#为协议扩展添加限制" class="headerlink" title="为协议扩展添加限制"></a>为协议扩展添加限制</h3><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述</p><h2 id="generics"><a href="#generics" class="headerlink" title="generics"></a>generics</h2><p>以交换两个Int类型数举例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个函数同样使用于交换浮点数，字符串等，只需要改参数的类型。这样就重复写了代码。</p><p>使用泛型会更加合理</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意他们两的差异，一个是在函数名后加了<code>&lt;T&gt;</code>，然后后面参数类型type name变成了<code>T</code>。</p><p>调用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>T</code>叫做<code>type parameter</code>，尽量要使用大写，代表这是类型。它可以替代<em>参数类型，返回类型，也可以用在函数体内部</em></p><blockquote><p>you can use it to define the type of a function’s parameters (such as the <code>a</code> and <code>b</code>parameters of the <code>swapTwoValues(_:_:)</code> function), or as the function’s return type, or as a type annotation within the body of the function. </p></blockquote><p>你可以在尖括号内写多个<code>type parameters</code>，用逗号分开。如<code>Dictionary&lt;Key, Value&gt;</code></p><p>在结构体中使用泛型，如定义一个栈。使用<code>&lt;Element&gt;</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extending-a-generic-type扩展泛型"><a href="#extending-a-generic-type扩展泛型" class="headerlink" title="extending a generic type扩展泛型"></a>extending a generic type扩展泛型</h3><p>对泛型扩展时，并不需要列出定义时<code>&lt;T&gt;</code>（尖括号以及定义在里面的type parameter），但是仍然能在花括号里使用这些type parameter。</p><p>如下，扩展Stack，不需要写<code>&lt;Element&gt;</code>，但是仍然可以在花括号里使用<code>Element</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type-constarints"><a href="#type-constarints" class="headerlink" title="type constarints"></a>type constarints</h3><p>上文中提到的<code>swapTwoValues(_:_:)</code> function and the <code>Stack</code> 适用于任何类型。但是有些时候，需要加上一些<code>constaints</code>来使得类型继承自某个特定类，或者conform每个协议或者协议组合。</p><p>如在<code>Dictionary</code>中，要求<code>Key</code>必须得是<code>Hashable</code>的。如</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type parameter T要求继承类SomeClass，type parameter U要求conform SomeProtocol</p><p>我们先定义了一个在数组中寻找对应String，并返回下标的函数，并用泛型改写他。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>(<span class="params">ofString</span> <span class="params">valueToFind</span>: <span class="type">String</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">String</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写成适用于任何类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;  <span class="comment">// 错</span></span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有错误，我们不能保证T类型是可以使用<code>==</code>的。所以，要使得T conforms 协议<code>Equatable</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关联类型associated value</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这应该相当于协议的泛型，写作<code>associatedtype</code></p></li></ul><ul><li><p>你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 <code>Container</code> 协议， 要求关联类型 <code>Item</code> 必须遵循 <code>Equatable</code> 协议：</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="generic-where-clauses"><a href="#generic-where-clauses" class="headerlink" title="generic where clauses"></a>generic where clauses</h3><p>下次再记</p><h2 id="automatic-reference-counting"><a href="#automatic-reference-counting" class="headerlink" title="automatic reference counting"></a>automatic reference counting</h2><p>每当你创建一个新的<em>类实例</em>时，ARC 会分配一块内存来储存该实例的信息。内存中会包含实例的类型信息，以及这个实例所关联的任何stored properties的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p><p>只要有类实例被引用，ARC就不会释放其在内存的空间。</p><blockquote><p>whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance.</p></blockquote><p>当你==assign==一个类实体给属性，常量变量。就会建立一个<code>strong inference</code>强引用。只要强引用存在，实例就不会被销毁。</p><p>例子，一个类Person</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个optional 类型，这时默认为nil，并不会指向实体</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure><p>通过assign建立了一个强引用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being initialized&quot;</span></span><br></pre></td></tr></table></figure><p>如果我们把这个引用，assgin给另两个optional类型，这样就有了三个强引用</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 <span class="operator">=</span> reference1</span><br><span class="line">reference3 <span class="operator">=</span> reference1</span><br></pre></td></tr></table></figure><p>如果我们释放掉其中的两个引用，包括最开始的那个引用，Person实例并不会释放，因为还有一个强引用指向他</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">reference2 <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>把所有的强引用都释放了，系统会回收这个实例，调用析构函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure><h3 id="strong-reference-cycle"><a href="#strong-reference-cycle" class="headerlink" title="strong reference cycle"></a>strong reference cycle</h3><p>强引用圈通常两个类实例，互相持有对对方的强引用，这样资源就永远不能释放。</p><p>解决方法，不使用强引用，使用弱一点的<code>weak</code>和<code>unowned</code></p><p>强引用的例子</p><p>person实例有属性引用了apartment实例，aparment实例有属性引用了person实例。</p><p>![截屏2023-03-09 16.19.51](swift-programming-language笔记.assets/截屏2023-03-09 16.19.51.png)</p><p>这样就是把外面的指针john和unit4A释放掉（置为nil），互相之间的强引用还是存在。</p><p>![截屏2023-03-09 16.30.45](swift-programming-language笔记.assets/截屏2023-03-09 16.30.45.png)</p><h3 id="resolving-strong-reference"><a href="#resolving-strong-reference" class="headerlink" title="resolving strong reference"></a>resolving strong reference</h3><p>解决强引用的两个方式，<code>weak</code>reference和<code>unowned</code>reference。</p><blockquote><p>Weak and unowned references enable one instance in a reference cycle to refer to the other instance <em>without</em> keeping a strong hold on it. </p><p>Use a weak reference when the other instance has a shorter lifetime — that is, when the other instance can be deallocated first. </p><p>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</p></blockquote><p>使用<code>weak</code>引用，当一方有较短的生命期，一方可能会提前释放资源。对比，使用<code>unowned</code>引用，当双方生命期相同，或者更长的生命期。</p><ul><li><p>weak reference</p><p>  因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。==因此，ARC 会在引用的实例被销毁后自动将其弱引用赋值为 <code>nil</code>。==并且因为弱引用需要在运行时允许被赋值为 <code>nil</code>，所以它们会被定义为可选类型变量，而不是常量。</p><p>  apartment实例对person实例是弱引用，如果指向person实例的强引用销毁，就是john赋值nil，则weak引用自动置为nil.</p><p>  ![截屏2023-03-09 16.30.53](swift-programming-language笔记.assets/截屏2023-03-09 16.30.53.png)</p><p>  ![截屏2023-03-09 16.30.58](swift-programming-language笔记.assets/截屏2023-03-09 16.30.58.png)</p></li><li><p>Unowned reference</p><blockquote><p>Unlike a weak reference, an unowned reference is expected to always have a value. As a result, marking a value as unowned doesn’t make it optional, and ARC never sets an unowned reference’s value to <code>nil</code>.</p></blockquote><p>  一个无主引用<strong>总是期望有值。</strong>因此，无主引用不是optional，ARC也不会将其置为nil。</p><blockquote><p>Use an unowned reference only when you are sure that the reference <em>always</em> refers to an instance that hasn’t been deallocated.</p></blockquote><p>  <strong>使用无主引用，你<em>必须</em>确保引用始终指向一个未销毁的实例。</strong></p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCard</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">number</span>: <span class="type">UInt64</span>, <span class="params">customer</span>: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number <span class="operator">=</span> number</span><br><span class="line">        <span class="keyword">self</span>.customer <span class="operator">=</span> customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Card #<span class="subst">\(number)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以信用卡和客户为例子。信用卡总是用主人，因此有一个无主引用的属性<code>unowned let customer: Customer</code>。还要注意一点是，这里的构造函数，确保了信用卡只有主人才会传进来。</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br><span class="line"></span><br><span class="line">john <span class="operator">=</span> <span class="type">Customer</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">john<span class="operator">!</span>.card <span class="operator">=</span> <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john<span class="operator">!</span>)</span><br></pre></td></tr></table></figure><p>  这样就建立了如下的引用关系</p><p>  ![截屏2023-03-09 16.41.41](swift-programming-language笔记.assets/截屏2023-03-09 16.41.41.png)</p><p>  注意接下来，如果把<code>john=nil</code>，就没有指向customer实体的强引用了，他将被释放。这样也没有强引用会指向creditcard实体了，==也会被释放。==（<em>这里是和weak 引用不同的地方</em>）</p><p>  ![截屏2023-03-09 16.44.23](swift-programming-language笔记.assets/截屏2023-03-09 16.44.23.png)</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;Card #1234567890123456 is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure><p>  调用两个析构函数</p></li></ul><ul><li><p>unowned optional reference</p><p>  上面说的是非optional 类型的无主引用，这里是optional类型的。和weak类似？？但是，必须确保optional类型的无主引用总是指向有效的oject或者被设为nil（是指的是一直不变吗？）不懂。</p></li></ul><ul><li><p><code>Person</code> 和 <code>Apartment</code> 的例子展示了两个属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用==弱引用==来解决。</p><p>  <code>Customer</code> 和 <code>CreditCard</code> 的例子展示了一个属性的值允许为 <code>nil</code>，而另一个属性的值不允许为 <code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过==无主引用==来解决。</p></li></ul><ul><li><p>strong reference cycles for closure</p><p>  闭包的循环强引用</p><blockquote><p>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as <code>self.someProperty</code>, or because the closure calls a method on the instance, such as <code>self.someMethod()</code>. In either case, these accesses cause the closure to “capture” <code>self</code>, creating a strong reference cycle.</p></blockquote><p>  如果你给一个类intance属性assign了一个闭包。当，你访问了self属性，或者访问了self方法，那么你就捕获到了self，创建了一个循环强引用。</p><blockquote><p>This strong reference cycle occurs because closures, like classes, are <em>reference types</em>. When you assign a closure to a property, you are assigning a <em>reference</em> to that closure.</p></blockquote><p>  因为闭包也是引用类型。当你assign一个闭包给属性，你就分配了一个到闭包的引用。</p><p>  ![截屏2023-03-09 19.47.19](swift-programming-language笔记.assets/截屏2023-03-09 19.47.19.png)解决方法<code>cpature list</code>。</p><p>  在capture list里定义unowned引用以及weak引用和类实体里一样的含义。</p><blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p><p>Conversely, define a capture as a weak reference when the captured reference may become <code>nil</code> at some point in the future. Weak references are always of an optional type, and automatically become <code>nil</code> when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p></blockquote><p>  定义无主引用的方式</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure <span class="operator">=</span> &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate]</span><br><span class="line">        (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  一般见到就是用一个方括号写在函数参数的定义之前<code>[weak self]</code></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>self captured by a closure before all members were initialized错误解决</title>
      <link href="/2023/03/05/self-captured-by-a-closure-before-all-members-were-initialized%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/03/05/self-captured-by-a-closure-before-all-members-were-initialized%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>问题1</p><p><em>代码1</em></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toy</span>(<span class="params">create</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        c <span class="operator">=</span> toy &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题可以简化成这样，初始化器里，对c用闭包复制的那一行报了错误<code>&#39;self&#39; captured by a closure before all members were initialized</code></p><span id="more"></span><p>原因，我大概明白了。在于Swift文档，闭包那一章里的值捕获那一节。因为在这个闭包里，使用了<code>self.a</code>或者隐式<code>a</code>，这样就捕获了<code>self</code>instance，而<strong>重点来了</strong>，<code>self</code>这个实例，我们没有对<code>c</code>实例化，而矛盾的是，我们正要对<code>c</code>实例化。其实写成以下<em>代码2</em>形式也是错的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toy</span>(<span class="params">create</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> d <span class="operator">=</span> toy &#123; <span class="keyword">_</span> <span class="keyword">in</span>  <span class="comment">// 还是报同样的错误</span></span><br><span class="line">            a</span><br><span class="line">        &#125;</span><br><span class="line">        c <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也就是说，在这个闭包里，假如捕获（使用）了self的属性，则必须满足self instance已经完全被实例化</strong></p><p>所以针对<em>代码2</em>，自然想到有以下解决方法。</p><ul><li>方法1，在初始化器中把c的值提前赋上（在闭包捕获<code>self</code>实例前）</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toy</span>(<span class="params">create</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        c <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">let</span> d <span class="operator">=</span> toy &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法2 给c一个默认值</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toy</span>(<span class="params">create</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span> <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> d <span class="operator">=</span> toy &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法1，2都保证了，在闭包捕获<code>self</code>实例前，已经完全初始化完成。</p><p>方法3，设成optional类型，或者隐式的optional类型。这样保证了，在初始化实例时，暂时可以不管<code>c</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">toy</span>(<span class="params">create</span>: (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span>?</span><br><span class="line">    <span class="comment">// 或者写成</span></span><br><span class="line">    <span class="comment">// var c: Int!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> d <span class="operator">=</span> toy &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对代码1，方法1显然很多余，我既然能对c赋值，为什么要用闭包复制。方法2，也显得累赘。我觉得使用<code>c!</code>，在一次初始化之后，<code>c</code>就一直会有值，满足我的需求。</p><p>另一种想法是把闭包写成函数是不是，就没有问题啦呢？示例如下</p><p>如果写成类的method，仍然是一样的效果</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">toy</span>() -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> d <span class="operator">=</span> toy()</span><br><span class="line">        c <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第13行<code>let d = toy()</code>报错，<code>&#39;self&#39; used before all stored properties are initialized</code>，错误类似。</p><p>如果我们执意要使用函数，可以把设定成<code>static</code>类型，应该就没有问题了。如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Element</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> b: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> c: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">toy</span>() -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        b <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        c <span class="operator">=</span> <span class="type">Element</span>.toy()  <span class="comment">// 使用type method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算属性 和 通过闭包给存储属性赋默认值 的区别</title>
      <link href="/2023/02/24/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E5%92%8C-%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E7%BB%99%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E9%BB%98%E8%AE%A4%E5%80%BC-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/24/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E5%92%8C-%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E7%BB%99%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E8%B5%8B%E9%BB%98%E8%AE%A4%E5%80%BC-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>swift中的计算属性computated properties 和 通过闭包来给存储属性赋默认值这一行为，看起来很像，写一篇记录一下。这里的计算属性主要是针对，只读的计算属性（也就是没有set，同时对get和花括号进行了缩写）。</p><p>先总结一下区别：</p><ol><li>计算属性不需要初始化，闭包赋值针对是默认初始化的赋值</li><li>计算属性的花括号里可以访问self即其相关属性或方法，闭包赋值的花括号里是不能访问self的。（我的理解，property initializer里面都不能访问self）</li><li>计算属性后面没有<code>=</code>，也有末尾的<code>()</code></li></ol><p>相同点，花括号里都能定义局部变量等。</p><p>举一个只读计算变量例子起，很简单。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;  <span class="comment">// 这里没有等号</span></span><br><span class="line">        <span class="keyword">let</span> a <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> width  <span class="comment">// 可以访问self</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;  <span class="comment">// 不需要代表立即执行的()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“the volume of fourByFiveByTwo is 0.0”</span></span><br></pre></td></tr></table></figure><p>接下来举一个正确的利用闭包给存储属性赋默认值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> <span class="operator">=</span> &#123;  <span class="comment">// 有等号</span></span><br><span class="line">        <span class="comment">// 不能访问self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10.0</span></span><br><span class="line">    &#125;()  <span class="comment">// 需要立即执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“the volume of fourByFiveByTwo is 10.0”</span></span><br></pre></td></tr></table></figure><p>接下来演示几个错误</p><p>错误1，在闭包内访问<code>self</code></p><p>报错<code>Cannot find &#39;self&#39; in scope</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a <span class="operator">=</span> <span class="keyword">self</span>.width  <span class="comment">// 错误1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10.0</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误2，没有写代表立即执行的<code>()</code>，这样就相当于把一个类型为<code>()-&gt;Double</code>的闭包赋给一个变量。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找的理解</title>
      <link href="/2023/02/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/02/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>二分查找很容易出现混淆的写法，本文从常见的二分查找的三种情况（查找特定元素，找第一个大于等于某个数的位置，找第一个大于某个数的位置），和以两道例题引出二分查找需要注意的细节问题，即关于中点的选择（偶数时，向左偏还是向右偏）。</p><p>二分算法的<strong>难点是</strong>，对于while循环中几个难以区分的点。</p><ol><li><code>left &lt; right</code>还是<code>left &lt;= right</code></li><li><code>left = mid + 1</code>还是<code>right = mid</code>或者其他划分区间的方法也可以</li><li>输入是<code>0 ~ n-1</code>还是<code>0 ~ n</code></li></ol><span id="more"></span><h2 id="查找某个具体的元素"><a href="#查找某个具体的元素" class="headerlink" title="查找某个具体的元素"></a>查找某个具体的元素</h2><p>对于升序的数组，查找每个具体的元素。</p><p>以我个人的角度，我习惯输入<code>[0, n-1]</code>这个闭区间，从直观上来理解，这个区间的每个数，都有可能是我们要查找的答案。</p><p><code>left &lt;= right</code>，这样选择的原因，一个角度是，<code>left == right</code>时，<code>mid</code>取到<code>left</code>，这个数仍然没有被判断到，这个等号是有意义的。另一个角度是，和<code>left &lt; right</code>不同，我们并不是要夹出某个具体的位置，如果<code>left</code>和<code>right</code>，交错开来，我们就返回-1。</p><p>区间的划分，如果<code>a[mid]</code>不是我们要查找的数，那<code>mid</code>位置一定不是我们想要的。所以我们将区间<code>[left, right]</code>划分为<code>[left, mid - 1]</code>和<code>mid</code>（已排除）和<code>[mid + 1, right]</code>。换个同样表达的意思，<code>left = mid + 1</code>，<code>right = mid - 1</code></p><p>示例代码，这里采取迭代的形式，递归形式可以很简单的转化，就不写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;  <span class="comment">// 取等号</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left)  <span class="comment">// 中点向左偏移</span></span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//找不到</span></span><br></pre></td></tr></table></figure><h2 id="找第一个大于等于某个元素的位置"><a href="#找第一个大于等于某个元素的位置" class="headerlink" title="找第一个大于等于某个元素的位置"></a>找第一个大于等于某个元素的位置</h2><p>可以针对非降序序列，如<code>[1,2,3,3,4]</code>找第一个大于等于3的位置，就是位置2。</p><p>对应C++中标准库的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), target)  <span class="comment">//返回迭代器</span></span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + <span class="number">10</span>, target) <span class="comment">//数组</span></span><br></pre></td></tr></table></figure><p>输入为<code>[0, n]</code>，为什么选<code>n</code>呢？因为最后一个位置的下一个，仍然可能是第一个大于等于的位置，如针对上面的序列，我们要找第一个大于等于10的位置，则是最后一个位置下一个。</p><p><code>left &lt; right</code>如同上文所说，这样写的目的是<strong>夹出某个具体的位置</strong>，最后<code>left == right</code>时，返回<code>left</code>即是我们想要的答案。（当然<code>right</code>也一样）</p><p>区间的划分：这里要加上理解才更好写。</p><ol><li><code>a[mid] == target</code>时，区间应该向<code>[left, mid]</code>收缩，因为<code>mid</code>这个位置有可能是第一个大于等于targeet的位置</li><li><code>a[mid] &gt; target</code>时，同上，区间应该向<code>[left, mid]</code>收缩，因为<code>mid</code>这个位置有可能是第一个大于等于targeet的位置</li><li><code>a[mid] &lt; target</code>时，区间应该向<code>[mid + 1, right]</code>收缩，因为<code>mid</code>一定不满足我们的要求。</li></ol><p>综上，也就是将区间<code>[left, right]</code>划分为<code>[left, mid]</code>和<code>[mid + 1, right]</code>。换个同样表达的意思，<code>left = mid + 1</code>，<code>right = mid</code></p><p>示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 取 &lt;</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left)  <span class="comment">// 中点向左偏移</span></span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//找到期望的位置</span></span><br></pre></td></tr></table></figure><h2 id="找第一个大于某个元素的位置"><a href="#找第一个大于某个元素的位置" class="headerlink" title="找第一个大于某个元素的位置"></a>找第一个大于某个元素的位置</h2><p>可以针对非降序序列，如<code>[1,2,3,3,4]</code>找第一个大于等于3的位置，就是位置4。</p><p>对于C++标准库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), target);  <span class="comment">// 返回迭代器</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, target);  <span class="comment">// 返回位置吧</span></span><br></pre></td></tr></table></figure><p>输入为<code>[0, n]</code>，为什么选<code>n</code>呢？因为最后一个位置的下一个，仍然可能是第一个等于的位置，如针对上面的序列，我们要找第一个大于10的位置，则是最后一个位置下一个。接下来，说些重复的话，但是区间划分的分析部分有所不同。</p><p><code>left &lt; right</code>如同上文所说，这样写的目的是<strong>夹出某个具体的位置</strong>，最后<code>left == right</code>时，返回<code>left</code>即是我们想要的答案。（当然<code>right</code>也一样）</p><p>区间的划分：这里要加上理解才更好写。</p><ol><li><code>a[mid] == target</code>时，区间应该向<code>[mid + 1, right]</code>收缩，因为<code>mid</code>一定不满足我们的要求。</li><li><code>a[mid] &gt; target</code>时，同上，区间应该向<code>[left, mid]</code>收缩，因为<code>mid</code>这个位置有可能是第一个大于等于targeet的位置</li><li><code>a[mid] &lt; target</code>时，区间应该向<code>[mid + 1, right]</code>收缩，因为<code>mid</code>一定不满足我们的要求。</li></ol><p>综上，也就是将区间<code>[left, right]</code>划分为<code>[left, mid]</code>和<code>[mid + 1, right]</code>。换个同样表达的意思，<code>left = mid + 1</code>，<code>right = mid</code></p><p>示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = n;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;  <span class="comment">// 取 &lt;</span></span><br><span class="line">    <span class="type">int</span> mid = left + (right - left)  <span class="comment">// 中点向左偏移</span></span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;  <span class="comment">//找到期望的位置</span></span><br></pre></td></tr></table></figure><h2 id="关于中点选择的注意事项"><a href="#关于中点选择的注意事项" class="headerlink" title="关于中点选择的注意事项"></a>关于中点选择的注意事项</h2><p>对于偶数个项的数组，中点的选择有两种。如<code>[0, 1, 2, 3]</code>，中点位置可以选择位置1（向左偏移）和位置2（向右便宜）。这两种方式并不是随意选的，接下来将详细解释。</p><ol><li><p>偶数个数时，靠左取中间节点还是靠右取中间节点。</p><p> 首先需要明确的是，对于奇数个数，两种写法都是取到中间节点。</p><ul><li><p>最常规的写法，取靠左的节点，如<code>0 1 2 3</code>，取节点1</p><p>  以下两种写法完全等价</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = (a + b) / <span class="number">2</span></span><br><span class="line"><span class="comment">// 为了防止溢出</span></span><br><span class="line"><span class="type">int</span> mid = a + (b - a) / <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>取靠右的节点，如<code>0 1 2 3</code>，取节点2</p><p>  以下两种写法完全等价，推荐写法2来防止溢出</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = (a + b + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="comment">// 为了防止溢出</span></span><br><span class="line"><span class="type">int</span> mid = a + (b - a + <span class="number">1</span>) / <span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>以上两种写法，都是为了搜索区间只有两个元素的特殊情况服务的。</p><ul><li><p>当区间的更新逻辑为<code>left = mid + 1</code>和<code>right = mid</code>，也就是将原区间划分为<code>[left, mid]</code>和<code>[mid+1, right]</code>，<code>while(left &lt; right)</code>退出循环后，<code>left == right</code>成立，<code>mid</code>向==左==取可取。（这也是最常见的二种二分的写法）</p><p>  ==原因==，如区间<code>[1,2]</code>，向左取中点，也就是<code>mid</code>更新为1，<code>left</code>更新为2，这样区间划分为<code>[1,1]</code>和<code>[2,2]</code>，夹出了我们想要的区间。</p></li><li><p>当区间的更新逻辑为<code>left = mid </code>和<code>right = mid-1</code>，也就是将原区间划分为<code>[left, mid-1]</code>和<code>[mid, right]</code>，<code>while(left &lt; right)</code>退出循环后，<code>left == right</code>成立，<code>mid</code>向==右==取可取。</p><p>  ==原因==，如区间<code>[1,2]</code>，仍然继续向左取中间，也就是<code>mid</code>更新为1，<code>left</code>更新为==1==，区间更新为<code>[1, 0]</code>和<code>[1,2]</code>，有可能导致<code>left != right</code>或者陷入了更新的死循环。</p></li></ul></li></ol><p>例题1<a href="https://leetcode.cn/problems/sqrtx/">x 的平方根</a></p><p>注意点夹出答案，特殊判断，向右取中点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这题我觉得有两点</span></span><br><span class="line">    <span class="comment">// 一个是输入边界的选择，我感觉[1, n]就可以了，n/2不知道又没有特殊情况（n&gt;4时适用）</span></span><br><span class="line">    <span class="comment">// 但是从数值角度来说，当右边为n/2，区间[1,1]对2，3也是成立的</span></span><br><span class="line">    <span class="comment">// 再一个int范围不够，要到long long才行</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 向右取，不过说实话，这得后面更新策略出来了，才能知道</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid == x) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt; x) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例题2<a href="https://leetcode.cn/problems/valid-perfect-square/">有效的完全平方数</a></p><p>与查找具体某个元素完全类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt; num) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一类题型，以对两棵子树的遍历来产生结果</title>
      <link href="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/"/>
      <url>/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一类题型，以对两棵子树的遍历来产生结果"><a href="#一类题型，以对两棵子树的遍历来产生结果" class="headerlink" title="一类题型，以对两棵子树的遍历来产生结果"></a>一类题型，以对两棵子树的遍历来产生结果</h1><p>这一类问题的特点是对树进行递归遍历时，往往是对两棵树同时递归，这就产生了，同一时刻会有对应关系的两个节点，针对不同的题意，采取对两棵树的不同遍历顺序（或者叫对两个节点的不同选择策略），入口如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(TreeNode* l, TreeNode* r)</span><br></pre></td></tr></table></figure><h2 id="leetcode-101-迭代法"><a href="#leetcode-101-迭代法" class="headerlink" title="leetcode 101 迭代法"></a>leetcode 101 迭代法</h2><p>首先以<a href="https://leetcode.cn/problems/symmetric-tree/description/">leetcode 101. 对称的树为例子</a></p><p>按照上面的说法，这题的本质，是判断一对对对应位置的节点是否是一致的。如题目中的示例树，一共要判断3对节点位置是否相等，<code>2-&gt;2</code>，<code>3-&gt;3</code>，<code>4-&gt;4</code></p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221225216709.png" alt="image-20221221225216709"></p><span id="more"></span><p>先说一个容易帮助我们理解的方法，类似层序法。利用两个队列（其实一个队列也行），分别取两个子树中的对应节点对，首先应该将左子树节点压入队列1，右子树节点压入队列2。这是图中两个黄色节点，已经压入两个对应的队列中，在while循环中，先出队，对两个节点进行比较</p><blockquote><p>对两个节点的比较有三种情况</p><ol><li>其中一个节点为空，另一个不空，这是已经可以返回false</li><li>两个节点都空（由于这两个节点没有子节点了，我们可以continue了）</li><li>两个节点都不空，但是值不等，显然可以判断不对称了</li></ol><p>两个节点相等，默认继续往下走</p></blockquote><p>两个输入的左右节点的判断逻辑很简单，如何判断图中的蓝色节点和红色节点的位置呢。</p><p><strong>这里的逻辑是整个题目的关键。</strong>队列1压入左节点的左节点，队列2压入右节点的右节点；（这两个节点，在队列里有对应关系）；队列1压入左节点的右节点，队列2压入右节点的左节点。（同样形成了对应关系）</p><p>这样不仅保证了，两个队列每次取出的元素是期望的对应位置的，而且也保证了遍历到了所有的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 队列法，其实比较直观的</span></span><br><span class="line">    <span class="comment">// 用一个队列就行了，我还用了两个队列</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q1;</span><br><span class="line">        queue&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">push</span>(root-&gt;left);  <span class="comment">// 左节点压入队列1</span></span><br><span class="line">        q2.<span class="built_in">push</span>(root-&gt;right); <span class="comment">// 右节点压入队列2</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* n1 = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* n2 = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>((!n1 &amp;&amp; n2) || (n1 &amp;&amp; !n2)) &#123;  <span class="comment">// 有一个是空的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n1 &amp;&amp; n2 &amp;&amp; (n1-&gt;val)!=(n2-&gt;val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!n1 &amp;&amp; !n2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q1.<span class="built_in">push</span>(n1-&gt;left);</span><br><span class="line">            q1.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">            q2.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            q2.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221231000499.png" alt="image-20221221231000499"></p><p><strong>这个方法是迭代法，接下来介绍递归的方法</strong>.</p><p>递归法我习惯按照labuladong的想法<a href="https://labuladong.gitee.io/algo/1/6/">labuladong二叉树</a>，将二叉树的问题分为自顶向下遍历解决的问题，和后序遍历，要获取子节点信息后才能解决的问题。</p><h2 id="leetcode-101-前序遍历法"><a href="#leetcode-101-前序遍历法" class="headerlink" title="leetcode 101 前序遍历法"></a>leetcode 101 前序遍历法</h2><p>我们先不讨论剪枝的问题（这里的剪枝即为，遇到了不匹配的情况，接下来的树，我们并不需要遍历了，结束即可），剪枝的情况与dfs中只找到一种满足条件的解类似。</p><p>我们先对左右两棵树做完整的遍历，遍历的顺序完全与上面一致。</p><p>左子树遍历顺序为<strong>中左右</strong>，右子树遍历顺序为<strong>中右左</strong>，在两棵树的同时遍历体现在<code>traverse</code>的调用上。同样的，我们还是要先在前序的位置判断本层的情况。这里我们设置了一个全局的变量来存储是否对称</p><blockquote><p>两个节点的情况与上面几乎完全一样</p><ol><li>其中一个节点为空，另一个不空，变量为false，返回。<strong>注意，这里的返回并不是一路直接返回到根节点，只是返回上一层，当前节点的后续的遍历步骤不做了，上一层未做完的遍历还是要做的，如，继续遍历上一层的右子树（显示这步没有意义）</strong></li><li>两个节点都空，直接return，没有子节点了，不必往下</li><li>两个节点都不空，但是值不等，还是遍历为false，返回。</li></ol><p>两个节点相等，暗含在没写的else里，相等就要继续往下走了。</p></blockquote><p>下一层如何遍历，按照我们刚刚提到的。左子树先遍历左节点，右子树先遍历右节点。左子树再遍历右节点，右子树再遍历左节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(l-&gt;left, r-&gt;right);  <span class="comment">// 这两行是这题的本质</span></span><br><span class="line"><span class="built_in">traverse</span>(l-&gt;right, r-&gt;left);</span><br></pre></td></tr></table></figure><p>为了更直观的看出dfs的遍历顺序，如下图，我们用一颗更深的树</p><p>先展示一下，递归法入队列的节点顺序</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221232819926.png" alt="image-20221221232819926"></p><p>dfs的遍历顺序</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221233046877.png" alt="image-20221221233046877"></p><p>通过对遍历顺序的设置，我们得到了左右两棵子树，在对称位置的一个节点对应关系，还遍历了整棵树。完整代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用前序的遍历来实现</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;  <span class="comment">// 对左右子树来遍历，只不过遍历顺序不同</span></span><br><span class="line">        <span class="keyword">if</span> ((!l &amp;&amp; r) || (l &amp;&amp; !r)) &#123;  <span class="comment">// 其中一个空</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l-&gt;val) != (r-&gt;val)) &#123;  <span class="comment">// 这时已经非空了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(l-&gt;left, r-&gt;right);  <span class="comment">// 这两行是这题的本质</span></span><br><span class="line">        <span class="built_in">traverse</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 题目保证了，一定会有一个节点</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要进行剪枝呢，如果不感兴趣，可以直接看下一节。剪枝（dfs中只取一个满足条件的情况），要设置返回值。在期望的地方return true。<em>注意，这里的return值，并不是判断是不是对称树的return值</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用前序的遍历来实现</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;  <span class="comment">// 对左右子树来遍历，只不过遍历顺序不同</span></span><br><span class="line">        <span class="keyword">if</span> ((!l &amp;&amp; r) || (l &amp;&amp; !r)) &#123;  <span class="comment">// 其中一个空</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((l-&gt;val) != (r-&gt;val)) &#123;  <span class="comment">// 这时已经非空了</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(l-&gt;left, r-&gt;right)) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 一路往上</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">traverse</span>(l-&gt;right, r-&gt;left)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 题目保证了，一定会有一个节点</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode-101-后序遍历法"><a href="#leetcode-101-后序遍历法" class="headerlink" title="leetcode 101 后序遍历法"></a>leetcode 101 后序遍历法</h2><p>其实我这里不太愿意称呼这种方法为后序遍历法，因为与前序遍历的代码几乎是一模一样的，不过为函数添加了返回值。<strong>只有在后续的位置通过&amp;操作，得到“对应节点对”是否对称之后，才能判断本棵树是否对称</strong>。也就是说，本方法只能在遍历完所有的节点才能得到结果。</p><p>这里先看完整代码，在前序位置，判断节点的三种情况一样，就是在后序的位置修改了代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 实际上还是labuladong说的遍历法的应用</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!left &amp;&amp; right) || (left &amp;&amp; !right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;  <span class="comment">// 其实叶子蕴含在里面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 这里要好好理解</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &amp;&amp; right &amp;&amp; (left-&gt;val)!=(right-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么值相等的情况不return ture呢？</span></span><br><span class="line">        <span class="comment">// 因为这样没法继续往下走了</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="built_in">cmp</span>(left-&gt;left, right-&gt;right);  <span class="comment">// 左； 右</span></span><br><span class="line">        <span class="type">bool</span> flag2 = <span class="built_in">cmp</span>(left-&gt;right, right-&gt;left);  <span class="comment">// 右； 左</span></span><br><span class="line">        <span class="keyword">return</span> flag1 &amp;&amp; flag2;  <span class="comment">// 这其实是在后续遍历的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>return的结果，代表以<code>l</code>为根的这棵树，和以<code>r</code>为根的这棵树是否是镜像（对称关系）.</p><p>这是宏观上的一个理解，也就是说，以1为根的树是否对称，取决于以2为根的两棵树是否是镜像关系。而以2为根的两棵树是否镜像，取决于以1的左节点的左节点为根的树和以1的右节点的右节点为根的树镜像，以及1的左节点的右节点为根的树和以1的右节点的左节点为根的树镜像，如图</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221221235831445.png" alt="image-20221221235831445"></p><p>本质上我觉得还是在比较对应的节点对，特别是在前序位置的比较。</p><p>这里还有一个问题，为什么不在前序的位置做相等的比较，然后return true呢？一个直观的回答是，即使两个节点值相同，也不能代表接下来的也相同。也可以理解为，相等这个判断已经隐式表现在了三个if中，这三个if都不是，肯定就相等了，接下来还得满足上图中，树的对称关系（也就是最后的与操作，相等就是&amp;true）</p><p>解决这一题并不是本次讲解的核心，本笔记的核心，<strong>是如何通过有效的递归（遍历的一个顺序），取到期望的节点对。</strong></p><p>==我们核心代码那两行的顺序是可以交换的，只不过会造成遍历的顺序不一样，不会影响结果。==</p><p>接下来，以<a href="https://leetcode.cn/problems/same-tree/">leetcode 100 相同的树</a>为例子，讲解如何取到两棵树完全一样的位置。</p><h2 id="leetcode-100"><a href="#leetcode-100" class="headerlink" title="leetcode 100"></a>leetcode 100</h2><p>这题写迭代法，用两个队列当然也是可行的，和上面的代码变化不大，不再写了。</p><p>前序法其实变化和上面的方法也不大，只改动了两行核心代码。</p><p>也就是左子树的遍历顺序是<strong>中左右</strong>，右子树保持完全一样的遍历顺序<strong>中左右</strong>。这里其实非常简单啊，就是对两棵树同时进行前序遍历即可。判断函数本层的三种情况，仍然如上。<strong>着重注意20行修改的部分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 按前序的方法来写写看，这样可以剪枝</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!p &amp;&amp; q) || (p &amp;&amp; !q)) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p-&gt;val) != (q-&gt;val)) &#123;  <span class="comment">// 这时候已经可以确保非空了</span></span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(p-&gt;left, q-&gt;left);  <span class="comment">// 修改的部分</span></span><br><span class="line">        <span class="built_in">traverse</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后序法，我也不写了，也是同上，只要修改两行核心代码即可。展示一下，遍历的图，有人可能疑惑，这个遍历图一眼都会。我画的目的是强调，我们这里每次取到的是对应的节点对</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221222001340003.png" alt="image-20221222001340003"></p><p>同样，核心代码那两行也是可以交换的。</p><h2 id="leetcode116-填充每个节点的下一个右侧节点指针"><a href="#leetcode116-填充每个节点的下一个右侧节点指针" class="headerlink" title="leetcode116. 填充每个节点的下一个右侧节点指针"></a>leetcode116. 填充每个节点的下一个右侧节点指针</h2><p>接下来，我介绍这一题，我认为也完全可以归结到取左右子树的节点对这一题型里来。</p><p>这一题最直观的方法，使用层序遍历，保存每一层的第一个节点作为头节点，这样就可以像链表一样串起来了。这里我就不详细介绍这一个方法了。</p><h3 id="leetcode-116-遍历法"><a href="#leetcode-116-遍历法" class="headerlink" title="leetcode 116 遍历法"></a>leetcode 116 遍历法</h3><p>注意我这里没有叫他前序或者后序之类，因为按照labuladong的理解，这是一棵三叉树。</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/2022-12-2222.15.06.png" alt="截屏2022-12-22 22.15.06"></p><p>其实我们也可以按照上面的思路来考虑。这里的题意其实可以理解为，每次取一个节点对，让左节点的next指针指向右节点。按照这样的思路，我们还是同样先画一下取节点的示意图：</p><p><img src="/2022/12/22/%E4%B8%80%E7%B1%BB%E9%A2%98%E5%9E%8B%EF%BC%8C%E4%BB%A5%E5%AF%B9%E4%B8%A4%E6%A3%B5%E5%AD%90%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%9D%A5%E4%BA%A7%E7%94%9F%E7%BB%93%E6%9E%9C/image-20221222222358349.png" alt="image-20221222222358349"></p><p>按照三叉树的遍历，或者按照取节点对的方式来理解都可以，最关键的部分，还是核心代码，在这里核心代码为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traverse</span>(p-&gt;left, p-&gt;right);  <span class="comment">// 对应三叉树最左边的节点</span></span><br><span class="line"><span class="built_in">traverse</span>(p-&gt;right, q-&gt;left);  <span class="comment">// 对应三叉树中间节点</span></span><br><span class="line"><span class="built_in">traverse</span>(q-&gt;left, q-&gt;right);  <span class="comment">// 对应三叉树最右边的节点</span></span><br></pre></td></tr></table></figure><p>开始第一遍看到这个代码，我其实是没有理解的，但是从节点对的角度，按照遍历顺序模拟一遍应该会好很多。这里和之前两题不同的是，这里取节点出现了同时在一棵树上的情况，要好好理解。</p><p>类似的，这题当然能用队列来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;Node*&gt; q1;</span><br><span class="line">        queue&lt;Node*&gt; q2;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) q1.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) q2.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node* n1 = q1.<span class="built_in">front</span>();</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">            Node* n2 = q2.<span class="built_in">front</span>();</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            n1-&gt;next = n2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n1-&gt;left) &#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(n1-&gt;left);  <span class="comment">// 这里对应核心代码部分</span></span><br><span class="line">                q2.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q1.<span class="built_in">push</span>(n1-&gt;right);</span><br><span class="line">                q2.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">                q1.<span class="built_in">push</span>(n2-&gt;left);</span><br><span class="line">                q2.<span class="built_in">push</span>(n2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这些题目的本质，还是dfs，或者说还是二叉树的前序遍历，但是在这里是在两棵树同时遍历。</p><h2 id="leetcode-617同种题型"><a href="#leetcode-617同种题型" class="headerlink" title="leetcode 617同种题型"></a>leetcode 617同种题型</h2><p>补充：</p><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">leetcode 617 合并二叉树</a>同种题型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dfs中的状态变量（全局还是局部，当层还是下一层）</title>
      <link href="/2022/12/16/dfs%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E8%BF%98%E6%98%AF%E5%B1%80%E9%83%A8%EF%BC%8C%E5%BD%93%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%8B%E4%B8%80%E5%B1%82%EF%BC%89/"/>
      <url>/2022/12/16/dfs%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E8%BF%98%E6%98%AF%E5%B1%80%E9%83%A8%EF%BC%8C%E5%BD%93%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%8B%E4%B8%80%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>如标题所示。我们主要讨论了两个问题，本文中是以二叉树为例子（dfs中也是等价）。</p><blockquote><ol><li>状态变量是作为全局变量来写，还是作为局部变量来写</li><li>无论作为全局变量，还是局部变量而言，状态变量的意义，是当前层函数的状态，还是下一层函数的状态（类比DFS中问题的写法，如八皇后）</li></ol></blockquote><p>首先解答第一个问题，两种写法都可以，我们将框架分为如下</p><p><img src="/2022/12/16/dfs%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%85%A8%E5%B1%80%E8%BF%98%E6%98%AF%E5%B1%80%E9%83%A8%EF%BC%8C%E5%BD%93%E5%B1%82%E8%BF%98%E6%98%AF%E4%B8%8B%E4%B8%80%E5%B1%82%EF%BC%89/image-20221216154210641.png" alt="image-20221216154210641"></p><span id="more"></span><p>我们使用全局的状态变量或者局部的状态变量都是可行的，这两种方法其实是等价的（我们在dfs中其实讨论过，在函数参数里局部变量的加法，蕴含了出函数之后，局部变量的减法）。</p><p>我们仍然以，一棵树的最深深度为例子。</p><p>首先是，全局状态变量，且是记录本层状态。这里初始化为0，且在记录本层状态之前++。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>;  <span class="comment">// 状态变量对于本层而言</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root  == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        depth++;  <span class="comment">// 注意这一行</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;  <span class="comment">// 记录本层值</span></span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// print是当前的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>全局状态变量记录下一层，初始化为1，在记录本层状态之后++.  注意，这里要特判空的情况，上一种情况不用。（为什么，我叫这种情况为记录下一层位置，因为和dfs中一样，这里的第14行depth++之后，比如从1变为了2，对应的是下一层的值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;  <span class="comment">// 状态变量对于下一层而言</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root  == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;</span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 如果不先减减的话，print是下一层的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right);</span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 因为默认有根，我要让状态变量相对于下一层</span></span><br><span class="line">        <span class="built_in">traverse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，把这种情况理解成记录当前层情况也行（毕竟，采取局部变量时，也进行了特判，和初始化为1）==毋容置疑的是，第11行if所处的位置，记录的一定是当前函数的状态值，其他地方，这两种方法是存在差异的。==如，在中序的位置，前一种方法打印depth，确实是对应当前的值，而当前方法，打印depth，对应的是下一层的值，这样的说法可能更为妥当一点。</p><p>当我们使用局部变量时，往往是<strong>已经可以做出一个选择了，</strong>如这里是默认存在根节点（并把根节点的值，作为函数的局部变量），==所以需要进行特判，并传入第一个值（节点蕴含的值，或者节点的地址）==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这次我们把状态变量写在函数里面取</span></span><br><span class="line">    <span class="comment">// 这里的话，状态变量写成当层的，比较make sense一点，先写当层的吧</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; ans) &#123;</span><br><span class="line">            ans = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 中序的位置print，depth仍然为本层的值</span></span><br><span class="line">        <span class="built_in">traverse</span>(root-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 状态变量写成当层，需要特判断</span></span><br><span class="line">        <span class="built_in">traverse</span>(root, <span class="number">1</span>);  <span class="comment">// 这里写成当前层，我们传入反而是1？</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与全局变量的第二种情况不同，因为局部变量自动蕴含了<code>--</code>的含义，所以这里的位置位置，打印depth，仍然是当前的一个深度状态。</p><ul><li><p>在使用全局变量时，我们需要在中序的位置对全局变量先<code>--</code>再<code>++</code>吗？</p><p>  如果我们想要在中序的位置打印当前变量的深度</p><ol><li><p>如果全局变量记录的是本层的值，我们可以直接打印（为什么？因为我们从子节点回来时，已经对全局变量经过先加加，再减减了）</p></li><li><p>如果全局变量记录的事下一层的值，我们需要先<code>--</code>再<code>++</code>。这里的做法和dfs里for循环里的做法一直</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">depth++;  <span class="comment">// 下一层的层深</span></span><br><span class="line"><span class="built_in">traverse</span>(root-&gt;left);</span><br><span class="line">depth--;</span><br><span class="line"><span class="built_in">print</span>(depth);  <span class="comment">// 本层的层深</span></span><br><span class="line">depth++;</span><br><span class="line"><span class="built_in">travese</span>(root-&gt;right);</span><br><span class="line">depth--;  <span class="comment">// 恢复本层</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>我们需要使用if特判是否存在左右子树吗</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left) traverse(root-&gt;left);</span><br></pre></td></tr></table></figure><p>  这里是一个提前的剪枝，使得叶子节点无需再往下走一步了。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下挂载的机械硬盘写权限问题</title>
      <link href="/2022/02/08/Ubuntu%E4%B8%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%86%99%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
      <url>/2022/02/08/Ubuntu%E4%B8%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E5%86%99%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>实验室主机下有一块4T机械盘，设置成了exfat格式，平时只能以<code>root</code>用户的权限来跑，现在想设置成usr权限可以操作。使用了<code>chmod -R 777</code>和<code>chown usrname</code>均不成功，<code>chmod</code>运行结束后，使用<code>ls -al</code>查看权限并没有修改；<code>chown usrname</code>直接提示没有权限。记录一下，解决的过程。</p><span id="more"></span><p>==通过查资料发现<code>ntfs,exfat,fat32</code>等文件系统都是windows下的文件系统，因此有不能用过chmod来改权限的问题。==这个问题还是挺久远的，google上十几年前就有人问了，又要吐槽一下CSDN，大家抄来抄去，还有百度搜索一个问题，直接给你推荐一个不相关的CSDN合集，真是有够恶心人的。</p><h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>（说一点废话，不想看的可以看下一段）因为，今天跑程序固态硬盘不够用，想在机械盘中存数据来跑nnunet，但是nnunet使用的不是如<code>python xxx.py</code>d的形式运行数据，而是用<code>nnUnet_</code>开头的命令行形式运行。因为使用<code>sudo</code>运行命令时，使用的是root用户下的环境变量，所以<code>sudo nnUnet_</code>命令虽然解决了写权限的问题，但是环境变量的设置又出错了。因此，想到了解决方法</p><ol><li>把usr下的<code>.bashrc</code>复制到<code>/root</code>下，再<code>source</code>，感觉后续有其他的问题，没有试。</li><li>解决硬盘的写权限问题</li></ol><h2 id="解决写权限"><a href="#解决写权限" class="headerlink" title="解决写权限"></a>解决写权限</h2><p>首先在CSDN这个垃圾堆找了一圈，跳转到了一篇知乎的文章<a href="https://www.zhihu.com/people/ni-da-pao-46%EF%BC%8C%E6%9C%89%E4%B8%80%E5%AE%9A%E7%9A%84%E5%8F%82%E8%80%83%E4%BB%B7%E5%80%BC%EF%BC%8C%E5%89%8D%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%9D%87%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%E8%BF%99%E4%B8%AA%E8%BF%9B%E8%A1%8C%E3%80%82">https://www.zhihu.com/people/ni-da-pao-46，有一定的参考价值，前序的步骤均可以按照这个进行。</a></p><h3 id="查看硬盘信息"><a href="#查看硬盘信息" class="headerlink" title="查看硬盘信息"></a>查看硬盘信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p>查看已经挂载的硬盘的信息，第一列我理解为硬盘名，如<code>/dev/sda2</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>查看所有硬盘的信息，有可能自己的硬盘还没挂载</p><h3 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sda2 /mnt  <span class="comment">#sda2后面不要加/，那mnt后面也别加吧，不知道为什么</span></span><br></pre></td></tr></table></figure><p>补充一下，卸载硬盘的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /dev/sda2</span><br></pre></td></tr></table></figure><p>如果显示硬盘正忙，无法卸载，最好就是重启再弄</p><h3 id="查看硬盘分区id"><a href="#查看硬盘分区id" class="headerlink" title="查看硬盘分区id"></a>查看硬盘分区id</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><p>找到对应硬盘的<code>UUID=XXXX-XXXX</code>和<code>TYPE=&quot;exfat&quot;</code>，每个人的type可能不一样，关系到后面的的修改</p><h3 id="编辑-etc-fstab文件"><a href="#编辑-etc-fstab文件" class="headerlink" title="编辑/etc/fstab文件"></a>编辑<code>/etc/fstab</code>文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br><span class="line"><span class="comment"># 在启动或在终端中输入mount -a时自动挂载，或者为noauto</span></span><br><span class="line"><span class="comment"># user 允许任何用户挂载设备,可选nouser，这样仅仅允许root用户挂载</span></span><br><span class="line"><span class="comment"># rw 挂载为读写权限，可选ro挂载为只读权限</span></span><br><span class="line">UUID=xxx /mnt/disk1 ext4 auto,user,rw,uid=1000,gid=1000 0 0</span><br></pre></td></tr></table></figure><p>我在作者的基础上加了另一个方法的解决方案<a href="https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive">https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive</a>，加上了<code>uid=1000</code>,<code>gid=1000</code></p><p>如果你不知道你的<code>uid</code>，可以通过下面的命令来获得</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">id</span> yourusername</span><br><span class="line">uid=1000(yourusername) gid=1000(yourusername) <span class="built_in">groups</span>=1000(yourusername),4(adm),24(cdrom),...</span><br></pre></td></tr></table></figure><p>其他方法中的<code>umask=000</code>在我的实验中，并不好用</p><p>如果你的分区硬盘还没接触挂载，先执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /dev/sda2 <span class="comment">#你的硬盘名</span></span><br></pre></td></tr></table></figure><p>Make systemd happy（我的理解，就是激活了/etc/fstab等这些开机启动程序的配置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>重新挂载硬盘即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><hr><p>最后纪念一下几个失败的修改（注释中全部失败了)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享的机械盘，挂载在/mnt下</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /mnt exfat auto,user,rw 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw,umasks=000 0 0</span></span><br><span class="line"><span class="comment"># UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat defaults,umasks=000 0 0</span></span><br><span class="line">UUID=1EE8-C12A /media/ubuntu-4/新加卷 exfat auto,user,rw,uid=1000,gid=1000 0 0</span><br></pre></td></tr></table></figure><h2 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h2><p>==成功的解决方案==<a href="https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive">https://askubuntu.com/questions/923691/ownership-permission-problem-with-automounting-exfat-drive</a></p><p>失败的，但是很有参考价值的一篇<a href="https://www.zhihu.com/people/ni-da-pao-46">https://www.zhihu.com/people/ni-da-pao-46</a></p><p>指出为什么不能写的原因的一篇<a href="https://askubuntu.com/questions/1111542/cant-change-ownership-of-mounted-device">https://askubuntu.com/questions/1111542/cant-change-ownership-of-mounted-device</a></p><p>指出为什么不能用<code>chomod</code>在ubuntu下修改NTFS(or FAT32)分区的很多解决方案<a href="https://askubuntu.com/questions/11840/how-do-i-use-chmod-on-an-ntfs-or-fat32-partition/956072#956072">https://askubuntu.com/questions/11840/how-do-i-use-chmod-on-an-ntfs-or-fat32-partition/956072#956072</a></p><p>这是介绍了umask=000解决方案的，对我失效<a href="https://askubuntu.com/questions/1255907/20-04-chmod-not-working-on-exfat-mount">https://askubuntu.com/questions/1255907/20-04-chmod-not-working-on-exfat-mount</a></p><p>一个人的非常的多尝试，可以看看<a href="https://www.reddit.com/r/linux4noobs/comments/kbpsex/cant_get_write_permissions_on_mounted_usb_hdd/">https://www.reddit.com/r/linux4noobs/comments/kbpsex/cant_get_write_permissions_on_mounted_usb_hdd/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh断开保持程序运行</title>
      <link href="/2022/02/08/ssh%E6%96%AD%E5%BC%80%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C/"/>
      <url>/2022/02/08/ssh%E6%96%AD%E5%BC%80%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>ssh断开后，程序运行的进程就会中断了，因此要在后台保持运行。中文的资料查阅，有两种方法。1. nohup &amp;命令 2. screen命令</p><span id="more"></span><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>先介绍screen的用法吧，具体原理也不是很清楚，拿来就用。</p><p>比较实用的一点</p><ol><li>在非计算节点上screen -S gpu新建session，然后再里面申请到GPU节点后，再screen -S train训练节点</li><li>在最内层train上面, ctrl a d返回的事最外层非计算节点，按<code>crtl a a d</code>即可从最内层返回上一层</li></ol><h3 id="screen的常见操作"><a href="#screen的常见操作" class="headerlink" title="screen的常见操作"></a>screen的常见操作</h3><p><a href="https://www.vpser.net/manage/screen.html">https://www.vpser.net/manage/screen.html</a></p><p>创建一个 screen: <code>screen -S screen_name</code><br>删除一个 screen: <code>screen -S screen_name -X quit</code></p><p>或者在其中<code>exit</code>来退出当前的会话</p><p>回到一个 screen: <code>screen -x screen_name</code></p><p>或者 <code>screen -r screen_name</code></p><p>当然也可以通过<code>screen -ls</code>查看每个回话的id号，以及是否attach。</p><p>可以通过<code>id</code>来替换<code>screen_name</code>，如<code>screen -r 11791</code></p><p>从 screen 返回 <code>ctrl+a</code>+<code>d</code>,先按下ctrl a再按下d即可</p><p>如何上下滚动鼠标</p><p>Ctrl + a然后按[，进入复制模式，就可以用鼠标滚轮了</p><p><a href="https://ubuntuqa.com/article/6360.html">https://ubuntuqa.com/article/6360.html</a></p><p><code>ctrl + a</code>+<code>ctrl + a</code>可以切换当前会话下的不同窗口，莫名奇妙在一个会话下，弄了两个窗口来申请了GPU节点，在这里记录一下这个切换。</p><h4 id="一种常见的情况，screen的嵌套"><a href="#一种常见的情况，screen的嵌套" class="headerlink" title="一种常见的情况，screen的嵌套"></a>一种常见的情况，screen的嵌套</h4><p>如，我遇到的情况是，在使用服务器时，首先新建一个screen的会话，在其中利用<code>srun -n16 --gres=gpu:V100:1 --pty bash </code>申请一个GPU节点。再在当前的GPU节点的主机上，新建一个screen会话，再其中运行程序。这样就可以返回上一级GPU节点，使用<code>htop</code>和<code>nvidia-smi</code>查看相关的信息。</p><p>但是，直接使用<code>ctrl a d</code>回直接返回最外面一层的会话。正确的方法应该为<code>ctrl a </code> + <code>a d</code>这样可以从最内侧来返回上一层的会话。</p><p>参考链接为ssh嵌套的情况<a href="https://wiki.archlinux.org/title/GNU_Screen">https://wiki.archlinux.org/title/GNU_Screen</a></p><blockquote><p>It is possible to get stuck in a nested screen session. A common scenario: you start an SSH session from within a screen session. Within the SSH session, you start screen. By default, the outer screen session that was launched first responds to <code>Ctrl+a</code> commands. To send a command to the inner screen session, use <code>Ctrl+a</code> <code>a</code>, followed by your command. For example:</p><p><code>Ctrl+a</code> <code>a</code> <code>d</code> Detaches the inner screen session.</p><p><code>Ctrl+a</code> <code>a</code> <code>K</code> Kills the inner screen session.</p></blockquote><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>除了使用screen之外，也可以使用nohup来保持程序在ssh断开之后的持续运行。查询到常见命令如下。</p><p><code>nohup command &gt; myout.file 2&gt;&amp;1 &amp; </code></p><p>在使用<code>command</code>之后，将输出的相关日志信息重定向到<code>myout.file</code>。其中，<code>&gt;</code>为覆盖式的写入，<code>&gt;&gt;</code>为在文件后面继续写入。如，使用nohup运行一测试程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> /home/ubuntu-4/anaconda3/bin/python3.8 /home/ubuntu-4/COVID19/test_nohup.py &gt;&gt; hello.log 2&gt;&amp;1 &amp; </span><br></pre></td></tr></table></figure><p>可以通过<code>tail hello.log</code>来查看输出的信息。但是，如果使用hello.log来保存python中的print信息的话，由于python中使用缓存机制，所输出的语句并不会实时显示。可以通过在print语句中加入flush来实现实时的输出。</p><p>==最后会显示Done==（not sure），在测试程序中实验的时候，在程序跑完之后确实可以看到进程打印了Done。但是，在ssh断开之后，父进程丢失。运行程序的进程变成了孤儿进程，我也不知道怎么恢复，只能从log信息中来获取。由于，我是在nnunet程序上做的实验，没有成功，这个方法就作罢了。</p><p>nnUNet_plan_and_preprocess -t 101 -tf 2 -tl 2 –verify_dataset_integrity | tee nnunet_pre_2nd.log</p><p>nohup nnUNet_plan_and_preprocess -t 101 –verify_dataset_integrity &gt;&gt; nnunet_pre.log 2&gt;&amp;1 &amp;</p><p>==最后执行完会显示Done==</p><p>nohup nnUNet_plan_and_preprocess -t 101 –verify_dataset_integrity &gt;&gt; /home/ubuntu-4/COVID19/nnunet_pre.log 2&gt;&amp;1 &amp;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一般的情况而言，我觉得使用<strong>screen</strong>加上，python中的<strong>logger</strong>输出到指定文件中是比较好的方法，直接使用print进行打印，并不是一个很好的方法。</p><p>但是在nnunet中，由于我不是很懂这份代码，我采用的策略是，新建一个screen会话，将程序中的print结果保留到result.log当中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python xxx.py | <span class="built_in">tee</span> result.log</span><br></pre></td></tr></table></figure><p>我最后并没有采用<code>nohup</code>和<code>tmux</code>，简单地掌握了<code>screen</code>的这几个命令，应该足够使用了，再遇到新的问题的时候，再去谷歌查screen的用户手册吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nnUnet的使用</title>
      <link href="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="开始的废话"><a href="#开始的废话" class="headerlink" title="开始的废话"></a>开始的废话</h2><p>刚放假的时候，满怀干劲的准备和师兄发一篇论文，准备用nnunet来跑一个baseline。虽然这篇论文现在黄了，但是好歹让我忙碌了一段时间，没有在假期一直浑浑噩噩，胡思乱想。在这里记录一下nnunet的主要流程和遇到的问题。</p><p>另外，使用nnunet并不需要看懂nnunet的论文。由于时间关系，我只看了一点点，可以直接根据作者的github仓库<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a>来做，不懂的地方可以提issue。作者回复的还是挺快的。</p><p>下面对github仓库中的内容，做一个简单的总结。</p><span id="more"></span><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>创建虚拟环境，安装pytoch（一般在pytorch官网选择自己想要的安装方式，conda， pip都是支持的，通常情况下pip的安装速度要快一点）</p></li><li><p>安装nnUnet，一般需要修改部分配置，选择第二种配置</p><p>For use as integrative <strong>framework</strong> (this will create a copy of the nnU-Net code on your computer so that you can modify it as needed)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/MIC-DKFZ/nnUNet.git</span><br><span class="line"><span class="built_in">cd</span> nnUNet</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure></li><li><p>配置数据格式，以及在<code>~/.bashrc</code>中设置三个环境变量</p></li><li><p>可选步骤，输出拓扑图</p></li></ol><p>安装pytorch和nnunet算是非常简单了，在conda中可能需要换源（需要用到清华的镜像），在用git克隆仓库时，可能需要能够比较顺畅的连接github。下面，着重讲一下开始的阶段最耗时的第一步，将数据预处理为nnunet所需要的命名格式。</p><h3 id="nnUnet数据格式"><a href="#nnUnet数据格式" class="headerlink" title="nnUnet数据格式"></a>nnUnet数据格式</h3><p><a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a></p><ul><li>针对每一个Task（数据集）</li></ul><p><code>nnUNet_raw_data_base</code> 文件夹存放数据（==Tips==，我开始以为这个文件夹的名字必须为nnUNet_raw_data_base，其实不是的，在环境变量中合理设置即可）。但是<code>nnUNet_raw_data</code>这个文件夹的名字是写死的。</p><p>每一个==数据集(dataset)==叫一个独立的<code>Task</code></p><p>每一个数据集有一个<code>Task_id</code></p><p>每个数据集表示的文件夹命名格式为<code>Taskxxx_name</code>（xxx为三位，name随便你取），如<code>Task001_BrainTumour</code>,<code>Task002_Heart</code></p><p>每一个Task存放在文件夹<code>nnUNet_raw_data_base/nnUNet_raw_data/</code></p><p>文件排布如下：</p><blockquote><p>nnUNet_raw_data_base/nnUNet_raw_data/<br>├── Task001_BrainTumour<br>├── Task002_Heart<br>├── Task003_Liver<br>├── Task004_Hippocampus<br>├── Task005_Prostate<br>├── …</p></blockquote><p>==在本例中，只使用新冠数据，因只有一个文件夹，为了避免和已有的数据集冲突，我将自己的数据集ID设为101（官方现在好像又推荐到500之后了，反正101我试了没问题）Task101_CovidInfection==</p><ul><li><p>针对每一个Task文件夹内部，格式应该为：</p><blockquote><p>Task001_BrainTumour/<br>├── dataset.json<br>├── imagesTr<br>├── (imagesTs)<br>└── labelsTr</p></blockquote><p><code>imagesTr</code>存放==训练集==，<code>imagesTs</code>存放==测试集==，<code>labelsTr</code>存放==标签数据==。</p><p>只有预测和算最后的精度用到了<code>imagesTs</code>,训练的时候完全没有用。（在训练时，这是可选项）。</p><p><code>dataset.josn</code>可以用程序生成，也可以参考example中很多自己直接写的，其实就几个参数，还是比较容易看懂的。</p><p>==训练数据可以有任意的灰度值，标签数据0代表背景，1代表类别1…直到类别n==（注意，标注的数据需要连续，比如brast2019中的标注的四个区域不连续，需要修改）</p><p>命名规则：</p><p>一个训练CT：<code>casename_identifier_XXXX.nii.gz</code></p><p>对应标签CT：<code>casename_identifier.nii.gz</code></p><p><del><code>casename</code>自己取得名字，<code>identififier</code>从001，002，003…，表示的是不同的病人例子的编号。</del>（==注意，删除线的说法是错误的。<code>case_identifier</code>可以任意取，只要不同即可，可参考brats的官方命名方式==</p><p><code>XXXX</code>表示的是同一个病人模态的标号，如CT，不同形式的核磁，从0000，0001…开始</p><p>例子如下：</p><p>Task001脑肿瘤分割任务，对于第一个case001有4个模态，FLAIR (0000), T1w (0001), T1gd (0002) and T2w (0003)。对应的label文件，BRATS_001.nii.gz</p><blockquote><p>nnUNet_raw_data_base/nnUNet_raw_data/Task001_BrainTumour/<br>├── dataset.json<br>├── imagesTr<br>│   ├── BRATS_001_0000.nii.gz<br>│   ├── BRATS_001_0001.nii.gz<br>│   ├── BRATS_001_0002.nii.gz<br>│   ├── BRATS_001_0003.nii.gz<br>│   ├── BRATS_002_0000.nii.gz<br>│   ├── BRATS_002_0001.nii.gz<br>│   ├── BRATS_002_0002.nii.gz<br>│   ├── BRATS_002_0003.nii.gz<br>│   ├── BRATS_003_0000.nii.gz<br>│   ├── BRATS_003_0001.nii.gz<br>│   ├── BRATS_003_0002.nii.gz<br>│   ├── BRATS_003_0003.nii.gz<br>│   ├── BRATS_004_0000.nii.gz<br>│   ├── BRATS_004_0001.nii.gz<br>│   ├── BRATS_004_0002.nii.gz<br>│   ├── BRATS_004_0003.nii.gz<br>│   ├── …<br>├── imagesTs<br>│   ├── BRATS_485_0000.nii.gz<br>│   ├── BRATS_485_0001.nii.gz<br>│   ├── BRATS_485_0002.nii.gz<br>│   ├── BRATS_485_0003.nii.gz<br>│   ├── BRATS_486_0000.nii.gz<br>│   ├── BRATS_486_0001.nii.gz<br>│   ├── BRATS_486_0002.nii.gz<br>│   ├── BRATS_486_0003.nii.gz<br>│   ├── BRATS_487_0000.nii.gz<br>│   ├── BRATS_487_0001.nii.gz<br>│   ├── BRATS_487_0002.nii.gz<br>│   ├── BRATS_487_0003.nii.gz<br>│   ├── BRATS_488_0000.nii.gz<br>│   ├── BRATS_488_0001.nii.gz<br>│   ├── BRATS_488_0002.nii.gz<br>│   ├── BRATS_488_0003.nii.gz<br>│   ├── BRATS_489_0000.nii.gz<br>│   ├── BRATS_489_0001.nii.gz<br>│   ├── BRATS_489_0002.nii.gz<br>│   ├── BRATS_489_0003.nii.gz<br>│   ├── …<br>└── labelsTr<br>   ├── BRATS_001.nii.gz<br>   ├── BRATS_002.nii.gz<br>   ├── BRATS_003.nii.gz<br>   ├── BRATS_004.nii.gz<br>   ├── …</p></blockquote><p>在本次实验中，没有多个模态。因此数据应为：</p><blockquote><p>nnUNet_raw_data_base/nnUNet_raw_data/Task101_CovidInfection/<br>├── dataset.json<br>├── imagesTr<br>│   ├── COVID_001_0000.nii.gz<br>│   ├── COVID_002_0000.nii.gz<br>│   ├── …<br>├── imagesTs<br>│   ├── COVID_409_0000.nii.gz<br>│   ├── COVID_410_0000.nii.gz<br>│   ├── …<br>└── labelsTr<br>   ├──COVID_001.nii.gz<br>   ├──COVID_002.nii.gz<br>   ├── …</p></blockquote><p>==For each training case, all images must have the same geometry to ensure that their pixel arrays are aligned. Also make sure that all your data is co-registered!==所有的图片都要有一样的形状，并且配准了。</p></li></ul><ul><li><p>生成datasets.json（对于==整个数据集==来说）</p><p>还没看，用程序生成<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/dataset_conversion.md</a></p><p>很简单看例子即可。</p><p>也可以参考nnUnet/nnunet.dataset_conversion中的例子，那里面有很多公开数据集的手动数据转换。</p></li></ul><ul><li><p>How to use 2D data with nnU-Net</p><p>Essentially, all images must be converted to pseudo 3D images (so <strong>an image with shape (X, Y).</strong> When loading the images with SimpleITK, the resulting numpy array **shape should be (1, x, y). **We recommend you save your images with SimpleITK so that the correct shape is guaranteed. </p></li></ul><h3 id="配置环境变量How-to-set-environment-variables"><a href="#配置环境变量How-to-set-environment-variables" class="headerlink" title="配置环境变量How to set environment variables"></a>配置环境变量How to set environment variables</h3><p>上述的过程是配置了<code>nnUNet_raw_data_base/nnUNet_raw_data/</code>文件夹，我们仍然需要其余的两个文件夹<code>nnUNet_preprocessed</code>,<code>RESULTS_FOLDER</code>两个文件夹。</p><ul><li><code>nnUNet_preprocessed</code>用于存放预处理生成的文件，==一定==放在一块==SSD上==。（<em>个人感觉这个文件夹生成的东西还是很大的，我个人的数据集生成了200G的数据</em>)。用机械盘真的处理的，非常非常非常的慢。</li><li><code>RESULTS_FOLDER</code>用来存放模型的结果，也可以存放<strong>预处理的模型</strong></li></ul><p><a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/setting_up_paths.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/setting_up_paths.md</a></p><p>设置这三个环境变量。</p><ol><li><p><code>cd</code></p><p>cd到home目录下</p></li><li><p>编辑<code>.bashrc</code></p><p>感觉直接用vscode编辑即可。如果没有<code>.bashrc</code>，可以<code>touch /home/usrname/.bashrc</code>来生成</p></li><li><p>添加相关的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> nnUNet_raw_data_base=<span class="string">&quot;/media/fabian/nnUNet_raw_data_base&quot;</span></span><br><span class="line"><span class="built_in">export</span> nnUNet_preprocessed=<span class="string">&quot;/media/fabian/nnUNet_preprocessed&quot;</span></span><br><span class="line"><span class="built_in">export</span> RESULTS_FOLDER=<span class="string">&quot;/media/fabian/nnUNet_trained_models&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>reload the <code>.bashrc</code>。用命令来使得环境变量生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /home/fabian/.bashrc</span><br></pre></td></tr></table></figure></li></ol><p>也可以设置暂时的环境变量，只在当前的终端中有用。不是很建议使用，这里就不写了。</p><hr><h2 id="数据预处理Experiment-planning-and-preprocessing"><a href="#数据预处理Experiment-planning-and-preprocessing" class="headerlink" title="数据预处理Experiment planning and preprocessing"></a>数据预处理Experiment planning and preprocessing</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity</span><br></pre></td></tr></table></figure><p><code>nnUNet_plan_and_preprocess</code>该命令进行预处理和提取数据特征</p><p><code>XXX</code>指的是Tash任务的编号<code>TaskXXX_MYTASK</code>，在这里是<code>000</code>对应着<code>Task000_CovidInfection</code></p><p><code>--verify_dataset_integrity</code>验证数据是否正确，必须在第一次运行时使用。</p><p>当内存不够时候，可以使用<code>-tl</code>和<code>-tf</code>选项</p><p>在完成此行命令后，a preprocessed copy of the data will be located at <code>nnUNet_preprocessed/TaskXXX_MYTASK</code></p><h3 id="预处理中遇到的问题"><a href="#预处理中遇到的问题" class="headerlink" title="==预处理中遇到的问题=="></a>==预处理中遇到的问题==</h3><p>开始的时候在实验室的机子上跑，总是会遇到程序’stuck’住的现象。<a href="https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/common_problems_and_solutions.md">https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/common_problems_and_solutions.md</a>，主要的原因还是因为内存耗尽了。解决方案，仍然参考文档。</p><ol><li><code>-tl</code>和<code>-tf</code>可以调整为2，实在不行可以调整为1。可以通过<code>-h</code>查看具体参数的意思</li><li>拿出SSD的空间，作为swap的区域。<a href="https://blog.csdn.net/weixin_37532614/article/details/119239715">https://blog.csdn.net/weixin_37532614/article/details/119239715</a></li></ol><p>我采取的是方法1，把线程数变成2之后，处理速度相当慢。预处理的时间其实也还是蛮长的。(这个也是看数据的，brats数据处理起来就非常的快，大概10几分钟就处理完的，我的私有数据处理整整一天)</p><h3 id="预处理后pre文件中应该有的文件"><a href="#预处理后pre文件中应该有的文件" class="headerlink" title="预处理后pre文件中应该有的文件"></a>预处理后pre文件中应该有的文件</h3><ul><li>下图为brats19预处理结果</li></ul><p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt="截屏2022-02-07 19.26.10"></p><p>其中，<code>splits_final.pkl</code>可以用程序打开看一看，保存的是五折交叉验证，对训练集和验证集的划分。</p><p>其实，也可以<strong>自己修改数据的划分</strong>，可以在<code>common_question</code>中找到。（这样的话，假如只训练一折，可以直接将测试集作为本次实验的验证集，可以直接在训练后得到，不用再预测和计算了）</p><ul><li>下图为私有数据集的预处理结果</li></ul><p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.29.27.png" alt="截屏2022-02-07 19.29.27"></p><p>不知道为什么多了一个<code>nnUNetData_plans_v2.1_stage1</code></p><p>根据我个人的理解，含有2D的文件夹是训练2d模型需要的，其他是训练3D模型需要的。如果磁盘空间不够大的话，可以考虑删除部分文件夹的内容。</p><p>（其实利用<code>-h</code>可以查看该命令的更多帮助信息，应该是可以在预处理的时候，不准备3D模型的，但是我嫌麻烦，具体没有尝试。）</p><hr><h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>感觉70%的工作已经完成了，剩下来的训练和预测步骤，多使用<code>-h</code>查看帮助即可。</p><p>训练采取的是五折交叉验证，如果要进行postprocessing and ensembling（我并没有做），是<strong>必须</strong>把五折交叉做完的。在这里，我只跑一折。</p><p>命令结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_train CONFIGURATION TRAINER_CLASS_NAME TASK_NAME_OR_ID FOLD  --npz (additional options)</span><br></pre></td></tr></table></figure><p><code>--npz</code>参数也是需要用在后处理中，我也没加。并不影响跑完一折的预测。</p><h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p>这里还是举两个具体例子吧</p><p>2D模型</p><p>For FOLD in [0, 1, 2, 3, 4], run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2 TaskXXX_MYTASK FOLD --npz</span><br></pre></td></tr></table></figure><p>注意，==FOLD==的取值为0，1，2，3，4</p><p>下面为跑一折2d的模型，在我自己修改的类<code>nnUNetTrainerV2_mine</code>上， 101为我的数据集的id，即前文中取得名字。用<code>tee</code>来保存print打印的数据到指定的文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2_mine 101 0 | <span class="built_in">tee</span> nnunet_train_200epoch_01_27_15_55.log</span><br></pre></td></tr></table></figure><p>跑3D模型同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_train 3d_fullres nnUNetTrainerV2_mine 102 0 | <span class="built_in">tee</span> xxx.log</span><br></pre></td></tr></table></figure><h3 id="修改属于自己的类"><a href="#修改属于自己的类" class="headerlink" title="修改属于自己的类"></a>修改属于自己的类</h3><p>在<code>nnUNet/nnunet/training/network_training</code>文件夹中有大量的类，大多数情况下使用的是<code>nnUNetTrainerV2</code>这个类。在这里我只对epoch数进行修改，所以直接将<code>nnUNetTrainerV2_fp32.py</code>的内容复制一下，修改一下epoch即可。==注意==,记得修改类的名字为自己取的名字，并在上面的命令中替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nnunet.training.network_training.nnUNetTrainerV2 <span class="keyword">import</span> nnUNetTrainerV2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">nnUNetTrainerV2_mine</span>(<span class="title class_ inherited__">nnUNetTrainerV2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Info for Fabian: same as internal nnUNetTrainerV2_2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plans_file, fold, output_folder=<span class="literal">None</span>, dataset_directory=<span class="literal">None</span>, batch_dice=<span class="literal">True</span>, stage=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 unpack_data=<span class="literal">True</span>, deterministic=<span class="literal">True</span>, fp16=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(plans_file, fold, output_folder, dataset_directory, batch_dice, stage, unpack_data,</span><br><span class="line">                         deterministic, fp16)</span><br><span class="line">        self.max_num_epochs = <span class="number">101</span>  <span class="comment"># 这是我做的修改</span></span><br></pre></td></tr></table></figure><h3 id="训练结束"><a href="#训练结束" class="headerlink" title="训练结束"></a>训练结束</h3><p>应该会在print中输出done。你设定的epoch数跑完之后，训练并没有完成。据我观察，接下来是对验证集的一些计算，在<code>validation_raw</code>文件夹中生成相关的文件，其中<code>.nii.gz</code>应该包换所有的验证集的数据。<code>summay.json</code>可以查看具体的在验证集中的训练精度。官方文件树机构如下</p><p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.55.05.png" alt="截屏2022-02-07 19.55.05"></p><p>我的文件结构</p><p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.55.51.png" alt="截屏2022-02-07 19.55.51"></p><p>其中<code>fold_0</code>文件夹</p><p><img src="/2022/02/08/nnUnet%E7%9A%84%E4%BD%BF%E7%94%A8/%E6%88%AA%E5%B1%8F2022-02-07%2019.56.20.png" alt="截屏2022-02-07 19.56.20"></p><p>在这里我只关注了<code>summary.josn</code>文件中的进度信息。</p><hr><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>如果寻找了最优参数，按照其提示进行预测。</p><p>我跳过了寻找最优参数，直接对一折的训练结果进行预测。</p><p>预测的每一个case的命名方式与之前一致</p><p>还是推荐查看<code>-h</code>来选择适合的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_predict -i INPUT_FOLDER -o OUTPUT_FOLDER -t 101 -m 2d -<span class="built_in">tr</span> nnUNetTrainerV2_mine -f 0 </span><br></pre></td></tr></table></figure><p><code>-t</code>选择具体的任务,<code>-m</code>选择训练的模型，我进行的是2d，<code>-tr</code>选择训练的类，<code>-f</code>选择对第几折的结果进行预测（按照帮助，好像是可以自动的选择的）</p><hr><h2 id="计算精度"><a href="#计算精度" class="headerlink" title="计算精度"></a>计算精度</h2><p>在这里我计算的是预测结果的进度。</p><p>命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_evaluate_folder -ref FOLDER_WITH_GT -pred FOLDER_WITH_PREDICTIONS -l 1 2 3 4</span><br></pre></td></tr></table></figure><p>其中1,2,3,4代表有4个前景，如果你是做二分类，只需要写1即可。</p><p>==注意==，由于数据的问题，可能会有部分的预测结果为0，在<code>summary.json</code>中很明显，要注意及时查看数据的问题，或者删除相关的数据。</p><h3 id="具体文件的实现"><a href="#具体文件的实现" class="headerlink" title="具体文件的实现"></a>具体文件的实现</h3><p>在<code>nnUNet/nnunet/evaluation/metrics.py</code>中nnunet几乎实现了所有的指标，我需要使用到三个指标<code>Dice, sensitivity, HD95</code>，注意==recall==就是sensitivity。</p><p>具体的计算是调用了<code>nnUNet/nnunet/evaluation/evaluator.py</code>，默认的实现是没有输出hd95的结果的。</p><p>我将<code>&quot;Hausdorff Distance 95&quot;</code>加入了<code>37</code>行的列表<code>default_metrics</code>中，并在下面的<code>default_advanced_metrics</code>中注释掉了。结果是可行的，应该将下面的一个False改为True，也可以计算<code>default_advanced_metrics</code>中的HD95，不过我没有尝试。</p><p>在这里nnunet应该是开了多个线程来计算这一结果，比我自己写的一个个计算的代码快了很多倍。针对我的100多个数据，很快就得到了结果。</p><hr><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol><li><p>检查病人ct的标注的范围，nnunet要求0为背景，其余前景要求<strong>连续</strong>为1,2,3….（如，在brats19中，前景值为1，2，4，需要做对应的修改，可参考nnunet的官方对brast19的转换）。</p></li><li><p>数据的移动和重命名。前文中提到，nnunet只对原始数据的尾缀，有要求。为0000,0001,0002…来代表不同的模态。对之前的<code>case_identifier</code>并没有要求。</p><p>常见的python中移动文件操作</p><ol><li><p>直接执行cp命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;cp -r &#x27;</span> + case_path + <span class="string">&#x27; &#x27;</span> + test_path)</span><br></pre></td></tr></table></figure></li><li><p>shutil.copyfile</p><p>文件到文件的移动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(old_file, new_file)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>预处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity</span><br></pre></td></tr></table></figure><p>必要时调整<code>-tf</code>，<code>-tl</code>。针对内存不足的情况，可以修改swap。不过还是在几百个G大内存的服务器上跑舒服。</p></li><li><p>训练</p><p>如2d模型，跑<strong>第0折</strong>训练</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_train 2d nnUNetTrainerV2_mine 101 0 | <span class="built_in">tee</span> nnunet_train_200epoch_01_27_15_55.log</span><br></pre></td></tr></table></figure><p>等待<code>summart.josn</code>文件生成之后，训练应该基本结束了。而且结尾应该也会答应done。</p></li><li><p>预测</p><p>预测时，注意选择自己需要的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_predict -i INPUT_FOLDER -o OUTPUT_FOLDER -t 101 -m 2d -<span class="built_in">tr</span> nnUNetTrainerV2_mine -f 0 | <span class="built_in">tee</span> nnunet_inference_01_28_16_11.log</span><br></pre></td></tr></table></figure></li><li><p>评估</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnUNet_evaluate_folder -ref FOLDER_WITH_GT -pred FOLDER_WITH_PREDICTIONS -l 1 2 3 4</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="遇到问题怎么办？"><a href="#遇到问题怎么办？" class="headerlink" title="遇到问题怎么办？"></a>遇到问题怎么办？</h2><p>在使用的时候可能会遇到各种各样的问题，可以多阅读作者写个答疑文档。也可以翻阅其他人提出的issue，如果还是没有解决，可以向作者提issue，他在一天之内，就回复了我提出的issue，在这里非常感谢Fabian无私地奉献。</p><p>我遇到的问题都是程序卡住的问题。</p><p>第一次程序卡住，是在预处理时程序卡住，开始以为是screen或者是nohup的问题，后来发现应该是内存耗尽了。可以在程序卡住的附近，注意观察。</p><p>==Tips==，在运行程序时，可以通过<code>htop</code>来查看CPU，内存和相关进程的情况。鼠标点击右下角退出。</p><p>使用<code>watch -n 0.1 nvidia-smi</code>来每隔0.1秒观察GPU的使用情况。</p><p>在预处理阶段，我建议使用<code>-tf</code>和<code>-tl</code>设置成1或者2的方式来解决卡住的问题。</p><p>第二次程序卡住，是在训练阶段。生成验证集数据并计算的时候，我的程序在生成了一个<code>npz</code>文件之后，呆在那长达数小时。由于我有300G的内存，并没有考虑内存的问题。可能是原始数据过大，我所使用的服务器小文件IO速度非常慢的原因造成。只需要耐心一点，一两天之后再回来看看，估计就有新的进展了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云服务器可视化和内网穿透</title>
      <link href="/2021/11/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2021/11/23/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>很久没有更新博客了，开学两个多月一直太懒了，从大四的惰性大概延续了整整一年吧。<br>最近双十一在阿里云购置了一个100元3年的云服务器，简单介绍一下自己搜索的使用教程。  </p><h2 id="云服务器的可视化连接（VNC）"><a href="#云服务器的可视化连接（VNC）" class="headerlink" title="云服务器的可视化连接（VNC）"></a>云服务器的可视化连接（VNC）</h2><p>云服务器的可视化连接主要是参考了阿里云的这篇官方文档。<br><a href="https://help.aliyun.com/knowledge_detail/59330.html?spm=a2c6h.13066369.0.0.6b957f94089Pc8&userCode=28kqeewo">通过VNC搭建Ubuntu 18.04和20.04图形界面</a></p><span id="more"></span><h2 id="通过drp实现内网穿透"><a href="#通过drp实现内网穿透" class="headerlink" title="通过drp实现内网穿透"></a>通过drp实现内网穿透</h2><p>因为有在远端连接实验室电脑的需求，简单了解了一下frp的配置。首先要利用到具有公网ip的云服务器作为跳转，就可以访问在内网的实验室主机了。  </p><p>这是frp的官方文档<a href="https://gofrp.org/docs/examples/ssh/">通过 SSH 访问内网机器</a>  </p><ol><li><p>在服务器端（此处为阿里云），安装drps。在frp的github的release中，选择适合的版本的。我这里选择的是linux_amd64，右键复制链接。在合适的目录下，进行下载解压。或者手动下载和解压。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xzvf frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> frp_0.38.0_linux_amd64 frp</span><br></pre></td></tr></table></figure></li><li><p>编辑服务器端的配置文件<code>frps.ini</code>。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br></pre></td></tr></table></figure><p> 设置了 frp 服务器用户接收客户端连接的端口。<strong>记得在阿里云的安全组中，打开对应的端口</strong></p></li><li><p>启动服务器端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure></li><li><p>接下来配置客户端，也就是要访问的远端服务器。下载解压重命名，同上操作，这里不再重复。</p></li><li><p>配置客服端文件<code>frpc.ini</code>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line"> server_addr = x.x.x.x</span><br><span class="line"> server_port = 7000</span><br><span class="line"></span><br><span class="line"> [ssh]</span><br><span class="line"> <span class="built_in">type</span> = tcp</span><br><span class="line"> local_ip = 127.0.0.1</span><br><span class="line"> local_port = 22</span><br><span class="line"> remote_port = 6000</span><br></pre></td></tr></table></figure><p>frps 所在服务器的公网 IP 为 x.x.x.x。<br>local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。</p></li><li><p>启动客户端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c frps.ini</span><br></pre></td></tr></table></figure></li><li><p><code>ssh -oPort=6000 test@x.x.x.x</code>.。通过访问，你设置的远端端口，即可访问到内网的主机。<strong>test为本机用户名，密码为本机密码!!</strong></p></li></ol><p>可以参考的b站配置视频<a href="https://www.bilibili.com/video/BV16441187zf">https://www.bilibili.com/video/BV16441187zf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中赋值,浅拷贝,深拷贝理解</title>
      <link href="/2021/07/25/Python%E4%B8%AD%E8%B5%8B%E5%80%BC-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%90%86%E8%A7%A3/"/>
      <url>/2021/07/25/Python%E4%B8%AD%E8%B5%8B%E5%80%BC-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文对查阅的相关资料做一个简单的总结，方便日后方便时查阅。  </p><p>首先，明确两个概念 <em>“可变对象类型”</em> 和 <em>不可变对象类型</em>。参考<a href="https://www.jianshu.com/p/b3157c9751d0">https://www.jianshu.com/p/b3157c9751d0</a>。可变对象类型，包括列表，字典，集合。不可变对象类型，包括元组，整形，浮点型，字符串。<br>对于可变对象，对对象内部的值进行改变时，对象的内存地址不会发生改变。（变量，也就是标签指向的内存地址，任然没有改变）如下： </p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; a.append(4)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br></pre></td></tr></table></figure><p>对于不可变对象，对象的值发生改变时。创建了一块新的内存，标签（变量名）指向这块新的内存。</p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>在了解赋值之前，先解释Python中的”is”与”==”<br>a is b 实际就是判断 id(a)与id(b)是否相同<br>a == b 判断a与b的值是否相同<br>如下例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; c = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(a)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(b)</span><br><span class="line">140305476471880</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">id</span>(c)</span><br><span class="line">140305477663816</span><br><span class="line">&gt;&gt;&gt; a is b</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; a is c</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; a == c</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>赋值部分参考了<a href="https://www.jianshu.com/p/521bdd67790e">https://www.jianshu.com/p/521bdd67790e</a><br>先说一下结论:  </p><blockquote><p>1）<strong>“变量B=变量A”</strong>（变量A肯定已经指向某个对象了），对于变量之间的赋值，毫无悬念，两个变量最终指向同一个对象。<br>2）<strong>“变量A=对象”</strong>（如A = ‘python’），对于这种情况，如果对象在内存中不存在，那么将新建这个对象，然后将变量A指向该对象；如果对象已经存在了，那情况就稍微复杂了，部分情况是将变量指向原有的对象，部分情况会新建建一个对象（即使内存中已经有了一个值完全相同的对象），然后将变量指向这个新的对象！</p></blockquote><p>Python中的变量名，实际上为一个标签。每一个变量指向着内存中的一个对象。变量的类型、内存地址、值就是它指向对象的类型、内存地址、值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">300</span></span><br></pre></td></tr></table></figure><p>该赋值语句做了三件事：1）开辟了一块内存（可用id(a)查看地址）；2）将该内存的值设为300；3）将变量a指向该内存。在重新将a指向其他对象之前，a就一直指向该内存，也就一直代表整数300。这里内存中的300是狭义“对象”，是个实实在在存在的东西。</p><h2 id="变量-对象"><a href="#变量-对象" class="headerlink" title="变量 = 对象"></a>变量 = 对象</h2><h3 id="赋值时，对象在内存中并不存在"><a href="#赋值时，对象在内存中并不存在" class="headerlink" title="赋值时，对象在内存中并不存在"></a>赋值时，对象在内存中并不存在</h3><p>这种情况只要遵循，开辟内存，将变量指向内存即可。</p><h3 id="赋值时，对象在内存中已经存在"><a href="#赋值时，对象在内存中已经存在" class="headerlink" title="赋值时，对象在内存中已经存在"></a>赋值时，对象在内存中已经存在</h3><p>这种情况，又要分变量类型来讨论。<u>具体情况请参考上述的参考链接。  </u><br>总结下来就是整型，在一定范围-5~256时，出现新的变量名时，会指向同一块内存区域。列表型，字典型，<strong>每次都开辟新的内存空间。</strong>元组型，除了空元组之外，每次也都开辟新的内存空间。  </p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>拷贝参考了博客园的这篇文章<a href="https://www.cnblogs.com/eczhou/p/7860668.html">https://www.cnblogs.com/eczhou/p/7860668.html</a>，==写的非常好。==具体的示意图和解释，请移步该篇文章。</p><h3 id="赋值再解释"><a href="#赋值再解释" class="headerlink" title="赋值再解释"></a>赋值再解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = will</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure><p>总结：<strong>wilber is will，wilber[i] is will[i]</strong></p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝的几种情况：</p><ol><li>使用copy.copy()</li><li>使用切片[:]操作</li><li>使用工厂函数（如list/dir/set）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = copy.copy(will)</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure><p>总结: 浅拷贝换创建一个新的对象，也就是id(will)与id(willber)不同。<strong>wilber is not will，wilber[i] is will[i]</strong></p><h3 id="自己的一点补充"><a href="#自己的一点补充" class="headerlink" title="自己的一点补充"></a>自己的一点补充</h3><p>我觉得，一个改变，另一个跟着变。是因为该块内存区域，放置的是一个可变类型的对象。如果将此处标签指向其他内存块，做浅拷贝的对应地方并不会改变。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; a = [1,2,[3,4]]</span><br><span class="line">&gt;&gt;&gt; b = copy.copy(a)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, [3, 4]]</span><br><span class="line">&gt;&gt;&gt; a[2] = 15</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 15]</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[1, 2, [3, 4]]</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝只有一种方式：使用copy.deepcopy()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">will = [<span class="string">&quot;Will&quot;</span>, <span class="number">28</span>, [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>]]</span><br><span class="line">wilber = copy.deepcopy(will)</span><br><span class="line"></span><br><span class="line">will[<span class="number">0</span>] = <span class="string">&quot;Wilber&quot;</span></span><br><span class="line">will[<span class="number">2</span>].append(<span class="string">&quot;CSS&quot;</span>)</span><br></pre></td></tr></table></figure><p>总结：对于对象中的元素，深拷贝都会重新生成一份（有特殊情况，下面会说明），而不是简单的使用原始元素的引用（内存地址）。<strong>wilber is not will，wilber[2] is not will[2]。</strong>因为特殊情况，wilber[0] is will[0];wilber[1] is will[1]</p><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有拷贝这一说<br>也就是说，对于这些类型，”obj is copy.copy(obj)” 、”obj is copy.deepcopy(obj)”<br>如果元祖变量只包含原子类型对象，则不能深拷贝，看下面的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">books = (<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line">coopies = copy.deepcopy(books)</span><br><span class="line"><span class="built_in">print</span>(books <span class="keyword">is</span> coopies)  <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line">books = (<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Java&quot;</span>, [])</span><br><span class="line">coopies = copy.deepcopy(books)</span><br><span class="line"><span class="built_in">print</span>(books <span class="keyword">is</span> coopies)  <span class="comment">#False</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后引用文中的总结</p><blockquote><p>本文介绍了对象的赋值和拷贝，以及它们之间的差异：</p></blockquote><ul><li>Python中对象的赋值都是进行对象引用（内存地址）传递</li><li>使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用<em>原始的引用.</em></li><li>如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝</li><li>对于非容器类型（如数字、字符串、和其他’原子’类型的对象）没有被拷贝一说</li><li>如果元祖变量只包含原子类型对象，则不能深拷贝</li></ul><p>本文参考搬运了以下博客：<br><a href="https://www.jianshu.com/p/b3157c9751d0">https://www.jianshu.com/p/b3157c9751d0</a><br><a href="https://www.jianshu.com/p/521bdd67790e">https://www.jianshu.com/p/521bdd67790e</a><br><a href="https://www.cnblogs.com/eczhou/p/7860668.html">https://www.cnblogs.com/eczhou/p/7860668.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ITK-SNAP使用方法简介</title>
      <link href="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在准备毕设，基于CT影像来对胃癌肿瘤进行分割。首先要打开<code>.nii</code>格式的CT影像。在软件选择方面，简单查阅后了解到，可以使用ITK-SNAP，MITK（貌似是VTK和ITK的综合），Pairs（一个国内开发的软件，在导师朋友圈里看到，还没有下）。</p><h2 id="几种医学影像文件的格式"><a href="#几种医学影像文件的格式" class="headerlink" title="几种医学影像文件的格式"></a>几种医学影像文件的格式</h2><p><a href="https://www.jiqizhixin.com/articles/2017-07-31">使用深度学习进行医疗影像分析：文件格式篇</a></p><p><a href="https://wenku.baidu.com/view/0660f81e48d7c1c708a14579.html">常见医学图像格式</a></p><span id="more"></span><p>针对常见医学影像格式，我参照了上面的两篇文章。DICOM和NIFTI（.nii文件）是最常见的两种格式。据我自己的理解，这两种格式的主要差别为，NIFTI是包含头文件和一个图像文件，而且图像是三维的。DICOM是文件头部，以及每层的二维图像都存储为一个单独的文件。</p><h2 id="ITK-SNAP软件的简单使用"><a href="#ITK-SNAP软件的简单使用" class="headerlink" title="ITK-SNAP软件的简单使用"></a>ITK-SNAP软件的简单使用</h2><p>ITJ-SNAP文件的官网为<a href="http://www.itksnap.org/pmwiki/pmwiki.php?n=Main.HomePage">http://www.itksnap.org/pmwiki/pmwiki.php?n=Main.HomePage</a>选择右上角DOWNLOADS即可下载，支持windows,Macos和Linux三大平台。</p><p>其中官方的文档为<a href="http://www.itksnap.org/pmwiki/pmwiki.php?n=Documentation.SNAP3">http://www.itksnap.org/pmwiki/pmwiki.php?n=Documentation.SNAP3</a></p><h3 id="调整以及查看图像信息"><a href="#调整以及查看图像信息" class="headerlink" title="调整以及查看图像信息"></a>调整以及查看图像信息</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.05.17.png" alt="截屏2021-03-29 23.05.17"></p><p>调整窗宽窗位，level与windows，即大于max均为max的值，小于min均为min的值<img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.05.56.png" alt="截屏2021-03-29 23.05.56"></p><p>查看图像信息，箭头1 Dimensions，表示x方向有512张图片，y方向有512张图片，z方向有60张图片 </p><p>箭头2Voxel Spacing表示，一个体素，x方向代表0.7031毫米，其余方向类似</p><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.13.06.png" alt="截屏2021-03-29 23.13.06"></p><h3 id="工具栏1——十字架"><a href="#工具栏1——十字架" class="headerlink" title="工具栏1——十字架"></a>工具栏1——十字架</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.17.02-7031098.png" alt="截屏2021-03-29 23.17.02"></p><p>按照他提示中的功能：左键移动十字，右键并进行拖拽可以进行放大缩小（zoom），option键+鼠标左键可以平移（pan）图像，滚动鼠标滚轮查看不同的slices</p><p>左侧面板中的<code>cursor position</code>可以查看当前十字在三维中的位置。<code>Intensity under cursor</code>显示当前灰度值的强度，如果当前图像有标注的话，<code>Label under cursor</code>可以显示是哪一种标注</p><h3 id="套索工具"><a href="#套索工具" class="headerlink" title="套索工具"></a>套索工具</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.27.57.png" alt="截屏2021-03-29 23.27.57"></p><p>这个套索工具的功能和photoshop中的几种套索功能几乎是完全一样的。</p><p><code>Smooth curve</code>模式，用连续的曲线勾画一个选区。</p><p><code>Polygon</code>模式，用鼠标左边的点击不断的选择点，最后勾画出选区。</p><p><code>Invert polygon</code>反转当前的选区</p><h3 id="画笔工具"><a href="#画笔工具" class="headerlink" title="画笔工具"></a>画笔工具</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.31.29.png" alt="截屏2021-03-29 23.31.29"></p><p>这个画笔和photoshop的魔术棒那一栏工具很相似，特别是最后一个画笔风格。按照他的说明，鼠标左键勾画选区，鼠标右键擦除选区。</p><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.44.26.png" alt="截屏2021-03-29 23.44.26"></p><p>他提供了三种笔刷的格式，前两种只是形状不一样，一个正方形一个是圆形。</p><p><code>Brush Options</code>中的选项，<code>3D</code>代表，不止在当前这一个slices中建立选区，其他图层中也会建立选区。<em>但是3d功能，有一个坏处，他在每一个图层中的选区是一样的，而器官在不同的CT切片上是会变化的。</em><code>Cursor chases brush</code>在移动画笔时，十字也会跟着移动，这样在四个视图的情况下会比较有用。<code>Isotropic</code>的功能不是很清楚。</p><p>第三种笔刷是自适应的笔刷，类似photoshop中的魔术棒。他有两个特别的参数。Granularity类似容忍度，考虑当前灰度与周围灰度的差异。Smoothness确定了画笔的光滑度。</p><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.52.02.png" alt="截屏2021-03-29 23.52.02"></p><h3 id="对标记进行管理"><a href="#对标记进行管理" class="headerlink" title="对标记进行管理"></a>对标记进行管理</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-29%2023.58.26.png" alt="截屏2021-03-29 23.58.26"></p><p>箭头1——进行标记管理</p><p>箭头2——在3D窗口隐藏红色标记1</p><p>箭头3——在所有窗口隐藏红色标记2</p><p>箭头4——删除当前的标记</p><h3 id="其余小功能介绍"><a href="#其余小功能介绍" class="headerlink" title="其余小功能介绍"></a>其余小功能介绍</h3><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-30%2000.02.55.png" alt="截屏2021-03-30 00.02.55"></p><p>箭头1——全屏显示当前角度</p><p>箭头2——更新3D图像</p><p>箭头3——调整label的不透明度</p><h3 id="如何载入已经标注好的label"><a href="#如何载入已经标注好的label" class="headerlink" title="如何载入已经标注好的label"></a>如何载入已经标注好的label</h3><p>可以直接将文件拖拽到ITK-SNAP的页面，选择load as segmentation</p><p><img src="/2021/03/30/ITK-SNAP%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/%E6%88%AA%E5%B1%8F2021-03-30%2000.08.17.png" alt="截屏2021-03-30 00.08.17"></p><p>也可以选择load as additional image来和当前的图片进行一个比较</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTex在毕设论文中的简单使用</title>
      <link href="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近毕设论文准备利用LaTex模板来写，因此介绍一些LaTex的基础使用知识。（本篇的软件的使用均基于Mac os）。Windows下可以安装官方软件TexLive，Mac os可以安装官方软件MacTex 2019，也可以使用vscode或Texpad来进行LaTeX的书写。<br>如果你不愿意下载软件的话，也可以使用在线网站，overleaf来进行LaTeX的书写。</p><span id="more"></span><h2 id="LaTex的配置"><a href="#LaTex的配置" class="headerlink" title="LaTex的配置"></a>LaTex的配置</h2><h3 id="通过Vscode进行LaTex的书写（方法一）"><a href="#通过Vscode进行LaTex的书写（方法一）" class="headerlink" title="通过Vscode进行LaTex的书写（方法一）"></a>通过Vscode进行LaTex的书写（方法一）</h3><p>首先在Vscode的扩展市场中，下载两个插件LaTex Workshop，LTex。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic1.png" alt="两个扩展" title="两个扩展"><br>接着点击左下角的管理齿轮，选择设置（也可以使用<u>command + ,</u>)，点击右上角所示符号，进入json格式的配置。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic2.png" alt="vscode配置页面" title="vscode配置页面"></p><p>将以下配置粘入json配置文件的两个大括号之间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latex-workshop.latex.tools&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-pdf&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,          </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">        <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"><span class="string">&quot;latex-workshop.latex.recipes&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tools&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">                    ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;xelatex-&gt;bibtex-&gt;xelatex-&gt;xelatex&quot;</span>,  </span><br><span class="line">          <span class="string">&quot;tools&quot;</span>: [  </span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span>,  </span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,  </span><br><span class="line">          ]  </span><br><span class="line">        &#125;  </span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;latex-workshop.view.pdf.viewer&quot;</span>: <span class="string">&quot;browser&quot;</span>,  </span><br><span class="line"><span class="string">&quot;latex-workshop.latex.clean.fileTypes&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.out&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    ],</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这段是语法检查模块</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="string">&quot;ltex.enabled&quot;</span>: <span class="literal">true</span>, <span class="comment">// 设置语言，这里是德语</span></span><br><span class="line"><span class="comment">// 要英语就下载对应 English Support，然后这里填 en, 或者 en-US,en-GB 等*/</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，新建一个文件夹（如latex_tutoial），用来测试Latex的书写。新建hello_world.tex文件，输入一个基本的LaTeX代码.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line">    Hello World</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><p>在新建一个.tex文件之后，vscode左侧边栏会出现图示Tex选项，点击该选项，选择Build LaTex project-&gt;Recipe xelatex。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic3.png" alt="vscode页面截图" title="pic3"><br>编译完成之后，latex_tutoial文件夹会出现编译生成的文件。接着选择uild LaTex project-&gt;Clean up auxiliary files。可以清除编译生成的多余的文件。<br>点击右上键的预览按钮，可以预览latex对应生成的pdf文件。</p><h3 id="通过付费软件Texpad来进行LaTex的书写（方法二）"><a href="#通过付费软件Texpad来进行LaTex的书写（方法二）" class="headerlink" title="通过付费软件Texpad来进行LaTex的书写（方法二）"></a>通过付费软件Texpad来进行LaTex的书写（方法二）</h3><p>Texpad为Mac上的付费软件。它有着更为简洁的页面，以下标注出几个重点区域。软件其他按键区域，在鼠标悬停时有相应的中文提示。<br><img src="/2021/03/05/LaTex%E5%9C%A8%E6%AF%95%E8%AE%BE%E8%AE%BA%E6%96%87%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/pic4.png" alt="Texpad页面" title="Texpad页面"></p><p>以上内容参考了B站视频<a href="https://www.bilibili.com/video/BV1eQ4y1M7rQ">mac系统下LaTex快速配置与各种使用技巧</a></p><h2 id="LaTex的基本语法"><a href="#LaTex的基本语法" class="headerlink" title="LaTex的基本语法"></a>LaTex的基本语法</h2><p><code>待续。。。</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub搜索开源项目技巧</title>
      <link href="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍使用GitHub搜索栏时的搜索技巧，我们平时搜索时一般在在搜索栏中直接键入内容。<br>本文会介绍根据<strong>仓库名字，readme内容，description内容，star数，语言以及最近推送时间</strong>做限制条件来进行搜索。<br>首先以一个仓库的页面来介绍上述名字的意思<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic1.png" alt="spring_boot仓库界面"></p><span id="more"></span><p>接下来介绍在搜索框中的操作</p><h2 id="根据仓库名字进行搜索"><a href="#根据仓库名字进行搜索" class="headerlink" title="根据仓库名字进行搜索"></a>根据仓库名字进行搜索</h2><p><code>in:name spring boot</code>表示仓库的名字中带有spring boot</p><h2 id="根据readme内中的内容来进行搜索"><a href="#根据readme内中的内容来进行搜索" class="headerlink" title="根据readme内中的内容来进行搜索"></a>根据readme内中的内容来进行搜索</h2><p><code>in:readme 微服务</code>readme中含有“微服务”的仓库会被搜索</p><h2 id="根据description的内容来进行搜索"><a href="#根据description的内容来进行搜索" class="headerlink" title="根据description的内容来进行搜索"></a>根据description的内容来进行搜索</h2><p>description内容一般是对项目的简单描述，根据description来进行搜索会更加的准确<br><code>in:description spring boot stars:&gt;3000</code>表示在限定仓库描述中含有spring boot的同时，stars数大于3000</p><hr><h2 id="搜索时限定stars数"><a href="#搜索时限定stars数" class="headerlink" title="搜索时限定stars数"></a>搜索时限定stars数</h2><p><code>in:name spring boot stars:&gt;3000</code>表示在限定仓库名字中含有spring boot的同时，要求仓库的stars数大于3000</p><h2 id="搜索时限定语言"><a href="#搜索时限定语言" class="headerlink" title="搜索时限定语言"></a>搜索时限定语言</h2><p><code>in:description spring boot language:Java</code>在限定仓库的description中含有spring boot的同时，限定语言为Java来进行搜索</p><h2 id="搜索时限定最近推送时间"><a href="#搜索时限定最近推送时间" class="headerlink" title="搜索时限定最近推送时间"></a>搜索时限定最近推送时间</h2><p><code>in:description spring boot language:Java pushed:&gt;2019-09-03</code>搜索description中含有spring boot且使用Java语言，且最近一次更新时间在2019-09-03之前进行搜索。</p><hr><h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><p>单独搜索spring boot<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic2.png" alt="pic2"><br>在description中搜索spring boot基础，可以看到spring boot官方那个仓库已被筛除<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic3.png" alt="pic3"><br>加上限制条件，stars数要求大于1000，可以看到上一张图的最后一个仓库被筛除了<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic4.png" alt="pic4"><br>再加上限制条件，要求最后一个push时间要晚于2019-01-01号，可以看到更新与18年的那个仓库被筛除了<br><img src="/2021/01/23/GitHub%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8A%80%E5%B7%A7/pic5.png" alt="pic5"></p><p>本文完全参考了B站up主codesheep的视频，来源如下<a href="https://www.bilibili.com/video/BV1yJ411S7Wu?from=search&seid=13430377427568355855">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作</a><br>另，在github的advanced search中有更多的高级搜索选项。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020北航，南大软院，计算所夏令营，北邮，西交人机所预推免记录</title>
      <link href="/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="北航夏令营流程"><a href="#北航夏令营流程" class="headerlink" title="北航夏令营流程"></a>北航夏令营流程</h2><h3 id="大致情况"><a href="#大致情况" class="headerlink" title="大致情况"></a>大致情况</h3><p>北航夏令营一共就两天，节奏非常的快。有大约600个人入营，最后170人左右优营。600个人里，应该还有不少没有参加北航夏令营，去参加那天冲突的其他学校去了。</p><p>一共两部分，分为机考和面试。机考环节可以提交CSP考试成绩进行代替，只要累计排名前百分之50都可以提交。建议排名不是很高的话，可以考一下机试，今年的难度不是很大。</p><span id="more"></span><h3 id="机考部分"><a href="#机考部分" class="headerlink" title="机考部分"></a>机考部分</h3><p>机试语言为C++或C，允许使用STL。</p><p>第一题60分，和<a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805407749357568">PAT A1064</a>几乎完全一样，除了题干描述，稍有不同，代码是完全相同的。主要是，考查二叉树的中序遍历顺序是有序的，和对一颗已知结构的二叉树进行中序遍历。</p><p>第二题40分，是一道模拟题，模拟函数调用的过程。题目给出了，push main, push sqr, push ABC, pop, pop, pop。这样一系列的压栈和弹栈的操作，来模拟函数调用。最后要求输出，压栈最深的函数，如本题中为ABC。以及它对应的调用函数的次数，调用次数和扇入数（关于扇入数，题干有充分的解释）。如果有多个函数深度相同，则所有情况都要输出。</p><p>我主要用了stl中的vector, set等来硬做，没有想到什么简便的技巧。</p><h3 id="面试部分"><a href="#面试部分" class="headerlink" title="面试部分"></a>面试部分</h3><p>面试部分。每人限时20分钟，老师问满20分钟，就会马上停止问下一位同学了。</p><p>今年的面试流程是，</p><p>第一部分思政题，应该是不计分的。我被问到的是，如何看待在这次疫情中我们国家制度的优越性？只要不偏离主旋律，正常答就行。</p><p>第二部分，英文问答。第一问，please briefly introduce yourself.背一下英文自我介绍就行。第二问，你擅长什么东西？请你具体的描述一下。</p><p>第三部分，数学问题两题（我复习的线代和概率论部分都没问到）。第一题，集合论，是否存在一个集合到其所有子集的元素的映射？（不知道描述，准不准确）。完全不会，说了半天还是不对。建议大家，不会就直接说不会，直接换题吧，可以节约下面试的时间。第二题，如果一个学校的学生，身高为随机变量X，那么其中一位同学的身高服从什么分布？（这个我也不太清楚，回答了根据中心极限定理，服从正态分布，不知道对不对）。老师，随后问，描述一下中心极限定理，我背了下教科书的定义，老师似乎没听懂，让我用更简单的语言讲一下，回答的不是很好。</p><p>第四部分，一般会根据你的成绩单和简历来问，如果你有优秀的论文和竞赛获奖的话，老师可能会问那方面，因为我没有，老师主要就是问的是成绩单。我是软件工程专业，请软件工程专业的同学一定好好复习软件工程，网上各个学校往年面试经验里有很多高频的问题（1.软件工程和计算机科学的区别 2.描述一下软件的开发的过程 3.常见的软件声明周期的模型，瀑布模型和快速原型的模型的区别在哪？）。</p><p>第一问，考的很高的课全都没问，直接问了考了最差的那门课，软件工程相关的那门课学了什么？</p><p>第二问，描述一下软件的开发的过程？</p><p>第三问，瀑布模型和快速原型（敏捷开发）的模型的区别在哪？</p><p>第四问，除了维护阶段，软件生命周期的哪个阶段耗时最长？我回答，开发阶段，老师说是维护阶段，并让我回去好好查资料。</p><p>然后换了一位老师，开始问语言相关。第一问，Java和C的区别。（网上有很多，不能只回答面向对象，还有内存管理机制等等）。第二问，Java中的拷贝是什么意思？（完全没懂，胡乱回答了一下，老师反问我，是吗）。最后一位老师，询问简历内容，问了做的一个项目，自己是如何做的（如果本科没有做过什么项目，可以贴上自己平时上课的课程设计的作业，如果github有不少star的话，也可以贴上自己的github）。</p><p>面试分为两批，分为两天进行。每个人应该是随机的，同一学校的学生一般在同一天。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面试结束之后，第二天公布入营名单。接着自己拿表，找愿意接收自己的老师签字。建议大家，如果简历比较优秀的话，在夏令营前提前联系好是最好的。如果，拿到入营资格后，再选老师的话，建议多群发。因为很多老师是不会回你邮件的。还有老师答应面试和联系你，结果你等了他几天的时间，他又突然不和你联系，或者告知你名额已经满了的现象也是非常常见的。所以，我建议一定要群发，老师3个小时不回邮件，估计是永远不会回你了。如果没有找到心仪的老师，可以提交空表。只要开学前，找到愿意接收你的老师都可以。但是，我觉得要小心，也有可能老师口头答应了你，却又突然反悔的现象。这还是挺常见的，大家还是多加注意。如果开学前没有找到老师，学院会为你进行分配，可能就不是你想继续读的方向了。所以，多报几个学校也是必要的，学校内换导师很难，但是换学校还是可以的。</p><h2 id="南大软院夏令营流程"><a href="#南大软院夏令营流程" class="headerlink" title="南大软院夏令营流程"></a>南大软院夏令营流程</h2><h3 id="大致情况-1"><a href="#大致情况-1" class="headerlink" title="大致情况"></a>大致情况</h3><p>今年，南大软院入营的人数非常多。有700多个人入营，第一轮机试筛选之后，还剩下180个人左右。一切消息通过QQ群通知，邮件中也强调要尽快联系导师。</p><h3 id="机试部分"><a href="#机试部分" class="headerlink" title="机试部分"></a>机试部分</h3><p>机试是采用南大的慕测平台，可以采用任意语言。机试时间为两个小时，五道题，一共500分。分几批参加测试，每个人的题目都不一样，题目的类型与leetcode类型相同。注意，每行答案输出末尾要加回车，不然会报presentation error。还有就是，今年线上考试，不允许使用本地IDE，只允许在南大开发的慕测平台上，在输入框内手敲代码。（没有自动补全，没有控制台输出，只会报提交的编译错误）。但是在提交代码之后，可以立即看到自己代码的得分。</p><p><img src="/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/%E6%88%AA%E5%B1%8F2020-11-20%2019.40.59.png" alt="截屏2020-11-20 19.41.12"></p><p><img src="/2020/11/20/2020%E5%8C%97%E8%88%AA%EF%BC%8C%E5%8D%97%E5%A4%A7%E8%BD%AF%E9%99%A2%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%89%80%E5%A4%8F%E4%BB%A4%E8%90%A5%EF%BC%8C%E5%8C%97%E9%82%AE%EF%BC%8C%E8%A5%BF%E4%BA%A4%E4%BA%BA%E6%9C%BA%E6%89%80%E9%A2%84%E6%8E%A8%E5%85%8D%E8%AE%B0%E5%BD%95/%E6%88%AA%E5%B1%8F2020-11-20%2019.41.12.png" alt="截屏2020-11-20 19.40.59"></p><h3 id="面试部分-1"><a href="#面试部分-1" class="headerlink" title="面试部分"></a>面试部分</h3><p>机试通过之后，将近一个多星期才出面试分组。也是每组形式不太一样，有的时间长，有的时间短。我的面试时间大概是5分钟，一个是英文自我介绍，再一个是老师会让你介绍一下你最熟悉的一个项目，并提一些简单的问题。</p><h3 id="老师选择"><a href="#老师选择" class="headerlink" title="老师选择"></a>老师选择</h3><p>南大软院的组比较少，在软院官网上可以看到，多数偏向开发方向。一般老师要求大四跟着进行毕设，研一研二出成果，研三会允许实习。适合想选择就业的同学。值得注意的是，今年南大专硕是不提供宿舍的。</p><h2 id="计算所vipl智信夏令营流程"><a href="#计算所vipl智信夏令营流程" class="headerlink" title="计算所vipl智信夏令营流程"></a>计算所vipl智信夏令营流程</h2><p>计算所联系老师还是比较重要的，老师和实验室决定的权力比较大。我只参加了智信实验室，竞争比较大。</p><h3 id="笔试加机试部分"><a href="#笔试加机试部分" class="headerlink" title="笔试加机试部分"></a>笔试加机试部分</h3><p>今年计算所进了非常多西电的学生，如果想去计算所的西电的同学，建议一定要好好复习线代，概率论，高等数学的知识，笔试会考。</p><p>我在vipl的笔试就没有通过，当时也没有保存题目。</p><p>数学基础知识 考试时间一小时，主要为基础的线性代数，概率论和高等数学的知识。</p><p>算法 考试时间30分钟。 涉及算法与分析部分课程内容，主要为基础算法，部分动态规划的内容，以及让你设计算法。</p><p>研究方法基础知识 30分钟 主要为计算机视觉方面的基础知识（虽然我都不太会，感兴趣的同学建议大三打好机器学习和视觉方面的知识）</p><p>综合能力测试 20分钟 主要为脑筋急转弯类，和找规律。比如说，移动一根火柴棒使得等式成立，给出一组数字，找出下一个数类似的。（这种网上可能会有不少，平时没训练过，当场纯靠灵感。）</p><p>下午为机试 考试时间1小时，可以选择python和纯C。C语言必须使用微软的VS作为IDE，不然不满足他的试题包。试题比较简单，分为两类题型。第一种程序填空，第二种是常见oj类型。</p><h3 id="北邮预推免"><a href="#北邮预推免" class="headerlink" title="北邮预推免"></a>北邮预推免</h3><p>北邮没有夏令营，在暑假的时候就可以自己联系北邮的老师，老师的权力比较大，之后每个组会自行组织面试。</p><p>我联系老师的时间比较迟，几乎保研快结束了。老师临时多出一个专硕名额联系了我。面试问题，介绍你自己。根据简历提问。然后询问是否有计算机类比赛或者获奖。然后是算法题考查，我是和老师一对一腾讯会议共享桌面的。考查了现场写二分查找元素，upper_bounder，由于很长时间没做算法题了，我没能一下子写出来。老师人比较好，给我很长的时间调试程序。</p><p>然后是，给出一篇英文paper的摘要，然后要求读一遍，之后翻译每一句话。一般是为老师相关方向的简单论文或者这方面比较经典的论文，并不是很难。需要对相关专业词汇有一定的熟悉。</p><p>最后询问你现在的保研状态如何，未来研究生的规划是怎么样的（感觉老师比较喜欢，自己有明确想干什么方向，然后要发论文的学生）。你为什么要读研？（我回答了，为了提升自己和锻炼自己的能力，感觉老师不是很满意。大家最好回答，对科研有浓厚的兴趣，一心想科研之类）。</p><h2 id="西交人工智能学院预推免"><a href="#西交人工智能学院预推免" class="headerlink" title="西交人工智能学院预推免"></a>西交人工智能学院预推免</h2><p>感觉西交人工智能学院比较重视title，初筛都是211往上。</p><p>西交人机所采取的是群面的机制，5，6个老师面5，6个学生。依次会让每一个人进行自我介绍，自我介绍的时候，老师会看你在网站上填写的简历信息。之后，老师会对简历中有兴趣点的进行提问。我那组有几个西交的学生，老师对自己的学生感兴趣的问题比较多。群面一定要多多展示自己，不要就说一点点话，该吹还是吹，并没有问技术细节的东西。</p><p>问了我，你的动手能力怎么样？我就说了一点，凉凉。</p><h2 id="哈工大深圳预推免"><a href="#哈工大深圳预推免" class="headerlink" title="哈工大深圳预推免"></a>哈工大深圳预推免</h2><p>我只参加了笔试部分，笔试考的范围很广。基本为选择题和判断题，有人考了一两个填空题。主要考察范围，离散数学，数据库，操作系统，计算机网络。题目可以自行搜索，我记得CSDN有人上传。</p><p>哈工大深圳对预推免举行了好几轮的笔试和面试，每一轮排在前面的同学有机会进入面试。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最后给大家推荐计算机保研交流群（605176069）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown_writer</title>
      <link href="/2020/09/09/markdown-writer/"/>
      <url>/2020/09/09/markdown-writer/</url>
      
        <content type="html"><![CDATA[<h2 id="这是二级标题，front-matter里的值为一级标题"><a href="#这是二级标题，front-matter里的值为一级标题" class="headerlink" title="这是二级标题，front matter里的值为一级标题"></a>这是二级标题，front matter里的值为一级标题</h2><p>这是正文部分，如果想换行的话在每行后面敲两个空格再按回车<br>这是换行</p><p>如何换段落呢？如在第10行和第12行之间敲回车，这是换段落<br>第12行后面没有按回车，显示的是不换行的格式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来<span class="emphasis">*这是斜体文字*</span>  </span><br></pre></td></tr></table></figure><p>接下来<em>这是斜体文字</em>  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来<span class="strong">**这是粗体文字**</span></span><br></pre></td></tr></table></figure><p>接下来<strong>这是粗体文字</strong></p><span id="more"></span><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来 <span class="emphasis">* <span class="strong">**这是斜粗体文字**</span> *</span></span><br></pre></td></tr></table></figure><p>接下来**<em>这是斜粗体文字**</em></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是~~删除线~~</span><br></pre></td></tr></table></figure><p>这是<del>删除线</del></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是==高亮==</span><br></pre></td></tr></table></figure><p>这是==高亮==</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是^上标^</span><br></pre></td></tr></table></figure><p>我是^上标^</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是~下标~  </span><br></pre></td></tr></table></figure><p>我是<del>下标</del>  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下划线采用html语法<span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>hhh(command+u)<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>下划线采用html语法<u>hhh(command+u)</u></p><h2 id="这也是二级标题"><a href="#这也是二级标题" class="headerlink" title="这也是二级标题"></a>这也是二级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采取&lt;!--more--&gt;来隐藏本文中剩下的内容</span><br></pre></td></tr></table></figure><h3 id="如何建立列表"><a href="#如何建立列表" class="headerlink" title="如何建立列表"></a>如何建立列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表1</span><br><span class="line"><span class="bullet">2.</span> 列表2</span><br><span class="line"><span class="bullet">3.</span> 列表3</span><br><span class="line"><span class="bullet">   1.</span> 层次3.1</span><br><span class="line"><span class="bullet">      1.</span> 层次3.1.1</span><br></pre></td></tr></table></figure><ol><li>列表1</li><li>列表2</li><li>列表3<ol><li>层次3.1<ol><li>层次3.1.1</li></ol></li></ol></li></ol><h3 id="如何建立不带数字的列表"><a href="#如何建立不带数字的列表" class="headerlink" title="如何建立不带数字的列表"></a>如何建立不带数字的列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 列表1</span><br><span class="line"><span class="bullet">*</span> 列表2</span><br><span class="line"><span class="bullet">*</span> 列表3</span><br></pre></td></tr></table></figure><ul><li>列表1</li><li>列表2</li><li>列表3</li></ul><h3 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">这是图片的替代文字</span>](<span class="link">markdown-writer/jienijieni.png &quot;这是图片的title&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/09/09/markdown-writer/jienijieni.png" alt="这是图片的替代文字" title="这是图片的title"></p><h3 id="如何进行latex公式的插入"><a href="#如何进行latex公式的插入" class="headerlink" title="如何进行latex公式的插入"></a>如何进行latex公式的插入</h3><p>快捷键command+m可以在文字中插入公式<br>快捷键command+两次m可以生成公式的段落，如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\lim<span class="emphasis">_&#123;x \to \infin&#125;\frac&#123; sin(x) &#125; &#123; x &#125; = 1</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>$$<br>\lim_{x \to \infin}\frac{ sin(x) } { x } = 1<br>$$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 小红 | 小明 | 小白 |</span><br><span class="line">| :---- | :----: | ----: |</span><br><span class="line">| a    | b    | c    |</span><br><span class="line">| e    | f    | g    |</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">小红</th><th align="center">小明</th><th align="right">小白</th></tr></thead><tbody><tr><td align="left">a</td><td align="center">b</td><td align="right">c</td></tr><tr><td align="left">e</td><td align="center">f</td><td align="right">g</td></tr></tbody></table><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接 [<span class="string">链接的描述，如百度</span>](<span class="link">www.baidu.com</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">www.baidu.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是一个链接 <a href="www.baidu.com">链接的描述，如百度</a></p><p>&lt;<a href="http://www.baidu.com&gt;/">www.baidu.com&gt;</a></p><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如一段C++语言代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一段注释</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是<span class="emphasis">*斜体*</span>文字</span><br></pre></td></tr></table></figure><p>这是一个代码块<code>abcd 这是代码块</code></p><p>hexo中应该也能运用tag plugin来实现代码的添加  </p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用段落"><a href="#引用段落" class="headerlink" title="引用段落"></a>引用段落</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一段引用</span></span><br><span class="line"><span class="quote">&gt; 22233344455</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一段引用<br>22233344455</p></blockquote><p>分隔线  </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure><hr><hr><hr>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2020/08/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/2020/08/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><hr><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
