<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"samulenzz.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="官方swift文档https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-programming-language&#x2F;aboutswift 自己不太熟的地方，做了一点总结 The Basic 使用let关键字声明常量，var来声明变量。   12let maximum &#x3D; 10  &#x2F;&#x2F; 常量var current &#x3D; 0  &#x2F;&#x2F; 变量  声">
<meta property="og:type" content="article">
<meta property="og:title" content="swift programming language笔记">
<meta property="og:url" content="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Sam&#39;s blog">
<meta property="og:description" content="官方swift文档https:&#x2F;&#x2F;docs.swift.org&#x2F;swift-book&#x2F;documentation&#x2F;the-swift-programming-language&#x2F;aboutswift 自己不太熟的地方，做了一点总结 The Basic 使用let关键字声明常量，var来声明变量。   12let maximum &#x3D; 10  &#x2F;&#x2F; 常量var current &#x3D; 0  &#x2F;&#x2F; 变量  声">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/multilineStringWhitespace_2x.png">
<meta property="article:published_time" content="2023-03-14T11:37:37.000Z">
<meta property="article:modified_time" content="2023-03-14T11:40:04.941Z">
<meta property="article:author" content="samule">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/multilineStringWhitespace_2x.png">

<link rel="canonical" href="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>swift programming language笔记 | Sam's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sam's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Keep learning. Keep coding.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/samulenzz" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/baobao.jpg">
      <meta itemprop="name" content="samule">
      <meta itemprop="description" content="记录一点学习轨迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sam's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          swift programming language笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-14 19:37:37 / 修改时间：19:40:04" itemprop="dateCreated datePublished" datetime="2023-03-14T19:37:37+08:00">2023-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>官方swift文档<a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutswift">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutswift</a></p>
<p>自己不太熟的地方，做了一点总结</p>
<h2 id="The-Basic"><a href="#The-Basic" class="headerlink" title="The Basic"></a>The Basic</h2><ul>
<li><p>使用<code>let</code>关键字声明常量，<code>var</code>来声明变量。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximum <span class="operator">=</span> <span class="number">10</span>  <span class="comment">// 常量</span></span><br><span class="line"><span class="keyword">var</span> current <span class="operator">=</span> <span class="number">0</span>  <span class="comment">// 变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明带上变量的类型，这篇文章里叫，<code>type annotations</code>。swift里面的变量名，通常是大写字母开头的。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure>

<p>  NOTE：在多数情况下不用写明类型，因为提供初值之后，编译器会自动推断，有点像C++的auto。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>打印<code>print(_:separator:terminator:)</code>有默认参数分离符，应该是空格吧，终止符换行，可以自己设置，想要同时打印string和变量的值，英文叫采取<code>string interpolation</code>的方式。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The current value of friendlyWelcome is Bonjour!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只有在一行写多句语句才需要写分号(semicolons)</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat <span class="operator">=</span> <span class="number">1</span>; <span class="built_in">print</span>(cat)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不需要显示声明常量和变量的类型，swift会自动做类型推断。</p>
</li>
<li><p>类型别名<code>typealias</code>，类似C里面的<code>typedef</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tuple类型和python类型，里面可以存放任意类型的变量，如下</p>
<p>  decompose操作和python 类似</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">// http404Error is of type (Int, String), and equals (404, &quot;Not Found&quot;)</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) <span class="operator">=</span> http404Error</span><br><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="keyword">_</span>) <span class="operator">=</span> http404Error</span><br></pre></td></tr></table></figure>

<p>  访问元组中元素的方式和C中不一样</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http404Error.<span class="number">0</span></span><br><span class="line">http404Error.<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  你可以在定义元组时，为元组中单个的元素命名。也可以通过元素名字取访问这些值。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http2000Status <span class="operator">=</span> (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">http2000Status.statusCode</span><br><span class="line">http2000Status.description</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>optional==类型==是swift==特性==。主要用于一个变量或者常量，有些值可能会缺失的情况。它有==两种状态==，一种是含有值，一种是不含有值。如<code>Int()</code>可以将String”123”转化为Int类型，但是不能将String”abc”转化为Int类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber is inferred to be of type &quot;Int?&quot;, or &quot;optional Int&quot;</span></span><br></pre></td></tr></table></figure>

<p>  <code>convertedNumber</code>类型为optional Int，也可以叫<code>Int?</code>。含义是，<code>convertNumber</code>可能包含一个<code>Int</code>类型的值，也有可能包含<code>no value</code>，不包含任何值。 (It can’t contain anything else, such as a <code>Bool</code> value or a <code>String</code> value. It’s either an <code>Int</code>, or it’s nothing at all.)</p>
<ul>
<li><p>可以给optional类型的变量赋no value，<code>nil</code></p>
<p>  定义了一个optinal Int型的变量，含有值404。我们也可以使他变为no vaule。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode contains an actual Int value of 404</span></span><br><span class="line">serverResponseCode <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode now contains no value</span></span><br></pre></td></tr></table></figure>

<p>  如果如定义，默认就是no value的</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer is automatically set to nil</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过与<code>nil</code>比较，判断optional内是否有值，通过<code>!</code>后缀强制取出（Forced Unwrapping）optinal类型变量的值（前提是要有值才取，不然会报错）</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;convertedNumber has an integer value of 123.&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>optional binding</p>
<p>  我觉得是利用<code>if</code>和<code>let</code>/<code>var</code>，将optional里的值暂时取出来，不使用上面描述的force unwrapping，也就是感叹号</p>
<p>  ==注意一下==，<code>actualNumber</code>是==局部变量==，只在if后的第一个大括号里有效。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The string <span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> has an integer value of <span class="subst">\(actualNumber)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The string <span class="subst">\&quot;</span><span class="subst">\(possibleNumber)</span><span class="subst">\&quot;</span> couldn&#x27;t be converted to an integer&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The string &quot;123&quot; has an integer value of 123&quot;</span></span><br></pre></td></tr></table></figure>

<p>  其实下面这个例子，更好的说明了optional binding</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber <span class="operator">=</span> <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// Here, myNumber is an optional integer</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myNumber <span class="operator">=</span> myNumber &#123;</span><br><span class="line">    <span class="comment">// Here, myNumber is a non-optional integer</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My number is <span class="subst">\(myNumber)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;My number is 123&quot;</span></span><br></pre></td></tr></table></figure>

<p>  第一行<code>myNumber</code>的类型为<code>Int?</code>，第三行的同名<code>myNumber</code>在if的作用域里的不是optional类型，就是常规的constant类型。</p>
<p>  由于经常取同名在if里覆盖上一级变量，所以有了更简化的写法。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> myNumber &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My number is <span class="subst">\(myNumber)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;My number is 123&quot;</span></span><br></pre></td></tr></table></figure>

<p>  可以同时写多个optional bindings，但是只有一个不含有值，则整个if语句判断为false。==这里不写&amp;&amp;，写逗号<code>,</code>==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Implicitly Unwrapped Optionals</p>
<p>  上文介绍了两种打开optional类型变量里的值，一种，使用<code>!</code>；第二种，使用optional binding</p>
<p>  Implicitly Unwrapped Optionals适用于，一个变量在第一次设置了值后，就一直有值了（其实没有太理解），这样就不用判断是不是<code>nil</code>了</p>
<p>  使用类似<code>Int!</code>来定义此种类型，如下</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;An optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> <span class="operator">=</span> possibleString<span class="operator">!</span> <span class="comment">// requires an exclamation point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> <span class="operator">=</span> assumedString <span class="comment">// no need for an exclamation point</span></span><br></pre></td></tr></table></figure>

<p>  一个理解，对于<code>implicitly unwrapped optional</code>类型，编译器首先会使用基础optional类型来进行尝试，如果尝试失败，则会将optional里面的值取出来使用。如下</p>
<p>  <code>optionalString</code>的类型是<code>String？</code>，而<code>implicitString</code>的类型是显示声明的<code>String</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalString <span class="operator">=</span> assumedString</span><br><span class="line"><span class="comment">// The type of optionalString is &quot;String?&quot; and assumedString isn&#x27;t force-unwrapped.</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>assertion和precondition</p>
<p>  和C中使用一样</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;age need larger than 0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">precondition</span>(index <span class="operator">&gt;</span> <span class="number">0</span>, <span class="string">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>  区别assert只在<code>debug buliding</code>中有效，precondition在<code>debug</code>和<code>production</code>中都有效。</p>
</li>
</ul>
<ul>
<li><p>error handing</p>
<p>  我们用<code>throw</code>关键字定义一个可能会抛出错误的函数</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">canThrowAnError</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在执行这个函数时，我们要把他包裹在do-catch里，并加上<code>try</code>关键字</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们看一个例子吧</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeASandwich</span>() <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.outOfCleanDishes &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.missingIngredients(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  函数<code>makeASandwich()</code>可能会抛出错误，如果不排除错误，就可以执行之后的语句<code>eatASangwich()</code>。如果抛出错误，看与catch语句中哪一个错误匹配，哪一个错误匹配就执行catch花括号里的语句。</p>
</li>
</ul>
<h2 id="Basic-Operators"><a href="#Basic-Operators" class="headerlink" title="Basic Operators"></a>Basic Operators</h2><ul>
<li><p>tuple也能进行比较，从左到右进行比较，只要但凡有一个有比较结果，就出结果（对于不等号），其实C++里的vector也是能比较的</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; aren&#x27;t compared</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) <span class="operator">&lt;</span> (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) <span class="operator">==</span> (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.</p>
<p>想在tuple中比较超过7个元素，需要自己重载运算符</p>
</blockquote>
</li>
<li><p>Range operator</p>
<p>  <code>a...b</code>意味着<code>[a, b]</code>；<code>a..&lt;b</code>意味着<code>[a, b)</code></p>
<p>  <code>names[2...]</code>,<code>names[..&lt;2]</code>忽略一侧的写法，有一点像python</p>
</li>
</ul>
<ul>
<li><p>Nil-coalescing operator(<code>a ?? b</code>)</p>
<blockquote>
<p>The <em>nil-coalescing operator</em> (<code>a ?? b</code>) unwraps an optional <code>a</code> if it contains a value, or returns a default value <code>b</code> if <code>a</code> is <code>nil</code>. The expression <code>a</code> is always of an optional type. The expression <code>b</code> must match the type that’s stored inside <code>a</code>.</p>
</blockquote>
<p>  <code>a ?? b</code>用于<code>a</code>是一个optional 类型，b是对应类型的一个值，如果a这个变量里面非空有值，则取a里面的值，如果是nil，则取b的值。（注意b的值的类型要和a的对应的类型对应）相当于</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> a<span class="operator">!</span> : b</span><br></pre></td></tr></table></figure>

<p>  举例，userDefinedColorName是nil，所以取了defaultColorName的值red</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName is nil, so colorNameToUse is set to the default of &quot;red&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Strings-and-Characters"><a href="#Strings-and-Characters" class="headerlink" title="Strings and Characters"></a>Strings and Characters</h2><ul>
<li><p>跨越多行的String字面量</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;  // 下一行为开始</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span></span><br><span class="line"><span class="string">please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span></span><br><span class="line"><span class="string">till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>  <span class="comment">// 上一行为结束</span></span><br></pre></td></tr></table></figure>

<p>  底下两个是相同的，也就是说是没有换行符的</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleLineString <span class="operator">=</span> <span class="string">&quot;These are the same.&quot;</span></span><br><span class="line"><span class="keyword">let</span> multilineString <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">These are the same.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当你在string中因为一行内容过长而要换行，但是不想输出换行符，可以使用bcakslash(\)，这样2,3行在输出中就是为一行内容</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> softWrappedQuotation <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">The White Rabbit put on his spectacles.  &quot;Where shall I begin, <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>please your Majesty?&quot; he asked.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on <span class="subst">\</span></span></span><br><span class="line"><span class="subst"><span class="string"></span>till you come to the end; then stop.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于多行字面量的缩进，最后的多引号之前的indent，在每一行中都会被忽略，之后的才会记录，如下图所示</p>
<p>  <img src="/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/multilineStringWhitespace_2x.png" alt="../_images/multilineStringWhitespace_2x.png"></p>
</li>
</ul>
<ul>
<li><p>初始化空字符串</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString <span class="operator">=</span> <span class="string">&quot;&quot;</span>               <span class="comment">// empty string literal</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString <span class="operator">=</span> <span class="type">String</span>()  <span class="comment">// initializer syntax</span></span><br><span class="line"><span class="comment">// these two strings are both empty, and are equivalent to each other</span></span><br></pre></td></tr></table></figure>

<p>  通过属性<code>isEmpty</code>判断字符串是否为空</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Nothing to see here&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Nothing to see here&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String type is a <code>value types</code>。对于这段话的理解是，在函数里，对字符串的传递是传值传递，也就是拷贝值，会传递一个新的版本，修改它并不会影像原来的字符串。编译器会保证在</p>
</li>
<li><p>与python类似，用<code>for-in</code>访问字符串中的每一个元素。</p>
<p>  可以通过<code>String()</code>将array数组转化为String，将<code>Character</code>数组传递给初始化器，==有没有发现Character，他也是用双引号初始化的==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] <span class="operator">=</span> [<span class="string">&quot;C&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;🐱&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> catString <span class="operator">=</span> <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// Prints &quot;Cat!🐱&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串String通过加号+连接新的字符串，通过<code>append()</code>添加字符<code>Character</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome now equals &quot;hello there!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用属性<code>count</code>计算String中字符的个数，但是由于String支持unicode编码的，所以String中添加了东西，仍然有可能字符个数未改变，如下：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word <span class="operator">=</span> <span class="string">&quot;cafe&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in cafe is 4&quot;</span></span><br><span class="line"></span><br><span class="line">word <span class="operator">+=</span> <span class="string">&quot;<span class="subst">\u&#123;301&#125;</span>&quot;</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.count)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the number of characters in café is 4&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Each <code>String</code> value has an associated <em>index type</em>, <code>String.Index</code>, which corresponds to the position of each <code>Character</code> in the string.</p>
</li>
<li><p>==因为String对于每一个Character的存储空间不同，所以String不能通过下标来访问。==通过属性，或者<code>index()</code>来访问</p>
<p>  <code>startIndex</code>属性对应String的第一个位置，<code>endIndex</code>属性对应String最后一个位置的下一个，和其他语言类似，还是左闭右开的。<code>offsetBy</code>的用法，注意是不包括当前的位置，数n个。==通过offsetBy可以实现类似的下标访问。==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Guten Tag!&quot;</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="number">7</span>)</span><br><span class="line">greeting[index]  <span class="comment">// 这里相当于greeting[7]</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<p>  Use the <code>indices</code> property to access all of the indices of individual characters in a string.但是我感觉，既然这么做了，为什么不用for-in来访问每一个元素呢？</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.indices &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;G u t e n   T a g ! &quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入和删除，用的时候再查吧，感觉用的时候很少</p>
</li>
<li><p>子串（<code>Substring</code>）有自己独特的type.子串类型一般用于临时使用，当准备长期存储结果时，需要将子串转化为String类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">let</span> index <span class="operator">=</span> greeting.firstIndex(of: <span class="string">&quot;,&quot;</span>) <span class="operator">??</span> greeting.endIndex</span><br><span class="line"><span class="keyword">let</span> beginning <span class="operator">=</span> greeting[<span class="operator">..&lt;</span>index]</span><br><span class="line"><span class="comment">// beginning is &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert the result to a String for long-term storage.</span></span><br><span class="line"><span class="keyword">let</span> newString <span class="operator">=</span> <span class="type">String</span>(beginning)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断字符串是否有相关前缀或者后缀<code>hasPrefix(), hasSuffix()</code>，返回Boolean类型</p>
</li>
</ul>
<h2 id="Collection-Types"><a href="#Collection-Types" class="headerlink" title="Collection Types"></a>Collection Types</h2><p>三种类型，数组，集合，字典</p>
<ul>
<li><p>数组的类型为<code>Array&lt;Int&gt;</code>，也可以速记为<code>[Int]</code>。==这里和C还是一样的，数组里只允许有一种类型==</p>
<p>  创建一个空数组，<strong>创建空数组时，需要显式声明变量类型，如[Int]</strong></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts: [<span class="type">Int</span>] <span class="operator">=</span> []</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInts is of type [Int] with <span class="subst">\(someInts.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInts is of type [Int] with 0 items.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  使用<code>append()</code>添加元素</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>  也可以初始化有重复元素的数组</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>

<p>  可以和python一样，使用<code>+</code>连接两个列表</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br></pre></td></tr></table></figure>

<p>  可以使用常数字面量初始化数组</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br><span class="line"><span class="comment">// 由于自动推断</span></span><br><span class="line"><span class="keyword">var</span> shoppingList <span class="operator">=</span> [<span class="string">&quot;Eggs&quot;</span>, <span class="string">&quot;Milk&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>  如果切片和替换的数组字面量长度不一致，仍然可以进行替换</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shop[<span class="number">4</span><span class="operator">...</span><span class="number">6</span>] <span class="operator">=</span> [<span class="string">&quot;bananas&quot;</span>, <span class="string">&quot;apples&quot;</span>]  <span class="comment">// 左边长度为3，右边长度为2</span></span><br></pre></td></tr></table></figure>

<p>  <code>insert</code>和<code>remove</code>，与String类似</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">&quot;Maple Syrup&quot;</span>, at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList now contains 7 items</span></span><br><span class="line"><span class="comment">// &quot;Maple Syrup&quot; is now the first item in the list</span></span><br></pre></td></tr></table></figure>

<p>  删除函数会返回被删除的那个值</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup <span class="operator">=</span> shoppingList.remove(at: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// the item that was at index 0 has just been removed</span></span><br><span class="line"><span class="comment">// shoppingList now contains 6 items, and no Maple Syrup</span></span><br><span class="line"><span class="comment">// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string</span></span><br></pre></td></tr></table></figure>

<p>  <code>enumerated()</code>方法和python类似</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Item <span class="subst">\(index <span class="operator">+</span> <span class="number">1</span>)</span>: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>字典，这里也与python不一样，key要求同一类型，value要求同一类型（这里有点像C++的unordered_map）。同样的，键是不能重复的。</p>
<p>  字典类型为<code>Dictinary&lt;type1, type2&gt;</code>，可以简写为<code>[type1: type2]</code>。</p>
<p>  创建一个空字典</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers: [<span class="type">Int</span>: <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"><span class="comment">// namesOfIntegers is an empty [Int: String] dictionary</span></span><br></pre></td></tr></table></figure>

<p>  使用字典字面量，创建字典</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] <span class="operator">=</span> [<span class="string">&quot;YYZ&quot;</span>: <span class="string">&quot;Toronto Pearson&quot;</span>, <span class="string">&quot;DUB&quot;</span>: <span class="string">&quot;Dublin&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>  可以直接使用下标更新值，也可以使用方法<code>updateValue(_:forKey:)</code>如果字典含有某个键，则更新他的值。如果没有那个键，则创建。实际上和通过下标访问的做法是一样的，但是这个方法会返回一个optional类型，也就是老的值，如果没有老的值，就返回nil</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue <span class="operator">=</span> airports.updateValue(<span class="string">&quot;Dublin Airport&quot;</span>, forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The old value for DUB was <span class="subst">\(oldValue)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The old value for DUB was Dublin.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  对于某个键，字典中可能会不存在，这样会返回optinal类型。==其实直接访问airport[“DUB”]，不管存不存在这个键，都是返回的optional类型==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName <span class="operator">=</span> airports[<span class="string">&quot;DUB&quot;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The name of the airport is <span class="subst">\(airportName)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That airport isn&#x27;t in the airports dictionary.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The name of the airport is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  移除值的两种方法</p>
<ol>
<li><p>设置值为<code>nil</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="string">&quot;Apple International&quot;</span></span><br><span class="line"><span class="comment">// &quot;Apple International&quot; isn&#x27;t the real airport for APL, so delete it</span></span><br><span class="line">airports[<span class="string">&quot;APL&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL has now been removed from the dictionary</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>removeValue(forKey:)</code>，利用键的值移除键值对，如果存在的话，返回移除的value，如果不存在的话，返回<code>nil</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue <span class="operator">=</span> airports.removeValue(forKey: <span class="string">&quot;DUB&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The removed airport&#x27;s name is <span class="subst">\(removedValue)</span>.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The airports dictionary doesn&#x27;t contain a value for DUB.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The removed airport&#x27;s name is Dublin Airport.&quot;</span></span><br></pre></td></tr></table></figure>

<p>迭代字典的方法也和python类似，同时迭代键-值对，==其中airportCode, airportName是常量==</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br></pre></td></tr></table></figure>

<p>利用属性<code>keys</code>或<code>values</code>迭代</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport code: <span class="subst">\(airportCode)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Airport name: <span class="subst">\(airportName)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br></pre></td></tr></table></figure>

<p>还可以将<code>d.keys</code>转化为array，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes <span class="operator">=</span> [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes is [&quot;LHR&quot;, &quot;YYZ&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames <span class="operator">=</span> [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames is [&quot;London Heathrow&quot;, &quot;Toronto Pearson&quot;]</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ul>
<li><p>set</p>
<p>  集合中的数据或者字典的key值，必须满足<code>hashable</code>。swift中的基础类型，比如String,Int,Double,Bool都是可哈希的，除此之外</p>
<p>  Enumeration case values without associated values are also hashable by default.</p>
<p>  当然你也使用你自己定义的类型作为集合的数据或者字典key的值，只需要他满足<code>Hashable</code>协议。</p>
<p>  建立空的集合</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.count)</span> items.&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  使用<code>insert</code>插入数据，注意，再次把letters变空时，它仍然是Set&lt;Character&gt;类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">// letters now contains 1 value of type Character</span></span><br><span class="line">letters <span class="operator">=</span> []</span><br><span class="line"><span class="comment">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span></span><br></pre></td></tr></table></figure>

<p>  使用数组字面量来创建集合</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="operator">=</span> [<span class="string">&quot;Rock&quot;</span>, <span class="string">&quot;Classical&quot;</span>, <span class="string">&quot;Hip hop&quot;</span>]</span><br><span class="line"><span class="comment">// favoriteGenres has been initialized with three initial items</span></span><br></pre></td></tr></table></figure>

<p>  使用<code>remove()</code>来删除set中的元素，当然和字典一样，返回的是optional</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre <span class="operator">=</span> favoriteGenres.remove(<span class="string">&quot;Rock&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(removedGenre)</span>? I&#x27;m over it.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I never much cared for that.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Rock? I&#x27;m over it.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  使用<code>contains()</code>判断是否包含某个元素</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.contains(<span class="string">&quot;Funk&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I get up on the good foot.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s too funky in here.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;It&#x27;s too funky in here.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  做集合操作略</p>
</li>
</ul>
<h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><ul>
<li><p>类似python中，有步长的range范围</p>
<p>  半开半闭[0, 60)，步长为5</p>
<p>  <code>stride(from: 开始,to: 结束, by: 步长)</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minuteInterval <span class="operator">=</span> <span class="number">5</span>, minutes <span class="operator">=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: minutes, by: minuteInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 5 minutes (0, 5, 10, 15 ... 45, 50, 55)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  全闭</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hours <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> hourInterval <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> tickMark <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">3</span>, through: hours, by: hourInterval) &#123;</span><br><span class="line">    <span class="comment">// render the tick mark every 3 hours (3, 6, 9, 12)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>switch</p>
<p>  这里和C有点不一样，没有break。与C中不同的是，Swift并没有implicit fallthrough，==只要找到第一个匹配的case，就跳出去==</p>
<p>  Every <code>switch</code> statement must be <em>exhaustive</em>，也就是说必须在case里找到一个可以<em>匹配</em>的选项，如果没有任何一种情况匹配，就会报错。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;z&quot;</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The first letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;z&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The last letter of the alphabet&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Some other character&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The last letter of the alphabet&quot;</span></span><br></pre></td></tr></table></figure>

<p>  case中必须至少包含一条可以执行的语句，下面的例子，<code>case:&quot;a&quot;</code>中没有执行语句，然而我们选择的又是<code>a</code>。按上述两条，也就是必须匹配，而且case中必须有执行语句。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>: <span class="comment">// Invalid, the case has an empty body</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This will report a compile-time error.</span></span><br></pre></td></tr></table></figure>

<p>  case中可以判断多种情况（多个值），用逗号分隔，满足其中一种即可</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;A&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The letter A&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Not the letter A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;The letter A&quot;</span></span><br></pre></td></tr></table></figure>

<p>  switch中还有一些独有特性，大致看了一下，感觉很少用switch</p>
<p>  通过<code>fallthrough</code>强制<code>switch</code>在匹配继续往下匹配一个？(<strong>fallthrough只是强制继续往下看一个，不管是否匹配，比如这里只看到了default，如果case 2,3… 之后有一个case 20，他仍然会执行case20的代码</strong>)。不知道这样写法的意义何在？</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// Prints &quot;The number 5 is a prime number, and also an integer.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  switch的值绑定，使用临时的常量或者变量来绑定对应的值。临时在于，只在这个case的作用域内有效。这个值绑定，还是和enum的值绑定很像的，那个也是通过switch</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;on the x-axis with an x value of 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>  switch中还可以使用where来进行匹配，感觉也是挺少见的，见例子</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;(1, -1) is on the line x == -y&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>这里取的标题是early exit</p>
<p>  像 <code>if</code> 语句一样，<code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 从句，如果条件不为真则执行 <code>else</code> 从句中的代码。</p>
<p>  <code>guard</code>作用和if类似，不同的地方是，1, 他一定要跟else，而且else中需要return 或者 throw(必须使用在函数内部？) 2, 作用域问题。if条件中定义的变量只能花括号里使用，guard在花括号之外还能使用，如下面的打印</p>
<blockquote>
<p>Any variables or constants that were assigned values using an optional binding as part of the condition are available for the rest of the code block that the <code>guard</code> statement appears in.</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: [<span class="params">String</span>: <span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> person[<span class="string">&quot;name&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location <span class="operator">=</span> person[<span class="string">&quot;location&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice near you.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice in <span class="subst">\(location)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>])</span><br><span class="line"><span class="comment">// Prints &quot;Hello John!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;I hope the weather is nice near you.&quot;</span></span><br><span class="line">greet(person: [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;location&quot;</span>: <span class="string">&quot;Cupertino&quot;</span>])</span><br><span class="line"><span class="comment">// Prints &quot;Hello Jane!&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;I hope the weather is nice in Cupertino.&quot;</span></span><br></pre></td></tr></table></figure>

<p>  如果 <code>guard</code> 语句的条件被满足，则继续执行 <code>guard</code> 语句大括号后的代码。将变量或者常量的可选绑定作为 <code>guard</code>语句的条件，都可以保护 <code>guard</code> 语句后面的代码。</p>
</li>
</ul>
<ul>
<li><p>检查API可用性</p>
<p>  有点不太理解。感觉就是一个if或者guard语句，判断当前版本是否能调用这个API。</p>
</li>
</ul>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>Every function in Swift has a type, consisting of the function’s parameter types and return type. You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions. </p>
<p>每一个函数都有一个type，由参数的类型和返回类型组成。你可以把他当做swift中的任意其他类型，这样方便了函数作为一个参数传递，或者作为返回值返回</p>
<p><em>形参是parameter</em>，实参是argument</p>
<ul>
<li><p>定义函数</p>
<p>  参数类型String，返回类型String</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ==调用函数的时候，必须写明label person，不然报错==，也就是说<code>greet(person: &quot;Sam&quot;)</code>，person不能省略</p>
</li>
<li><p>两个函数变量名相同，但是参数返回类型不同，编译器还是可以区分的。这是多态？忘了</p>
</li>
<li><p>使用tuple来返回多个值，不同的是，返回的多个值，可以带上label（==也可以不取名字和其他返回类型一样，直接写<code>(Int, Int)</code>==），方便后续的访问。和之前第一章定义tuple的内容类似，在这里<code>bounds</code>是一个tuple。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bounds <span class="operator">=</span> minMax(array: [<span class="number">8</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min is <span class="subst">\(bounds.min)</span> and max is <span class="subst">\(bounds.max)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;min is -6 and max is 109&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回optional tuple类型，有可能返回tuple，也有可能返回nil，如</p>
<p>  <code>(Int, Int)?</code></p>
<blockquote>
<p>(Int, Int)?的意思就是我上面说的，有可能返回tuple，也有可能返回nil</p>
<p>(Int?, Int?)的意思不同，这是两个单独的值</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">minMax</span>(<span class="params">array</span>: [<span class="type">Int</span>]) -&gt; (min: <span class="type">Int</span>, max: <span class="type">Int</span>)<span class="operator">?</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span><span class="operator">..&lt;</span>array.count] &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">&lt;</span> currentMin &#123;</span><br><span class="line">            currentMin <span class="operator">=</span> value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value <span class="operator">&gt;</span> currentMax &#123;</span><br><span class="line">            currentMax <span class="operator">=</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式返回值，这个要求整个函数体只有一行，这个也太少见了吧</p>
</li>
<li><p>The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label.</p>
<p>  很奇怪的做法，每个函数都有<code>argument label</code>实参的标注，在调用函数的时候，必须注明label。每个函数还有<code>parameter name</code>形参的名字，用于在函数体内实现相关行为。通常情况下，形参使用名字作为对应的label</p>
<p>  这一点比较有意思，不明白意义在哪里。每一个函数的参数，有<code>argument label</code>和<code>parameter name</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">argumentLabel</span> <span class="params">parameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// In the function body, parameterName refers to the argument value</span></span><br><span class="line">    <span class="comment">// for that parameter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>argument label</code>用在Call这个函数，<code>parameter name</code>用在函数内部。默认情况下，<code>argument label</code>被<code>parameter name</code>代替</p>
</li>
<li><p>我们可以用下划线来忽略<code>argument label</code>，==这样在调用函数时，就不用写label名字啦==，如下：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="keyword">_</span> <span class="params">firstParameterName</span>: <span class="type">Int</span>, <span class="params">secondParameterName</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// In the function body, firstParameterName and secondParameterName</span></span><br><span class="line">    <span class="comment">// refer to the argument values for the first and second parameters.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>默认参数值(Default Parameter Values)</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>(<span class="params">parameterWithoutDefault</span>: <span class="type">Int</span>, <span class="params">parameterWithDefault</span>: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="comment">// If you omit the second argument when calling this function, then</span></span><br><span class="line">    <span class="comment">// the value of parameterWithDefault is 12 inside the function body.</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">3</span>, parameterWithDefault: <span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></span><br><span class="line">someFunction(parameterWithoutDefault: <span class="number">4</span>) <span class="comment">// parameterWithDefault is 12</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>可变形参(variadic parameters)，用<code>Int...</code>表示，输入的多个值，被作为constant的Array传入</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">arithmeticMean</span>(<span class="keyword">_</span> <span class="params">numbers</span>: <span class="type">Double</span>...) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total <span class="operator">/</span> <span class="type">Double</span>(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>==注意点==，在这里十分傻逼的是，函数的参数是==常数类型==，不能再body里面改变</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">change</span>(<span class="params">a</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    a <span class="operator">=</span> <span class="number">36</span>  <span class="comment">// 报错</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">change(a: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>  如果你想改变值（==这里同时改变了传入的实参的值，这样我们的实参只能是变量，不能是常量和字面量==），在类型前面加上<code>inout</code>，如交换两个数的值</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  而且只能传入可以修改的变量，传入时候还要加上<code>&amp;</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span></span><br></pre></td></tr></table></figure>

<p>  这像指针又不像，像引用又不像。<strong>而且，如果我们想要不修改外部的变量，就不能用inout了，把形参强制设置为常数真的很傻</strong></p>
</li>
<li><p>函数类型</p>
<p>  函数类型由参数的类型和返回的类型所决定：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">addTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">multiplyTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">*</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这两个函数的类型都为<code>(Int, Int) -&gt; Int</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printHelloWorld</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这个函数类型为<code>() -&gt; Void</code></p>
</li>
<li><p>==注意==函数类型和其他任何类型，在swift中都一样的使用，你可以用它来定义变量，并assgin一个合适的函数。==那也可以理解成，其实函数也是一个变量？赋给另一个变量，相当于别名？==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> addTwoInts</span><br></pre></td></tr></table></figure>

<p>  你可以用它来调用函数</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 5&quot;</span></span><br></pre></td></tr></table></figure>

<p>  还可以用其他函数来改变它的值，并且调用</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction <span class="operator">=</span> multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>))</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 6&quot;</span></span><br></pre></td></tr></table></figure>

<p>  ==当然，和其他变量一样，你可以让swift自己去推断变量的类型==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction <span class="operator">=</span> addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型还可以用作参数的类型（？？？说实话，不是很理解这样的用途</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printMathResult</span>(<span class="keyword">_</span> <span class="params">mathFunction</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Result: <span class="subst">\(mathFunction(a, b))</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Result: 8&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型还能作为返回类型</p>
<p>  首先定义两个函数</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  将<code>(Int)-&gt;Int</code>作为返回类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套函数(nested function)，在函数里嵌套定义函数，他的作用域只在花括号里有效</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepForward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stepBackward</span>(<span class="params">input</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>之前没看懂，开头的话跳过了。</p>
<p>全局和嵌套函数也是一种特殊的闭包。</p>
<blockquote>
<p>全局函数是一个有名字但不会捕获任何值的闭包</p>
<p>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</p>
<p>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</p>
</blockquote>
<p>应该和lambda函数类似</p>
<p>以<code>sorted</code>函数举例子，这个和C++里的库函数差不多，需要接收一个函数返回布尔值来帮助排序。常规方法，构造一个普通的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames is equal to [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure>

<p>这样写有点复杂，闭包的格式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序函数中传入闭包</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>==注意这种写法，其实和函数的写法是相似的==。同样拥有<code>(s1: String, s2: String) -&gt; Bool</code>，只不过写在了花括号里面，而且没有了名字，多了<code>in</code></p>
<blockquote>
<p>The start of the closure’s body is introduced by the <code>in</code> keyword. This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.</p>
</blockquote>
<p><code>in</code>意味着参数和返回类型已经结束，函数体开始了。</p>
<ul>
<li><p>推断闭包中参数的返回值的类型，让编译器自己推断，所以去掉了参数两侧的括号，以及返回类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>

<blockquote>
<p>It’s always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument.</p>
</blockquote>
<p>  ==？当一个闭包被用作函数或者方法的实参时，不需要写完整的定义，如参数类型，返回值，只需像上面那么写就行==</p>
</li>
<li><p>==只有单句表达式==的闭包，可以隐式蕴含了<code>return</code>语句。相比上面去掉参数和返回类型，这里进一步去掉了<code>return</code>关键字</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以进一步简化，去掉整个参数列表和<code>in</code>，<strong>只有这种简化写法的时候，可以去掉参数列表</strong></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure>
</li>
<li><p>更进一步简化</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>尾部闭包</p>
<p>  <strong>感觉主要两个点，第一个尾闭包可忽略label，作为唯一参数时可以忽略括号</strong></p>
<p>  函数参数可以接受函数类型，当闭包作为<del>最后一个</del>英文是last参数（其实，好像是后面的就可以）传递时，可以用尾部闭包。写在函数调用的括号之外。一次函数调用，可以包含多个尾部闭包，第一尾部闭包可以不写argument label？</p>
<blockquote>
<p>If you need to pass a closure expression to a function as the function’s <strong>final</strong> argument and the closure expression is long, it can be useful to write it as a <em>trailing closure</em> instead. You write a trailing closure <strong>after the function call’s parentheses</strong>, even though the trailing closure is still an argument to the function. When you use the trailing closure syntax, you <strong>don’t write the argument label for the first closure</strong> as part of the function call. A function call can include multiple trailing closures; however, the first few examples below use a single trailing closure.</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数，参数类型为函数类型</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用该函数</span></span><br><span class="line"><span class="comment">// Here&#x27;s how you call this function without using a trailing closure:</span></span><br><span class="line"><span class="comment">// 这是常规闭包调用的方法</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// closure&#x27;s body goes here</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用尾部闭包的方式调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// trailing closure&#x27;s body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  上文中的排序就可以用尾部闭包来写</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>  如果闭包表达式作为函数的==唯一参数==，而且写作尾部闭包时，==可以把函数调用的括号去掉==。其实不唯一的也去了括号，如lec2里的button。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>  尾闭包用在Array类型的方法<code>map(_:)</code>里，自己看吧，不想理了。（主要内容就是作为唯一参数的尾部闭包，去掉了括号，调用写在外部）相当于，实现了对数组中的某一个对象做的操作，但是调用时会对每一个对象按顺序做一遍操作。<strong>这里有意思的一点是，和上文中的说法不同，闭包作为函数的参数时，不用写全完整的形式，但是这里删掉返回值类型，报错，不能推断</strong></p>
<p>  可以写多个尾部闭包，但是==第一个尾部闭包的label可以省略不写==，再注意一下函数调用时，括号里的参数列表。</p>
<p>  如下，这个函数，最后两个参数是函数类型，可以传入尾部闭包</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">loadPicture</span>(<span class="params">from</span> <span class="params">server</span>: <span class="type">Server</span>, <span class="params">completion</span>: (<span class="type">Picture</span>) -&gt; <span class="type">Void</span>, <span class="params">onFailure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> picture <span class="operator">=</span> download(<span class="string">&quot;photo.jpg&quot;</span>, from: server) &#123;</span><br><span class="line">        completion(picture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onFailure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  调用该函数，==第二个label还是要写的==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadPicture(from: someServer) &#123; picture <span class="keyword">in</span></span><br><span class="line">    someView.currentPicture <span class="operator">=</span> picture</span><br><span class="line">&#125; onFailure: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Couldn&#x27;t download the next picture.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li><p>值捕获 capturing values</p>
<p>  感觉有点复杂，这里是以嵌套函数的捕获为例子的。</p>
<blockquote>
<p>A closure can <em>capture</em> constants and variables from the surrounding context in which it’s defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</p>
</blockquote>
<p>  闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>  嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。看下面的例子吧</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">makeIncrementer</span>(<span class="params">forIncrement</span> <span class="params">amount</span>: <span class="type">Int</span>) -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">incrementer</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal <span class="operator">+=</span> amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  嵌套函数 <code>incrementer()</code> 从上下文中捕获了两个值，定义在外面这个函数作用域里的变量<code>runningTotal</code> 和 外面函数的形参<code>amount</code>。</p>
<blockquote>
<p> It does this by capturing a <em>reference</em> to <code>runningTotal</code> and <code>amount</code> from the surrounding function and using them within its own function body. Capturing by reference ensures that <code>runningTotal</code> and <code>amount</code>don’t disappear when the call to <code>makeIncrementer</code> ends, and also ensures that <code>runningTotal</code> is available the next time the <code>incrementer</code> function is called.</p>
</blockquote>
<p>  这是因为它从外围函数捕获了 <code>runningTotal</code> 和 <code>amount</code> 变量的==引用==。捕获引用保证了 <code>runningTotal</code> 和 <code>amount</code> 变量在调用完 <code>makeIncrementer</code> 后不会消失，并且保证了在下一次执行 <code>incrementer</code> 函数时，<code>runningTotal</code> 依旧存在。</p>
<p>  例子，重要</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure>

<p>  每次调用这个函数，<code>runningTotal</code>的值都会增加，并不是每次都初始化为0！这和C里面有很多的差别。</p>
<p>  如果你创建了另一个 <code>incrementer</code>，它会有属于自己的引用，指向一个全新、独立的 <code>runningTotal</code> 变量：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven <span class="operator">=</span> makeIncrementer(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure>

<p>  再次调用原来的 <code>incrementByTen</code> 会继续增加它自己的 <code>runningTotal</code> 变量，该变量和 <code>incrementBySeven</code> 中捕获的变量没有任何联系：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>闭包是引用类型，感觉这一点和说的class类似</p>
<p>  上面的例子中，<code>incrementBySeven</code> 和 <code>incrementByTen</code> 都是==常量==，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p>
<p>  无论你将函数或闭包赋值给一个常量还是变量，你实际上都是将常量或变量的值设置为对应函数或闭包的<em>引用</em>。上面的例子中，指向闭包的引用 <code>incrementByTen</code> 是一个常量，而并非闭包内容本身。</p>
<p>  这也意味着如果你将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen <span class="operator">=</span> incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50,值继续增加</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>逃逸闭包看不懂</p>
<p>  一个闭包作为实参传递给函数，但是要在函数返回之后才调用这个闭包，称为这个闭包逃逸了。如果你允许一个闭包逃逸，在写函数的参数时，要加上<code>@escaping</code>关键字。</p>
<p>  然后之后需不需要隐式地调用self，又没看懂。应该和会形成引用有关系。也就是说，逃逸闭包捕获了self，但是需要在函数执行之后不知道什么时候才调用。这样这个引用就会一直存在。类对象，必须显示引用self。</p>
<p>  如果self是一个结构体和枚举类型类型的self，你可以隐式的引用他，但是不能修改他。</p>
</li>
</ul>
<h2 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h2><p><strong>枚举类型起初并没有和什么值绑定，他就是他自己作为值。可以用switch判断，也可以用CaseIterable来创建collection。然后引入了，关联的值，为每个case关联值。</strong></p>
<p>==可以确定的是，他也是一个<strong>TYPE</strong>==，可以理解成和struct类似？</p>
<p>枚举类型的格式</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SomeEnumeration</span> &#123;</span><br><span class="line">    <span class="comment">// enumeration definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个定义枚举类型的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用逗号分隔多个case</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与在C中不同的是，这些case并没有绑定默认的值，我的理解是，他的值就是定义在case的右边的本身</p>
<ul>
<li><p>Each enumeration definition defines a new type. Like other types in Swift, their names (such as <code>CompassPoint</code> and <code>Planet</code>) start with a capital letter.</p>
<p>  每一个枚举类型定义了一个新的类型，他们的类型名字用大写字母开头。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead <span class="operator">=</span> <span class="type">CompassPoint</span>.west</span><br></pre></td></tr></table></figure>

<p>  The type of <code>directionToHead</code> is inferred when it’s initialized with one of the possible values of <code>CompassPoint</code>. Once <code>directionToHead</code> is declared as a <code>CompassPoint</code>, you can set it to a different <code>CompassPoint</code> value using a shorter dot syntax:</p>
<p>  既然已经确定了变量<code>directionToHead</code>是类型<code>CompassPoint</code>，再为他赋值时，可以使用更简单的方式</p>
<p>  <code>directionToHead is CompassPoint</code>返回的是true</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead <span class="operator">=</span> .east</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>使用switch匹配枚举类型，略。只有一个注意点，就是要匹配到枚举类型里所有的case才能保证完备。</li>
</ul>
<ul>
<li><p>迭代枚举类型</p>
<p>  首先要在枚举类型的名字后面加上<code>CaseIterable</code>，这样在访问属性<code>allCases</code>时，就创建了一个含有枚举类型中所有case的collection，可以使用for-in对collection进行访问</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Beverage</span>: <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> coffee, tea, juice</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numberOfChoices <span class="operator">=</span> <span class="type">Beverage</span>.allCases.count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(numberOfChoices)</span> beverages available&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;3 beverages available&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beverage <span class="keyword">in</span> <span class="type">Beverage</span>.allCases &#123;</span><br><span class="line">    <span class="built_in">print</span>(beverage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// coffee</span></span><br><span class="line"><span class="comment">// tea</span></span><br><span class="line"><span class="comment">// juice</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>associated value</code></p>
<p>  可以把每个case存储相关的值，这样更有意义。而且每个case可以有不同的值类型。</p>
<p>  他的举例为，一个一维条形码upc，和二维码qrcode</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“Define an enumeration type called <code>Barcode</code>, which can take either a value of <code>upc</code> with an associated value of type (<code>Int</code>, <code>Int</code>, <code>Int</code>, <code>Int</code>), or a value of <code>qrCode</code> with an associated value of type <code>String</code>.”</p>
</blockquote>
<p>  定义一个枚举类型叫做<code>Barcode</code>，要么是值<code>upc</code>同时有一个associated value是类型<code>(Int, Int, Int, Int)</code>，要么是值<code>qrCode</code>同时有一个associated value是类型<code>String</code></p>
<blockquote>
<p>This definition doesn’t provide any actual <code>Int</code> or <code>String</code> values—it just defines the <em>type</em> of associated values that <code>Barcode</code> constants and variables can store when they’re equal to <code>Barcode.upc</code> or <code>Barcode.qrCode</code>.</p>
</blockquote>
<p>  这个定义并没有提供一个实际的<code>Int</code>或者<code>String</code>值，他只是定义了associated value的类型，当他们与<code>Barcode.upc</code>或<code>Barcode.qrCode</code>相等时，一个<code>BarCode</code>变量可能存储的值。</p>
<p>  还是看例子吧</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>  定义了一个变量，而且assigns it a value of <code>Barcode.upc</code> with an associated tuple value of <code>(8, 85909, 51226, 3)</code>.</p>
<p>  同样和上文一样，可以修改这个变量为其他的case</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode <span class="operator">=</span> .qrCode(<span class="string">&quot;ABCDEFGHIJKLMNOP&quot;</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>还是可以用switch判断类型，但是可以提取associated value，这里就不写了。</li>
</ul>
<ul>
<li><p>Raw Values</p>
<p>  除了用关联值为一个case关联值，类似类和结构体的初始化，枚举类型这里也可以使用原始值预填充，每个原始值的类型必须是一致的。如下，==<strong>注意</strong>第一行后面写了类型==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ASCIIControlCharacter</span>: <span class="title class_">Character</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> tab <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> lineFeed <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> carriageReturn <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  原始值之间必须是<strong>不相同的</strong>。</p>
<p>  <code>ASCIIControlCharacter.tab</code>仍然是<code>ASCIIControlCharacter</code>枚举类型，<code>ASCIIControlCharacter.tab.rawValue</code>才是对应的原始值类型。具体见我们再cs193笔记开头写的代码例子。</p>
</li>
</ul>
<ul>
<li><p>当使用Int或者String作为原始值时，会存在着隐式的赋值。这一点和C很像。</p>
<p>  当使用整数作为原始值时，隐式赋值的值依次递增 <code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为 <code>0</code>。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Planet</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> mercury <span class="operator">=</span> <span class="number">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在上面的例子中，<code>Plant.mercury</code> 的显式原始值为 <code>1</code>，<code>Planet.venus</code> 的隐式原始值为 <code>2</code>，依次类推。</p>
<p>  当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span>: <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> north, south, east, west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  面例子中，<code>CompassPoint.south</code> 拥有隐式原始值 <code>south</code>，依次类推。</p>
<p>  使用枚举成员的 <code>rawValue</code> 属性可以访问该枚举成员的原始值：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder <span class="operator">=</span> <span class="type">Planet</span>.earth.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection <span class="operator">=</span> <span class="type">CompassPoint</span>.west.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 &quot;west&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用原始值初始化枚举实例 initializing from raw value感觉有点鸡肋</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet <span class="operator">=</span> <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet is of type Planet? and equals Planet.uranus</span></span><br></pre></td></tr></table></figure>

<p>  就是用原始值，找到对应的case来初始化一个变量。==注意==，返回的是对应的枚举optional类型，因为可能找不到。</p>
</li>
<li><p>递归枚举，有点绕，但是能看懂，估计用处不大，这里不写了</p>
</li>
</ul>
<h2 id="Structures-and-Classes"><a href="#Structures-and-Classes" class="headerlink" title="Structures and Classes"></a>Structures and Classes</h2><p><strong>总结，结构体和其他大多数类型是值类型，传递时，先做复制，彼此之间的修改相互独立。类类型是引用类型，和python类似，都指向同一个对象，而且有点像存储地址的意思？虽然文档说不是，但是可以这么理解</strong></p>
<p>类型名字大写驼峰命名，如<code>SomeStructure</code>和<code>SomeClass</code>。属性名和方法名，小写驼峰命名，如<code>frameRate</code>和<code>incrementCount</code></p>
<ul>
<li><p>Structures and enumerations are value type. 结构体和枚举类型是值类型。</p>
<blockquote>
<p>A <em>value type</em> is a type whose value is <em>copied</em> when it’s assigned to a variable or constant, or when it’s passed to a function.</p>
</blockquote>
<p>  值类型是一种类型，当传递给变量或者常量时，或者传递给函数时，它只是将值做一遍拷贝。</p>
<blockquote>
<p>all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.</p>
</blockquote>
<p>  swift中几乎所有的基础类型，整数，浮点，布尔，字符串，数组，字典都是值类型，都是使用结构体实现的。</p>
</li>
</ul>
<ul>
<li><p>Classes are reference types. 类是引用类型。</p>
<p>  也就是说，将一个变量a赋给变量b时，两个变量指向同一个内存区域。这个和python里一样。</p>
<p>  Effectively, they’re just two different names for the same single instance</p>
<p>  还一个有意思的现象，==这里变量貌似存储的是一个地址？==，因为我可以修改一个常量类变量属性的值。对此文档的解释是，属性的值改变，并没有改变实例。 they both <em>refer</em> to a <code>VideoMode</code> instance behind the scenes. It’s the <code>frameRate</code> property of the underlying <code>VideoMode</code> that’s changed, not the values of the constant references to that <code>VideoMode</code>.我觉得，大概的意思是，就是地址。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Resolution</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoMode</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> resolution <span class="operator">=</span> <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hd <span class="operator">=</span> <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tenEighty <span class="operator">=</span> <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution <span class="operator">=</span> hd</span><br><span class="line">tenEighty.interlaced <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">tenEighty.name <span class="operator">=</span> <span class="string">&quot;1080i&quot;</span></span><br><span class="line">tenEighty.frameRate <span class="operator">=</span> <span class="number">25.0</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用三个等于号</p>
<p>  <code>===</code>来判断两个变量是否指向同一个示例</p>
<p>  <code>!==</code>指向不同的示例</p>
</li>
</ul>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li><p>stored properties感觉就和C中的属性类似</p>
<p>  由于结构体是value type，所以与上文中的class不同，不能对常量类型的结构体的属性进行修改，如下，==但是定义成变量的结构体，是可以修改属性的==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems <span class="operator">=</span> <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// this range represents integer values 0, 1, 2, and 3</span></span><br><span class="line">rangeOfFourItems.firstValue <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="comment">// this will report an error, even though firstValue is a variable property</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>lazy stored properties. 利用<code>lazy</code>修饰器，修饰一个存储变量属性（只能修饰变量），使得当这个属性第一次被使用时，才会真正的初始化。适用于，初始化消耗比较多的场景。</p>
<blockquote>
<p>必须将延时加载属性声明成变量（使用 <code>var</code> 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而<strong>常量属性在构造过程完成之前必须要有初始值</strong></p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataImporter</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DataImporter is a class to import data from an external file.</span></span><br><span class="line"><span class="comment">    The class is assumed to take a nontrivial amount of time to initialize.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> filename <span class="operator">=</span> <span class="string">&quot;data.txt&quot;</span></span><br><span class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataManager</span> &#123;</span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">manager.data.append(<span class="string">&quot;Some more data&quot;</span>)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property hasn&#x27;t yet been created</span></span><br></pre></td></tr></table></figure>

<p>  如上，创建DataManager实例后，其中的属性importer并没有创建实例，直到它第一次被使用。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.filename)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has now been created</span></span><br><span class="line"><span class="comment">// Prints &quot;data.txt&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Computed properties</p>
<p>  举几个例子，<code>var body</code>还有<code>viewModel</code>里返回<code>cards</code>的变量都是计算属性，不过他们是只读的，其实计算类型很好理解的。</p>
<p>  <strong>计算类型一定要设置为变量</strong>，他们并不存储值，通过<code>get</code>中返回一个与定义的变量类型相同的值来获取值，同时他也能通过<code>set</code>来影响其他的属性。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter <span class="operator">=</span> square.center</span><br><span class="line"><span class="comment">// initialSquareCenter is at (5.0, 5.0)</span></span><br><span class="line">square.center <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;square.origin is now at (10.0, 10.0)&quot;</span></span><br></pre></td></tr></table></figure>

<p>  最关键的代码就是第10-20行，这个计算变量<code>center</code>的代码。我们初始化这个正方体，只给了属性<code>origin</code>和<code>size</code>值，我们通过<code>get</code>计算出值来赋给<code>center</code>。同样，我们改变<code>center</code>的值，会自动的通过<code>set</code>来影响到其他属性。</p>
</li>
<li><p>简化setter声明，在上文中，我们对set设置了参数<code>set(newCenter)</code>，我们也可以不设置参数，使用简写的方式,默认的名字是<code>newValue</code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">    origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">    origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  getter简写，就是一行代码不写return，这个和函数也和闭包里面一样</p>
</li>
</ul>
<ul>
<li><p>read-only computed properties只读计算属性，没有setter的计算属性</p>
<p>  这个就是我们经常见到的<code>var body</code>啦。这次省略的更厉害，==把get，连同get的花括号全部省略了==</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cuboid</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span>, depth <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width <span class="operator">*</span> height <span class="operator">*</span> depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo <span class="operator">=</span> <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>  感觉这里return都能省略</p>
</li>
<li><p>type properties</p>
<p>  我觉得type stored properties就是C++中类里的静态类型，用<code>static</code>来声明。type computed properties应该就和copmuted properties类似，多了个关键字？</p>
<blockquote>
<p>Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself doesn’t have an initializer that can assign a value to a stored type property at initialization time.</p>
<p>Stored type properties are lazily initialized on their first access. They’re guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they don’t need to be marked with the <code>lazy</code> modifier.</p>
</blockquote>
<p>  必须给<strong>stored</strong> type properties一个默认值。然后stored type properties是lazy初始化的，只有第一次访问到他，才会用值初始化。</p>
</li>
</ul>
<ul>
<li><p>property obsevers</p>
<p>  这个和计算属性其实有点像，但是是有区别的。</p>
<blockquote>
<p>Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.</p>
</blockquote>
<p>  每次属性值改变的时候，都是用属性观察者。</p>
<p>  你可以在以下位置添加属性观察器：</p>
<ul>
<li><p>自定义的存储属性</p>
</li>
<li><p>继承的存储属性</p>
</li>
<li><p>继承的计算属性</p>
<p>==区别1，属性观察者可以用在存储属性上。==区别2，这里使用的是<code>willSet</code>或者<code>didSet</code>，可以两者都用，或者只用其中之一。</p>
<p><code>willSet</code>在值被改变前调用，<code>didSet</code>在值被改变后调用。</p>
<p>如果你实现<code>willSet</code>的话，新值将会作为常量参数传入。你可以给参数名字，如果不给名字，默认就是<code>newValue</code></p>
<p>同样地，实现<code>didSet</code>的话，旧值作为常量参数传入。你可以给参数名字，如果不给名字，默认就是<code>oldValue</code></p>
<p>这里有一些关于继承的note，暂时不摘过来了。例子：</p>
</li>
</ul>
<p>  <strong>注意一下,didSet之后，你可以直接使用变量的名字，那里面放的就是新值</strong></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StepCounter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;将 totalSteps 的值设置为 <span class="subst">\(newTotalSteps)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps <span class="operator">&gt;</span> oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;增加了 <span class="subst">\(totalSteps <span class="operator">-</span> oldValue)</span> 步&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter <span class="operator">=</span> <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">200</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 200</span></span><br><span class="line"><span class="comment">// 增加了 200 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">360</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 360</span></span><br><span class="line"><span class="comment">// 增加了 160 步</span></span><br><span class="line">stepCounter.totalSteps <span class="operator">=</span> <span class="number">896</span></span><br><span class="line"><span class="comment">// 将 totalSteps 的值设置为 896</span></span><br><span class="line"><span class="comment">// 增加了 536 步</span></span><br></pre></td></tr></table></figure>

<p>  注意这个属性是存储属性。每次被赋予新值的时候，（即使新值等于旧值），willSet和didSet都会被调用。</p>
<blockquote>
<p>If you pass a property that has observers to a function as an in-out parameter, the <code>willSet</code> and <code>didSet</code> observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function.</p>
</blockquote>
<p>  如果将带有观察器的属性通过 in-out 方式传入函数，<code>willSet</code> 和 <code>didSet</code> 也会调用。这是因为 in-out 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>
</li>
</ul>
<ul>
<li><p>property wrapper</p>
<p>  当使用属性包装器时，你只需在定义属性包装器时编写一次管理代码，然后应用到多个属性上来进行复用。</p>
<p>  为了定义一个property wrapper，你可以定义一个结构体，枚举，类，定义一个属性wrappedValue。<code>TwelveOrLess</code> 结构体确保它包装的值始终是小于等于 12 的数字。如果要求它存储一个更大的数字，它则会存储 12 这个数字。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TwelveOrLess</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number <span class="operator">=</span> <span class="built_in">min</span>(newValue, <span class="number">12</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里<code>wrappedValue</code>被定义为计算变量，set保证了设置的值不会超过12.</p>
<blockquote>
<p>You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute.</p>
</blockquote>
<p>  你可以应用一个包装器，通过把他的名称写在属性之前，如这里<code>@TwelveOrLess</code>。通过 <code>TwelveOrLess</code> 属性包装器来确保它的长宽均小于等于 12。==值得注意的一点，==The <code>height</code> and <code>width</code> properties get their initial values from the definition of <code>TwelveOrLess</code>, which sets <code>TwelveOrLess.number</code> to zero.这里height的初值应该还是来自12这个结构体的计算变量。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    <span class="meta">@TwelveOrLess</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rectangle <span class="operator">=</span> <span class="type">SmallRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;10&quot;</span></span><br><span class="line"></span><br><span class="line">rectangle.height <span class="operator">=</span> <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height)</span><br><span class="line"><span class="comment">// 打印 &quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>  下面这串代码和我们写属性包装器的效果是一样的。_height是一个<code>TwelveOrLess</code>实例，这个版本将其属性明确地包装在 <code>TwelveOrLess</code> 结构体中，而不是把 <code>@TwelveOrLess</code> 作为特性写下来：现在理解为什么叫属性包装器了吧。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SmallRectangle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _height <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _width <span class="operator">=</span> <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _height.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _height.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _width.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _width.wrappedValue <span class="operator">=</span> newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ==因为属性包装器语法只是具有 getter 和 setter 的属性的语法糖==</p>
</li>
</ul>
<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>方法，我感觉就是定义在类，结构体，枚举类型里的函数？</p>
<p>分为<code>instance methods</code>，实例化后使用；和<code>type methods</code>，感觉和静态的类似？</p>
<ul>
<li><p>一个非常重要的理解，<strong>self是一个instance</strong>，这对报初始化错的理解有帮助</p>
</li>
<li><p><code>instance methods</code>就是C那一套，不多说了。</p>
<p>  一个instance method可以有隐式地访问其他的instance method和properties，只能由实例调用。再一个，可以重名写（参数类型不一样就可以？），如下。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">        count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">increment</span>(<span class="params">by</span> <span class="params">amount</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        count <span class="operator">+=</span> amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">        count <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Every instance of a type has an implicit property called <code>self</code>, which is exactly equivalent to the instance itself. You use the <code>self</code> property to refer to the current instance within its own instance methods.</p>
</blockquote>
<p>  每一个类型的实例，有一个隐式的属性，叫做<code>self</code>。与类型本身完全一致，可以用self在method里作为本身的指代。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">increment</span>() &#123;</span><br><span class="line">    <span class="keyword">self</span>.count <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  其实不需要显示的写<code>self</code>，swift会自己进行推断。例外在，method的参数和外部的参数冲突，可以使用self</p>
</li>
</ul>
<ul>
<li><p>上文中<strong>在method里对属性直接修改的是class</strong></p>
<blockquote>
<p>Structures and enumerations are <em>value types</em>. By default, the properties of a value type can’t be modified from within its instance methods.</p>
</blockquote>
<p>  这又是一个很奇怪的属性，由于结构体和枚举类型是value type。默认的他们的属性的值，不能够被instance method修改，要在method前使用<code>mutating</code>关键字。很奇怪的特性，因为对于变量结构体而言，他的属性可以在外部直接修改，在method里却不能直接改。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        x <span class="operator">+=</span> deltaX</span><br><span class="line">        y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The point is now at (3.0, 4.0)&quot;</span></span><br></pre></td></tr></table></figure>

<p>  而且</p>
<blockquote>
<p>The method can also assign a completely new instance to its implicit <code>self</code> property, and this new instance will replace the existing one when the method ends.</p>
</blockquote>
<p>  这个方法会返回一个新的实例来替代<code>self</code>，所以有另一种写法。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x: x <span class="operator">+</span> deltaX, y: y <span class="operator">+</span> deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们之前在enum章节，已经介绍过在枚举类型的method里，可以用switch self。在这里也有一个应用，用在mutating的method里</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriStateSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, low, high</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">        <span class="keyword">case</span> .low:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">        <span class="keyword">case</span> .high:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight <span class="operator">=</span> <span class="type">TriStateSwitch</span>.low</span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .high</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight is now equal to .off</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>type methods. 与instance methods不同，不需要实例化，基于类型调用。<strong>不能基于实例去调用</strong></p>
<blockquote>
<p>You indicate type methods by writing the <code>static</code> keyword before the method’s <code>func</code> keyword. Classes can use the <code>class</code> keyword instead, to allow subclasses to override the superclass’s implementation of that method.</p>
</blockquote>
<p>  在方法前加上<code>static</code>，就是type methods。但是在类里，可以使用<code>class</code>关键字，去允许子类覆盖超类中方法的实现。</p>
<p>  允许直接用类名去调用type methods</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">func</span> <span class="title class_">someTypeMethod</span>() &#123;</span><br><span class="line">        <span class="comment">// type method implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Within the body of a type method, the implicit <code>self</code> property refers to the type itself, rather than an instance of that type. This means that you can use <code>self</code> to disambiguate between type properties and type method parameters, just as you do for instance properties and instance method parameters.</p>
</blockquote>
<p>  在type method里，==self属性指的是type本身，所以可以直击在里面直接使用静态的属性==并不是实例。所以如同上文一样，你可以用self来避免命名的重复。</p>
</li>
</ul>
<ul>
<li><p><code>type method</code>里使用其他的type method和type properties，而不用使用type名作为前缀。==实验了一下，非静态的属性不能用在type method里，会报错。Instance member ‘currentLevel’ cannot be used on type ‘LevelTracker’==</p>
<p>  同样在instance method中也不能直接访问静态的属性，要加上类或者结构体的名称。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LevelTracker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">unlock</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> level <span class="operator">&gt;</span> highestUnlockedLevel &#123; highestUnlockedLevel <span class="operator">=</span> level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">isUnlocked</span>(<span class="keyword">_</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level <span class="operator">&lt;=</span> highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">advance</span>(<span class="params">to</span> <span class="params">level</span>: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel <span class="operator">=</span> level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="subscripts"><a href="#subscripts" class="headerlink" title="subscripts"></a>subscripts</h2><p>access the elements of a collection</p>
<p>语法，使用subscipt关键字，后跟参数以及返回类型（有点像函数）。内部有点像计算变量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的下标值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The type of <code>newValue</code> is the same as the return value of the subscript. <code>newValue</code>的类型和下标的返回值一致。下面的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TimesTable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier <span class="operator">*</span> index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable <span class="operator">=</span> <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;six times three is 18&quot;</span></span><br></pre></td></tr></table></figure>



<p>下标可以接受任意数量的参数，这些参数可以是任意类型的，返回值也可以是任意类型的。</p>
<h2 id="inheritance"><a href="#inheritance" class="headerlink" title="inheritance"></a>inheritance</h2><p>不继承自其它的类称为base class</p>
<p>子类可以为继承来的实例方法，类方法，实例属性，类属性，或下标提供自己定制的实现。如果要override，必须加上override关键字。</p>
<p>你可以提供定制的 getter（或 setter）来重写任何一个继承来的属性，无论这个属性是存储型还是计算型属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必须将它的名字和类型都写出来。</p>
<p>还可以为继承来的属性设置属性观察器，</p>
<p>把属性方法或者下标定义成final，来防止被重写。</p>
<h2 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h2><ul>
<li><blockquote>
<p>Classes and structures <em>must</em> set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties can’t be left in an indeterminate state.</p>
</blockquote>
<p>  类和结构体的<code>存储属性</code>，在创建一个实例后，==必须有一个初始值。==可以通过初始化器，也可以通过赋默认的属性值。</p>
<p>  通过初始化器初始化</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f <span class="operator">=</span> <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The default temperature is 32.0° Fahrenheit&quot;</span></span><br></pre></td></tr></table></figure>

<p>  通过属性的默认值初始化</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fahrenheit</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperature <span class="operator">=</span> <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>自定义初始化，初始化器可以引入argument label和parameter name，==如果写了label，那么在调用时一定要进行调用，也就是说在目前这个例子里，<code>Celsius(30.0)来初始化是错的，因为两个初始化器都有label</code>==</p>
<p>  如下，温度转化的例子</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius is 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius is 0.0</span></span><br></pre></td></tr></table></figure>

<p>  如果不想写label，还是和之前函数章节描述的一样，使用下划线</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">celsius</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius <span class="operator">=</span> celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature <span class="operator">=</span> <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius is 37.0</span></span><br></pre></td></tr></table></figure>

<p>  但是值得注意的是，我如果把从开尔文的温度转化也去掉label名字，这样就会存在初始化器的冲突现象出现。<code>init(_ kelvin: Double)</code>和<code>init(_ celsius: Double)</code>被认为是一样的。</p>
</li>
</ul>
<ul>
<li><p>optional 类型的属性，在初始化时，会被自动的定义为nil，可以在实例化之后为其赋值。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SurveyQuestion</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">text</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text <span class="operator">=</span> text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">ask</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion <span class="operator">=</span> <span class="type">SurveyQuestion</span>(text: <span class="string">&quot;Do you like cheese?&quot;</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// Prints &quot;Do you like cheese?&quot;</span></span><br><span class="line">cheeseQuestion.response <span class="operator">=</span> <span class="string">&quot;Yes, I do like cheese.&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>只要在初始化结束之前为常量属性赋值即可，一旦常量属性被赋了一个值，就不能再修改。对于类来说，常量属性只能被这一级的类修改，不能被子类修改。</li>
</ul>
<ul>
<li><blockquote>
<p>Structure types automatically receive a <em>memberwise initializer</em> if they don’t define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values.</p>
</blockquote>
<p>  即使你没有给结构体提供构造器和默认值，他也会自动有一个<code>memberwise initializer </code></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<p>  当你调用memberwise initializer时，可以忽略已有默认值的属性。如下，可以忽略<code>width</code>，也可以把<code>width</code>和<code>height</code>都忽略。</p>
</li>
</ul>
<ul>
<li><p>==注意一下，==对于结构体和类来说，如果为所有的属性提供了默认值，但又没有提供初始化器，就会获得一个<code>default initializer</code>，不需要任何参数。<strong>结构体除此之外，就算 他不给属性提供默认值，他也会获得一个默认的<code>memberwise initializer</code>，这个是需要写label的</strong>。这两者有一些细微的差距。当然对于结构体，前者也可以理解为后者的忽略已有值的简写。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default initializer</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="type">Size</span>() <span class="comment">//没写参数</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="type">Size</span>(width: <span class="number">3</span>, height: <span class="number">5</span>)  <span class="comment">// memberwise</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>这是==两个==构造器，这种情况是允许存在的。就是label的名字不同，竟然编译器就认为这是两个构造器</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0</span>, height <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        width <span class="operator">=</span> a</span><br><span class="line">        height <span class="operator">=</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">c</span>: <span class="type">Int</span>, <span class="params">d</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        width <span class="operator">=</span> c</span><br><span class="line">        height <span class="operator">=</span> d</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>initializer delegation for value type</p>
<p>  大概意思就是，在一个<code>init()</code>里可以调其他的构造器。</p>
<p>  构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为<em>构造器代理</em>，它能避免多个构造器间的代码重复。</p>
<p>  对于值类型，你可以使用 <code>self.init</code> 在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用 <code>self.init</code>。</p>
<p>  请注意，如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。</p>
<p>  我们还是看例子吧</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">        <span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里提供了三个构造器。</p>
<p>  第一个<code>init()</code>，和什么参数都没有的默认构造器一样。会自动赋默认值。</p>
<p>  第二个<code>init(origin:size:)</code>，和memberwise的构造器一样</p>
<p>  第三个<code>init(center:size:)</code>，注意和因为label不一样，上面的构造器是不一样的。在这个构造器里使用<code>self.init</code>调用了上一个构造函数。</p>
</li>
</ul>
<ul>
<li><p>类的继承和初始化</p>
<p>  swift定义了两种初始化器，保证了所有的存储属性都有初始化值。<code>designated initializers</code>和<code>convenience intializers</code>指定构造器和便利构造器。</p>
<p>  <em>指定构造器</em>是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并调用合适的父类构造器==让构造过程沿着父类链继续往上进行。==</p>
<p>  每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>
</li>
<li><p>指定构造器语法和便利构造器语法</p>
<p>  Designated initializer</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  便利构造器要加上<code>convenience</code>关键字</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类类型的构造器代理</p>
<p>  ==三条规则。==</p>
<p>  指定构造器必须调用其直接父类的的指定构造器。</p>
<p>  便利构造器必须调用<em>同</em>类中定义的其它构造器。</p>
<p>  便利构造器最后必须调用指定构造器。</p>
<blockquote>
<p>指定构造器必须总是<em>向上</em>代理</p>
<p>便利构造器必须总是<em>横向</em>代理</p>
</blockquote>
<p>  如图</p>
<p>  ![截屏2023-03-10 15.33.27](swift-programming-language笔记.assets/截屏2023-03-10 15.33.27.png)</p>
</li>
<li><p>两段式初始化</p>
<p>  第一阶段，每一个存储属性必须被赋予初值，通过引入他的类。在所有存储属性有初值之后，进入第二阶段，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p>
<p>  四条规则总结，1 2条对于指定构造器，必须先把本层类引入的存储属性初始化，然后这时候必须交给父类的构造器，然后才能修改继承来的属性。3 条 便利构造器，必须先调用同级的其他构造器，然后才能修改属性值。 4 条 在第一阶段完成之前，一个构造器不能访问self的值，或者instance方法。</p>
</li>
<li><p>构造的两个阶段</p>
<p>  自底向上调用父类的构造器</p>
<blockquote>
<p>类的某个指定构造器或便利构造器被调用。</p>
<p>完成类的新实例内存的分配，但此时内存还没有被初始化。</p>
<p>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</p>
<p>指定构造器切换到父类的构造器，对其存储属性完成相同的任务。</p>
<p>这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。</p>
<p>当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</p>
</blockquote>
<p>  第二阶段，</p>
<blockquote>
<ul>
<li>Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access <code>self</code> and can modify its properties, call its instance methods, and so on.</li>
<li>Finally, any convenience initializers in the chain have the option to customize the instance and to work with <code>self</code>.</li>
</ul>
</blockquote>
<p>  自定向下所有的存储属性已经全部有值了。现在指定构造器能够自己修改实例了，构造器也能访问到self并且修改他了。便利构造器也可以自定义实例了。</p>
</li>
</ul>
<ul>
<li><p>Swift 中的子类默认情况下不会继承父类的构造器。</p>
<blockquote>
<p>父类的构造器仅会在安全和适当的某些情况下被继承。</p>
</blockquote>
<p>  当你写一个子类构造器匹配父类的<strong>指定</strong>构造器，你就是在override。</p>
<p>  当你重写一个父类的指定构造器时，你总是需要写 <code>override</code> 修饰符。</p>
<p>  当你写了一个子类匹配父类的<strong>便利</strong>构造器，由于子类不能直接调用父类的便利构造器，因此这不是重写，不用写override。</p>
<p>  例子，我们定义了一个行驶工具类</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(numberOfWheels)</span> wheel(s)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  子类自行车继承并重写了默认的构造函数</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bicycle</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels <span class="operator">=</span> <span class="number">2</span>  <span class="comment">// 第二阶段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ==如果子类在第二阶段，不自定义操作，可以省略<code>super.init()</code>==，如下</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hoverboard</span>: <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> color: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">color</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.color <span class="operator">=</span> color</span><br><span class="line">        <span class="comment">// 隐式调用</span></span><br><span class="line">        <span class="comment">// super.init() implicitly called here</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(<span class="keyword">super</span>.description)</span> in a beautiful <span class="subst">\(color)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>构造器的自动继承</p>
<p>  默认情况下，子类不会继承父类的构造器。但是，有两个规则会适用。</p>
<p>  规则1：如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</p>
<p>  规则2：If your subclass provides an implementation of all of its superclass designated initializers — either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition — then it automatically inherits all of the superclass convenience initializers.如果子类提供了<strong>所有</strong>超类的指定构造器的实现（不管是不是通过规则1继承来的），那么他将自动的实现超类所有的便利构造器</p>
</li>
</ul>
<ul>
<li><p>Failable initializers</p>
<p>  就是有时候传入无效的参数（如类型转化），或者缺少某种外部资源，构造器会失败。以return nil来表示构造器失败。</p>
<p>  这个例子类型转化就失败了，返回了nil。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wholeNumber: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12345.0</span></span><br><span class="line"><span class="keyword">let</span> pi <span class="operator">=</span> <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> valueMaintained <span class="operator">=</span> <span class="type">Int</span>(exactly: wholeNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(wholeNumber)</span> conversion to Int maintains value of <span class="subst">\(valueMaintained)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;12345.0 conversion to Int maintains value of 12345&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> valueChanged <span class="operator">=</span> <span class="type">Int</span>(exactly: pi)</span><br><span class="line"><span class="comment">// valueChanged is of type Int?, not Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valueChanged <span class="operator">==</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(pi)</span> conversion to Int doesn&#x27;t maintain value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;3.14159 conversion to Int doesn&#x27;t maintain value&quot;</span></span><br></pre></td></tr></table></figure>

<p>  用<code>init?</code>表示表示构造器可能会失败，如下，当传入的字符串为空时，会触发构造器失败。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init?</span>(<span class="params">species</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species <span class="operator">=</span> species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>required initializers</p>
<p>  在类中用required关键字修饰初始化器，要求该类的所有子类都要实现这个构造器</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在子类重写父类的必要构造器时，必须在子类的构造器前也添加 <code>required</code> 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubclass</span>: <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<ul>
<li><p>通过闭包或者函数设置属性的<strong>默认值</strong></p>
<p>  这一章<strong>很新</strong></p>
<p>  ==这样可以避免了，我们使用property initilizer时无法调用一个内容与self无关的method，直接写一个闭包，同时也避免了写成全局太难看==</p>
<p>  我们可以使用闭包或者<strong>全局</strong>函数为==存储==属性提供默认值。（这和计算属性是有很大不同的）。通过闭包或者函数的返回值，来作为属性的默认值。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()  <span class="comment">// 这个花括号很重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ==注意闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。==</p>
<blockquote>
<p>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 <code>self</code> 属性，或者调用任何实例方法。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>只读计算属性computated propertues 和 通过闭包设置存储属性的默认值的区别</p>
<p>  先总结一下区别：</p>
<ol>
<li><p>计算属性不需要初始化，闭包赋值针对是默认初始化的赋值</p>
</li>
<li><p>计算属性的花括号里可以访问self即其相关属性或方法，闭包赋值的花括号里是不能访问self的。（我的理解，property initializer里面都不能访问self）</p>
</li>
<li><p>计算属性后面没有<code>=</code>，也有末尾的<code>()</code></p>
<p>相同点，花括号里都能定义局部变量等。</p>
</li>
</ol>
</li>
</ul>
<h2 id="deinitialization"><a href="#deinitialization" class="headerlink" title="deinitialization"></a>deinitialization</h2><p>析构函数，只需用于类类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// perform the deinitialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个类<strong>最多只有一个</strong>析构函数。Deinitializers are called automatically, just before instance deallocation takes place.在实例被释放前，将会被自动调用。</p>
<p>Superclass deinitializers are inherited by their subclasses, and the superclass deinitializer is called automatically at the end of a subclass deinitializer implementation. Superclass deinitializers are always called, even if a subclass doesn’t provide its own deinitializer.</p>
<p>超类的析构函数会被子类继承，超类的析构函数会在子类析构函数实现的最后被自动调用。超类的析构函数总是会被调用，即使一个子类没有提供自己的析构函数。</p>
<h2 id="Optional-Chaining"><a href="#Optional-Chaining" class="headerlink" title="Optional Chaining"></a>Optional Chaining</h2><p>先简单说一点。一个optional 类型变量想要通过dot也就是点<code>.</code>来访问方法，属性或者访问下标 或者 通过下标来访问。但是，又不想通过强制解包或者optional binding来先判断这个optional 类型是否是<code>nil</code>，就是不管，直接往下继续访问。</p>
<blockquote>
<p>也就是说optional类型变量，后面加个问号，就能当做正常变量一样，继续往后写东西。如，<code>a?.xxx</code>，<code>a?[0]</code></p>
</blockquote>
<p>看两个简单例子起，变量<code>c</code>是<code>String</code>类型，它调用函数<code>hasPrefix()</code>返回的是bool值。也就是说，变量<code>d</code>的类型是<code>Bool</code>类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c.hasPrefix(<span class="string">&quot;e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p>现在我们将变量<code>c</code>变为<code>String?</code>类型，按理说，他要是想要调用函数，只能强制解包后，才能调用。但是这样如果<code>c</code>是nil的话，就会引发运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line">c<span class="operator">!</span>.hasPrefix(<span class="string">&quot;e&quot;</span>)  <span class="comment">// 强制解包</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过optinal chaining，不解包就调用函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c<span class="operator">?</span>.hasPrefix(<span class="string">&quot;a&quot;</span>)  <span class="comment">// 注意这里的返回类型，为Bool?</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment">// Optional(true)</span></span><br></pre></td></tr></table></figure>

<p>但是由于<code>c</code>有可能是nil，所以最后返回的类型，是我们期望正常返回类型的optional类型。在这里是<code>Bool?</code>。如果<code>c</code>不是nil，那么<code>d</code>这个<code>Bool?</code>类型就有值。</p>
<p>如果<code>c</code>是nil，那么<code>d</code>这个<code>Bool?</code>类型就是<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> c<span class="operator">?</span>.hasPrefix(<span class="string">&quot;a&quot;</span>)  <span class="comment">// 注意这里的返回类型，为Bool?</span></span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>



<p>例子2，字典的下标访问</p>
<p>字典取值返回的是optional类型，如果key里放的是数组，想要进一步通过下标访问数组元素。同样的做法，optional chaining</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores <span class="operator">=</span> [<span class="string">&quot;Dave&quot;</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">&quot;Bev&quot;</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">&quot;Dave&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">91</span></span><br><span class="line">testScores[<span class="string">&quot;Bev&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">testScores[<span class="string">&quot;Brian&quot;</span>]<span class="operator">?</span>[<span class="number">0</span>] <span class="operator">=</span> <span class="number">72</span></span><br><span class="line"><span class="comment">// &quot;Dave&quot; 数组现在是 [91, 82, 84]，&quot;Bev&quot; 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure>

<p>前两个调用成功。==第二个调用有点奇怪？？==我的理解是，optinal类型可以被赋值，但是能直接这么加1吗？普通变量这么加肯定是错的</p>
<ul>
<li><p>例子举完了。我们先说最后的总结吧</p>
<p>  optional chaining是可以连接很多很多层的，但是最后的返回类型只和最后一个调用的返回类型相关，并变成optional类型。</p>
<blockquote>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个 <code>Int</code> 值，将会返回 <code>Int?</code>，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问 <code>Int?</code> 值，依旧会返回 <code>Int?</code> 值，并不会返回 <code>Int??</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><blockquote>
<p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回 <code>nil</code> 则说明调用失败。</p>
<p>这里需要特别指出，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是 <code>Int</code> 类型，则会变为 <code>Int?</code> 类型。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>看一个访问属性的简单例子</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">!</span>.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount <span class="operator">=</span> john.residence<span class="operator">?</span>.numberOfRooms &#123;  <span class="comment">// 使用optional chaining</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;John&#x27;s residence has <span class="subst">\(roomCount)</span> room(s).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unable to retrieve the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>除了可以访问属性，还可以为属性赋值，如</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress</span><br></pre></td></tr></table></figure>

<p>  上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，==等号右侧的代码不会被执行。==上面等号右边是常量，看不出来。假如改成函数调用，函数将不会调用，体现在没有执行中间的打印语句。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">createAddress</span>() -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function was called.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress <span class="operator">=</span> <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber <span class="operator">=</span> <span class="string">&quot;29&quot;</span></span><br><span class="line">    someAddress.street <span class="operator">=</span> <span class="string">&quot;Acacia Road&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence<span class="operator">?</span>.address <span class="operator">=</span> createAddress()</span><br></pre></td></tr></table></figure>

<p>  没有任何打印消息，可以看出 <code>createAddress()</code> 函数并未被执行</p>
</li>
</ul>
<ul>
<li><p>除了访问属性，为属性赋值。还可以调用method</p>
<p>  假如调用的方法是有返回值的，会返回对应的optional类型。如果没有返回值，即返回<code>Void</code>类型，那么也会返回对应的<code>Void?</code>.对于无返回值类型的，可以判断是否等于<code>nil</code>。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence<span class="operator">?</span>.printNumberOfRooms() <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to print the number of rooms.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure>

<p>  通过可选链式调用给属性赋值会返回 <code>Void?</code>，通过判断返回值是否为 <code>nil</code> 就可以知道赋值是否成功：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence<span class="operator">?</span>.address <span class="operator">=</span> someAddress) <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was possible to set the address.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It was not possible to set the address.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印“It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="error-handling"><a href="#error-handling" class="headerlink" title="error handling"></a>error handling</h2><p>一般用枚举类型来标记一组错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">VendingMachineError</span>: <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> invalidSelection</span><br><span class="line">    <span class="keyword">case</span> insufficientFunds(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> outOfStock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再代码里用<code>throw</code>抛出一组错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>如下函数定义了跑出不同的错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">vend</span>(<span class="params">itemNamed</span> <span class="params">name</span>: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> item <span class="operator">=</span> inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.invalidSelection</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.outOfStock</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> item.price <span class="operator">&lt;=</span> coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price <span class="operator">-</span> coinsDeposited)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>调用这个函数时，也要写明try，因为这个函数有可能会抛出错误。嵌套有这个函数的函数，也要写明throw</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">buyFavoriteSnack</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">vendingMachine</span>: <span class="type">VendingMachine</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> snackName <span class="operator">=</span> favoriteSnacks[person] <span class="operator">??</span> <span class="string">&quot;Candy Bar&quot;</span></span><br><span class="line">    <span class="keyword">try</span> vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以使用do-catch来捕获并处理错误。如果一条 <code>catch</code> 子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为 <code>error</code>的局部常量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">3</span>, pattern <span class="number">4</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do-catch语句并不一定要处理所有的错误，如果是定义在有throw的函数里，可以继续把不能处理的错误向外传播。</p>
<p>将错误转化为optional类型，也就是转为nil。使用<code>try?</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someThrowingFunction</span>() <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> <span class="keyword">try?</span> someThrowingFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="keyword">try</span> someThrowingFunction()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    y <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x和y意义一致。使用<code>try?</code>调用可能会抛出错误的函数时，x的类型是返回值对应的optinal类型，这里是<code>Int?</code></p>
<h2 id="Nested-Types"><a href="#Nested-Types" class="headerlink" title="Nested Types"></a>Nested Types</h2><p>就是我们作业中，在结构体Model中，又定义了结构体Card。</p>
<p>类，枚举类型，结构体都可以进行嵌套。</p>
<h2 id="Extentions"><a href="#Extentions" class="headerlink" title="Extentions"></a>Extentions</h2><p><em>扩展</em>可以给一个现有的类，结构体，枚举，还有协议添加新的功能。</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加<strong>计算型</strong>实例属性和<strong>计算型</strong>类属性，注意不能定义存储属性</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使已经存在的类型遵循（conform）一个协议</li>
</ul>
<ul>
<li><p>添加计算属性</p>
<p>  因为Doube, Int等都是struct实现的，这里为Double添加了计算类型。</p>
<blockquote>
<p>extention里是可以访问到self的，甚至能<strong>访问private属性</strong></p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>

<p>  可以在浮点数字面量上，如<code>25.4</code>调用新的计算属性。当然也可以在字面常量或者变量上调用。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">25.4</span></span><br><span class="line">a.mm  <span class="comment">// 值为0.0254</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>扩展可以添加新的计算属性，但是它们不能添加存储属性，也不能向现有的属性添加属性观察者。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>扩展构造器</p>
<p>  extension可以提供一个新的便利构造器，但是不能提供一个指定构造器和析构器给一个类。指定构造器和析构器必须由原始的类实现。</p>
<p>  如果一个结构体没写构造器，但是你扩展了，这样不会覆盖默认的构造器和memberwise的构造器。你可以在自己写的构造器里调用他们。</p>
<p>  我举个自己的例子吧，可以在扩展的构造器里，利用<code>self</code>调用已有的初始化器。举的例子适用于结构体，不适用于类，假如是类，会出现指定的构造器的错。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">e</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        a <span class="operator">=</span> e <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">b</span>: <span class="type">Int</span>, <span class="params">c</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(e: <span class="number">15</span>)  <span class="comment">// 调用了已有的初始化器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp <span class="operator">=</span> <span class="type">Size</span>(b: <span class="number">1</span>, c: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp.a)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>  如果结构体没有自己定义的初始化器，还可以在extension的初始化器里，调用Default的和memberwise的构造器。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">b</span>: <span class="type">Int</span>, <span class="params">c</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp <span class="operator">=</span> <span class="type">Size</span>(b: <span class="number">1</span>, c: <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>扩展方法</p>
<p>  很简单的例子</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  可以在Int类型的字面量或者常量变量上调用</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p>  由于Int底层是struct，可以通过mutating方法来修改self</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">square</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 现在是 9</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>下标不熟，先跳过一下</li>
</ul>
<ul>
<li><p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型</p>
<p>  如下为Int添加新的枚举嵌套类型</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> negative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .negative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  通过计算属性kind，可以为Int类型变量提供枚举类型返回值</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">printIntegerKinds</span>(<span class="keyword">_</span> <span class="params">numbers</span>: [<span class="type">Int</span>]) &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .negative:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .zero:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0 &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> .positive:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;+ &quot;</span>, terminator: <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, <span class="operator">-</span><span class="number">27</span>, <span class="number">0</span>, <span class="operator">-</span><span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印“+ + - 0 - 0 + ”</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="Protocols"><a href="#Protocols" class="headerlink" title="Protocols"></a>Protocols</h2><p>属性，以及其他需要的东西。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。某个类型遵循协议，称为<em>conform</em>。</p>
<p>还能对协议进行拓展，也能对一个类型拓展，使它额外遵循某个协议。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>协议的定义，注意因为protocol也能看成是一种type，所以要==大写==命名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">	<span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类型可以遵循多个协议，可以用都喊分隔开来。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeStructure</span>: <span class="title class_">FirstProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">	<span class="comment">// 这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类有父类，因为要继承，要先写父类的名字再写协议的名字，还是用逗号分隔。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">FirstProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">	<span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="协议对属性的要求"><a href="#协议对属性的要求" class="headerlink" title="协议对属性的要求"></a>协议对属性的要求</h3><p>协议并不指明要求属性不要求属性是stored还是computated。</p>
<p>但他会要求是instance还是type，以及需要满足变量名name和type。还会要求满足set和get。</p>
<p>针对set get两种情况，<code>set get</code>可读可写，<code>set</code>可读。如果要求可读，但是实现时是可读可写也满足需求。</p>
<p>例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;  <span class="comment">// 可读可写</span></span><br><span class="line">	<span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>协议要求有type 属性。在类中实现时，也可以用class关键字代替static，以便可以被子类修改？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>举例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类型想要conform协议FullyNamed，需要有一个名字叫fullname的String类型变量，且满足可读。</p>
<p>实现，类型Person conforms 协议FullyNamed。这里使用了stored属性，使用computed属性也是可以的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">FullyNamed</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john <span class="operator">=</span> <span class="type">Person</span>(fullName: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// john.fullName 为 &quot;John Appleseed&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="协议对方法的要求"><a href="#协议对方法的要求" class="headerlink" title="协议对方法的要求"></a>协议对方法的要求</h3><p>同上，协议会要求方法是instance还是type的。会要求method的名字以及类型，会要求参数名，label名吗？但是<strong>不需要花括号以及方法的实现</strong>，不允许默认参数值</p>
<p>如下的例子，label名字必须一样，但是可以改parameter name。在这个例子里也就是，<code>from</code>和<code>to</code>必须一样，但是下面可以改成<code>c</code>和<code>d</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">RandomNum</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>(<span class="params">from</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">to</span> <span class="params">b</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>: <span class="title class_">RandomNum</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">random</span>(<span class="params">from</span> <span class="params">c</span>: <span class="type">Int</span>, <span class="params">to</span> <span class="params">d</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于结构体和枚举类型，如果协议期望的实现的方法需要改变值，需要加上mutating关键字。但是一个class conform这个协议，他实现这个方法时，不需要加上mutating</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OnOffSwitch</span>: <span class="title class_">Togglable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> off, on</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">toggle</span>() &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .off:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .on</span><br><span class="line">        <span class="keyword">case</span> .on:</span><br><span class="line">            <span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch <span class="operator">=</span> <span class="type">OnOffSwitch</span>.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .on</span></span><br></pre></td></tr></table></figure>



<h3 id="协议对构造器的要求"><a href="#协议对构造器的要求" class="headerlink" title="协议对构造器的要求"></a>协议对构造器的要求</h3><p>如下，只需要给出构造器名字init以及参数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 因为遵循协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h3><p>作为类型，要用大写字母开头命名</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<p>比如说，一个变量的类型是<code>RandomNumberGenerator</code>协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dice</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">sides</span>: <span class="type">Int</span>, <span class="params">generator</span>: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sides <span class="operator">=</span> sides</span><br><span class="line">        <span class="keyword">self</span>.generator <span class="operator">=</span> generator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">roll</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(generator.random() <span class="operator">*</span> <span class="type">Double</span>(sides)) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何实例只要conform这个<code>RandomNumberGenerator</code>协议，都可以赋给这个变量。并且由于其类型是 <code>RandomNumberGenerator</code>，所以在 <code>Dice</code> 类中与 <code>generator</code> 交互的代码，必须适用于所有遵循该协议的 <code>generator</code> 实例。<strong>这意味着不能使用由 <code>generator</code> 的底层类型定义的任何方法或属性。</strong>如果要是判断底层类型，可以用<code>is</code>吗？还有后面的as?有点记不清了</p>
<h3 id="委托delegation"><a href="#委托delegation" class="headerlink" title="委托delegation"></a>委托delegation</h3><p>大概意思就是说用协议来实现委托的设计模式。</p>
<h3 id="使用extension为类型添加拓展"><a href="#使用extension为类型添加拓展" class="headerlink" title="使用extension为类型添加拓展"></a>使用extension为类型添加拓展</h3><p>就是说，原来的类型可能没有遵循某一个协议，仍然可以通过extension来添加协议，注意扩展是可以访问到self的，实验过，即使是private变量也能访问到</p>
<p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。</p>
<blockquote>
<p>注意</p>
<p>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
</blockquote>
<p>通过扩展遵循并采纳协议，和在原始定义中遵循并符合协议的效果完全相同。</p>
<p>如，下面新的扩展</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以令Dice类遵循这个新的扩展</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Dice</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A <span class="subst">\(sides)</span>-sided dice&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>就是使用where语句</p>
<p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 <code>where</code> 分句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">TextRepresentable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="decalring-protocol-adoption-with-an-extension"><a href="#decalring-protocol-adoption-with-an-extension" class="headerlink" title="decalring protocol adoption with an extension"></a>decalring protocol adoption with an extension</h3><p>意思就是如果一个type已经满足了遵循一个protocol的条件（在这里是有了变量textualDescription），但是他却没有显示的声明要遵循这个协议。那么可以在extension中声明，却不需要在花括号里做任何的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hamster</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Hamster</span>: <span class="title class_">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>经过extension之后，Hamster已经conform这个协议TextRepresentable</p>
<h3 id="adopting-a-protocol-using-a-synthesized-implementation"><a href="#adopting-a-protocol-using-a-synthesized-implementation" class="headerlink" title="adopting a protocol using a synthesized implementation"></a>adopting a protocol using a synthesized implementation</h3><p>Swift 可以自动提供一些简单场景下遵循 <code>Equatable</code>、<code>Hashable</code> 和 <code>Comparable</code> 协议的实现。也就是说，只要满足条件，你只需遵循这几个协议，但是却不需要自己取实现。</p>
<p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p>
<ul>
<li>遵循 <code>Equatable</code> 协议且只有存储属性的结构体。（结构体中只有存储属性，且存储属性的）</li>
<li>遵循 <code>Equatable</code> 协议且只有关联类型的枚举</li>
<li>没有任何关联类型的枚举</li>
</ul>
<p>满足<code>Equatable</code>类型也就是可以使用<code>==</code>和<code>!=</code></p>
<p>如下结构体的存储属性，全都满足<code>Equatable</code>，所以直接conform这个协议就好</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;These two vectors are also equivalent.&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Hashable</code>和<code>Equatable</code>用的场景一样</p>
<p>Swift 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。</p>
<p>这个例子其实没太看到，有关联值可以比较能够理解，为什么没有值的case也能排序？？？好像是按照从上到下的顺序排的？有什么意义呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SkillLevel</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> beginner</span><br><span class="line">    <span class="keyword">case</span> intermediate</span><br><span class="line">    <span class="keyword">case</span> expert(stars: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> levels <span class="operator">=</span> [<span class="type">SkillLevel</span>.intermediate, <span class="type">SkillLevel</span>.beginner,</span><br><span class="line">              <span class="type">SkillLevel</span>.expert(stars: <span class="number">5</span>), <span class="type">SkillLevel</span>.expert(stars: <span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> levels.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(level)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;beginner&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;intermediate&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 3)&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 5)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h3><p>协议也可以在数组或者字典这样的集合中使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] <span class="operator">=</span> [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>

<p>就是只要instance满足协议类型，即可加入到集合中去。</p>
<h3 id="protocol-inheritance"><a href="#protocol-inheritance" class="headerlink" title="protocol inheritance"></a>protocol inheritance</h3><p>协议的继承和类的继承类似，但是可以继承一个或者多个协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">InheritingProtocol</span>: <span class="title class_">SomeProtocol</span>, <span class="title class_">AnotherProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// protocol definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如一个type遵循这个协议，同时也必须要遵循他的父协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">SnakesAndLadders</span>: <span class="title class_">PrettyTextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output <span class="operator">=</span> textualDescription <span class="operator">+</span> <span class="string">&quot;:<span class="subst">\n</span>&quot;</span>  <span class="comment">// 访问了父协议的属性？？</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder <span class="operator">&gt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▲ &quot;</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake <span class="operator">&lt;</span> <span class="number">0</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;▼ &quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output <span class="operator">+=</span> <span class="string">&quot;○ &quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrettyTextRepresentable，它继承自 <code>TextRepresentable</code> 协议。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。</p>
<h3 id="类专属协议class-only-protocols"><a href="#类专属协议class-only-protocols" class="headerlink" title="类专属协议class-only protocols"></a>类专属协议class-only protocols</h3><p>只能给类使用的协议，要继承一下<code>AnyObject</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_">AnyObject</span>, <span class="title class_">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="protocol-composition-协议组合"><a href="#protocol-composition-协议组合" class="headerlink" title="protocol composition 协议组合"></a>protocol composition 协议组合</h3><p>一个类型是可以遵循多个协议的，只需要用逗号分隔开就可以。协议组合的类型可以看成一个组合类型，使用 <code>SomeProtocol &amp; AnotherProtocol</code> 的形式。你可以列举任意数量的协议，用和符号（<code>&amp;</code>）分开。协议组合也能包含类类型，这允许你标明一个需要的父类。</p>
<p>例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Named</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>: <span class="title class_">Named</span>, <span class="title class_">Aged</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">wishHappyBirthday</span>(<span class="params">to</span> <span class="params">celebrator</span>: <span class="type">Named</span> &amp; <span class="type">Aged</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Happy birthday, <span class="subst">\(celebrator.name)</span>, you&#x27;re <span class="subst">\(celebrator.age)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Malcolm&quot;</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you&#x27;re 21!”</span></span><br></pre></td></tr></table></figure>

<p><code>Person</code> 结构体采纳了这两个协议。<code>wishHappyBirthday(to:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>Named &amp; Aged</code>， 这意味着“任何同时遵循 Named 和 Aged 的协议”。它不关心参数的具体类型，只要参数遵循这两个协议即可。</p>
<p>刚刚提到了协议组合也可以包含class类型，代表继承父类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> latitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> longitude: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.latitude <span class="operator">=</span> latitude</span><br><span class="line">        <span class="keyword">self</span>.longitude <span class="operator">=</span> longitude</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">City</span>: <span class="title class_">Location</span>, <span class="title class_">Named</span> &#123;  <span class="comment">// 继承同时遵循协议</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">latitude</span>: <span class="type">Double</span>, <span class="params">longitude</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(latitude: latitude, longitude: longitude)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">beginConcert</span>(<span class="params">in</span> <span class="params">location</span>: <span class="type">Location</span> &amp; <span class="type">Named</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(location.name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> seattle <span class="operator">=</span> <span class="type">City</span>(name: <span class="string">&quot;Seattle&quot;</span>, latitude: <span class="number">47.6</span>, longitude: <span class="operator">-</span><span class="number">122.3</span>)</span><br><span class="line">beginConcert(in: seattle)</span><br><span class="line"><span class="comment">// 打印 &quot;Hello, Seattle!&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>beginConcert(in:)</code> 函数接受一个类型为 <code>Location &amp; Named</code> 的参数，这意味着“任何 Location 的子类，并且遵循 Named 协议”。</p>
<h3 id="protocol-extension协议扩展"><a href="#protocol-extension协议扩展" class="headerlink" title="protocol extension协议扩展"></a>protocol extension协议扩展</h3><p>和上面对type扩展，使得type conforms新的协议不同。这里是对协议要求遵循的内容进行扩展。</p>
<p>扩展协议要同时把属性和方法实现了，不然怎么回到那些遵循协议的类型里去实现？</p>
<p>如下，值得注意的是，我可以再扩展协议里调用原有协议要求实现的方法或者属性，如下，调用了<code>random()</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">RandomNumberGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">randomBool</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() <span class="operator">&gt;</span> <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator <span class="operator">=</span> <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here&#x27;s a random number: <span class="subst">\(generator.random())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;Here&#x27;s a random number: 0.3746499199817101&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;And here&#x27;s a random Boolean: <span class="subst">\(generator.randomBool())</span>&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;And here&#x27;s a random Boolean: true&quot;</span></span><br></pre></td></tr></table></figure>



<p>你可以在协议扩展中，对协议要求的属性或者方法进行一个默认的实现。但是如果conforming type提供了自己的实现，就不会使用默认的实现。如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">PrettyTextRepresentable</span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为协议扩展添加限制"><a href="#为协议扩展添加限制" class="headerlink" title="为协议扩展添加限制"></a>为协议扩展添加限制</h3><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述</p>
<h2 id="generics"><a href="#generics" class="headerlink" title="generics"></a>generics</h2><p>以交换两个Int类型数举例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个函数同样使用于交换浮点数，字符串等，只需要改参数的类型。这样就重复写了代码。</p>
<p>使用泛型会更加合理</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">T</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意他们两的差异，一个是在函数名后加了<code>&lt;T&gt;</code>，然后后面参数类型type name变成了<code>T</code>。</p>
<p>调用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString <span class="operator">=</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> anotherString <span class="operator">=</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">swapTwoValues(<span class="operator">&amp;</span>someString, <span class="operator">&amp;</span>anotherString)</span><br><span class="line"><span class="comment">// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>



<p><code>T</code>叫做<code>type parameter</code>，尽量要使用大写，代表这是类型。它可以替代<em>参数类型，返回类型，也可以用在函数体内部</em></p>
<blockquote>
<p>you can use it to define the type of a function’s parameters (such as the <code>a</code> and <code>b</code>parameters of the <code>swapTwoValues(_:_:)</code> function), or as the function’s return type, or as a type annotation within the body of the function. </p>
</blockquote>
<p>你可以在尖括号内写多个<code>type parameters</code>，用逗号分开。如<code>Dictionary&lt;Key, Value&gt;</code></p>
<p>在结构体中使用泛型，如定义一个栈。使用<code>&lt;Element&gt;</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span>&lt;<span class="title class_">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Element</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">push</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Element</span>) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">pop</span>() -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="extending-a-generic-type扩展泛型"><a href="#extending-a-generic-type扩展泛型" class="headerlink" title="extending a generic type扩展泛型"></a>extending a generic type扩展泛型</h3><p>对泛型扩展时，并不需要列出定义时<code>&lt;T&gt;</code>（尖括号以及定义在里面的type parameter），但是仍然能在花括号里使用这些type parameter。</p>
<p>如下，扩展Stack，不需要写<code>&lt;Element&gt;</code>，但是仍然可以在花括号里使用<code>Element</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty <span class="operator">?</span> <span class="literal">nil</span> : items[items.count <span class="operator">-</span> <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="type-constarints"><a href="#type-constarints" class="headerlink" title="type constarints"></a>type constarints</h3><p>上文中提到的<code>swapTwoValues(_:_:)</code> function and the <code>Stack</code> 适用于任何类型。但是有些时候，需要加上一些<code>constaints</code>来使得类型继承自某个特定类，或者conform每个协议或者协议组合。</p>
<p>如在<code>Dictionary</code>中，要求<code>Key</code>必须得是<code>Hashable</code>的。如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunction</span>&lt;<span class="type">T</span>: <span class="type">SomeClass</span>, <span class="type">U</span>: <span class="type">SomeProtocol</span>&gt;(<span class="params">someT</span>: <span class="type">T</span>, <span class="params">someU</span>: <span class="type">U</span>) &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type parameter T要求继承类SomeClass，type parameter U要求conform SomeProtocol</p>
<p>我们先定义了一个在数组中寻找对应String，并返回下标的函数，并用泛型改写他。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>(<span class="params">ofString</span> <span class="params">valueToFind</span>: <span class="type">String</span>, <span class="params">in</span> <span class="params">array</span>: [<span class="type">String</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写成适用于任何类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;  <span class="comment">// 错</span></span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样有错误，我们不能保证T类型是可以使用<code>==</code>的。所以，要使得T conforms 协议<code>Equatable</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">of</span> <span class="params">valueToFind</span>: <span class="type">T</span>, <span class="params">in</span> <span class="params">array</span>:[<span class="type">T</span>]) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>关联类型associated value</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这应该相当于协议的泛型，写作<code>associatedtype</code></p>
</li>
</ul>
<ul>
<li><p>你可以在协议里给关联类型添加约束来要求遵循的类型满足约束。例如，下面的代码定义了 <code>Container</code> 协议， 要求关联类型 <code>Item</code> 必须遵循 <code>Equatable</code> 协议：</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">item</span>: <span class="type">Item</span>)</span><br><span class="line">    <span class="keyword">var</span> count: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="generic-where-clauses"><a href="#generic-where-clauses" class="headerlink" title="generic where clauses"></a>generic where clauses</h3><p>下次再记</p>
<h2 id="automatic-reference-counting"><a href="#automatic-reference-counting" class="headerlink" title="automatic reference counting"></a>automatic reference counting</h2><p>每当你创建一个新的<em>类实例</em>时，ARC 会分配一块内存来储存该实例的信息。内存中会包含实例的类型信息，以及这个实例所关联的任何stored properties的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>只要有类实例被引用，ARC就不会释放其在内存的空间。</p>
<blockquote>
<p>whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a <em>strong reference</em> to the instance.</p>
</blockquote>
<p>当你==assign==一个类实体给属性，常量变量。就会建立一个<code>strong inference</code>强引用。只要强引用存在，实例就不会被销毁。</p>
<p>例子，一个类Person</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being initialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个optional 类型，这时默认为nil，并不会指向实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>

<p>通过assign建立了一个强引用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being initialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果我们把这个引用，assgin给另两个optional类型，这样就有了三个强引用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 <span class="operator">=</span> reference1</span><br><span class="line">reference3 <span class="operator">=</span> reference1</span><br></pre></td></tr></table></figure>

<p>如果我们释放掉其中的两个引用，包括最开始的那个引用，Person实例并不会释放，因为还有一个强引用指向他</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">reference2 <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>把所有的强引用都释放了，系统会回收这个实例，调用析构函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="strong-reference-cycle"><a href="#strong-reference-cycle" class="headerlink" title="strong reference cycle"></a>strong reference cycle</h3><p>强引用圈通常两个类实例，互相持有对对方的强引用，这样资源就永远不能释放。</p>
<p>解决方法，不使用强引用，使用弱一点的<code>weak</code>和<code>unowned</code></p>
<p>强引用的例子</p>
<p>person实例有属性引用了apartment实例，aparment实例有属性引用了person实例。</p>
<p>![截屏2023-03-09 16.19.51](swift-programming-language笔记.assets/截屏2023-03-09 16.19.51.png)</p>
<p>这样就是把外面的指针john和unit4A释放掉（置为nil），互相之间的强引用还是存在。</p>
<p>![截屏2023-03-09 16.30.45](swift-programming-language笔记.assets/截屏2023-03-09 16.30.45.png)</p>
<h3 id="resolving-strong-reference"><a href="#resolving-strong-reference" class="headerlink" title="resolving strong reference"></a>resolving strong reference</h3><p>解决强引用的两个方式，<code>weak</code>reference和<code>unowned</code>reference。</p>
<blockquote>
<p>Weak and unowned references enable one instance in a reference cycle to refer to the other instance <em>without</em> keeping a strong hold on it. </p>
<p>Use a weak reference when the other instance has a shorter lifetime — that is, when the other instance can be deallocated first. </p>
<p>In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.</p>
</blockquote>
<p>使用<code>weak</code>引用，当一方有较短的生命期，一方可能会提前释放资源。对比，使用<code>unowned</code>引用，当双方生命期相同，或者更长的生命期。</p>
<ul>
<li><p>weak reference</p>
<p>  因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。==因此，ARC 会在引用的实例被销毁后自动将其弱引用赋值为 <code>nil</code>。==并且因为弱引用需要在运行时允许被赋值为 <code>nil</code>，所以它们会被定义为可选类型变量，而不是常量。</p>
<p>  apartment实例对person实例是弱引用，如果指向person实例的强引用销毁，就是john赋值nil，则weak引用自动置为nil.</p>
<p>  ![截屏2023-03-09 16.30.53](swift-programming-language笔记.assets/截屏2023-03-09 16.30.53.png)</p>
<p>  ![截屏2023-03-09 16.30.58](swift-programming-language笔记.assets/截屏2023-03-09 16.30.58.png)</p>
</li>
<li><p>Unowned reference</p>
<blockquote>
<p>Unlike a weak reference, an unowned reference is expected to always have a value. As a result, marking a value as unowned doesn’t make it optional, and ARC never sets an unowned reference’s value to <code>nil</code>.</p>
</blockquote>
<p>  一个无主引用<strong>总是期望有值。</strong>因此，无主引用不是optional，ARC也不会将其置为nil。</p>
<blockquote>
<p>Use an unowned reference only when you are sure that the reference <em>always</em> refers to an instance that hasn’t been deallocated.</p>
</blockquote>
<p>  <strong>使用无主引用，你<em>必须</em>确保引用始终指向一个未销毁的实例。</strong></p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CreditCard</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">number</span>: <span class="type">UInt64</span>, <span class="params">customer</span>: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number <span class="operator">=</span> number</span><br><span class="line">        <span class="keyword">self</span>.customer <span class="operator">=</span> customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Card #<span class="subst">\(number)</span> is being deinitialized&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以信用卡和客户为例子。信用卡总是用主人，因此有一个无主引用的属性<code>unowned let customer: Customer</code>。还要注意一点是，这里的构造函数，确保了信用卡只有主人才会传进来。</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br><span class="line"></span><br><span class="line">john <span class="operator">=</span> <span class="type">Customer</span>(name: <span class="string">&quot;John Appleseed&quot;</span>)</span><br><span class="line">john<span class="operator">!</span>.card <span class="operator">=</span> <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john<span class="operator">!</span>)</span><br></pre></td></tr></table></figure>

<p>  这样就建立了如下的引用关系</p>
<p>  ![截屏2023-03-09 16.41.41](swift-programming-language笔记.assets/截屏2023-03-09 16.41.41.png)</p>
<p>  注意接下来，如果把<code>john=nil</code>，就没有指向customer实体的强引用了，他将被释放。这样也没有强引用会指向creditcard实体了，==也会被释放。==（<em>这里是和weak 引用不同的地方</em>）</p>
<p>  ![截屏2023-03-09 16.44.23](swift-programming-language笔记.assets/截屏2023-03-09 16.44.23.png)</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints &quot;John Appleseed is being deinitialized&quot;</span></span><br><span class="line"><span class="comment">// Prints &quot;Card #1234567890123456 is being deinitialized&quot;</span></span><br></pre></td></tr></table></figure>

<p>  调用两个析构函数</p>
</li>
</ul>
<ul>
<li><p>unowned optional reference</p>
<p>  上面说的是非optional 类型的无主引用，这里是optional类型的。和weak类似？？但是，必须确保optional类型的无主引用总是指向有效的oject或者被设为nil（是指的是一直不变吗？）不懂。</p>
</li>
</ul>
<ul>
<li><p><code>Person</code> 和 <code>Apartment</code> 的例子展示了两个属性的值都允许为 <code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用==弱引用==来解决。</p>
<p>  <code>Customer</code> 和 <code>CreditCard</code> 的例子展示了一个属性的值允许为 <code>nil</code>，而另一个属性的值不允许为 <code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过==无主引用==来解决。</p>
</li>
</ul>
<ul>
<li><p>strong reference cycles for closure</p>
<p>  闭包的循环强引用</p>
<blockquote>
<p>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as <code>self.someProperty</code>, or because the closure calls a method on the instance, such as <code>self.someMethod()</code>. In either case, these accesses cause the closure to “capture” <code>self</code>, creating a strong reference cycle.</p>
</blockquote>
<p>  如果你给一个类intance属性assign了一个闭包。当，你访问了self属性，或者访问了self方法，那么你就捕获到了self，创建了一个循环强引用。</p>
<blockquote>
<p>This strong reference cycle occurs because closures, like classes, are <em>reference types</em>. When you assign a closure to a property, you are assigning a <em>reference</em> to that closure.</p>
</blockquote>
<p>  因为闭包也是引用类型。当你assign一个闭包给属性，你就分配了一个到闭包的引用。</p>
<p>  ![截屏2023-03-09 19.47.19](swift-programming-language笔记.assets/截屏2023-03-09 19.47.19.png)解决方法<code>cpature list</code>。</p>
<p>  在capture list里定义unowned引用以及weak引用和类实体里一样的含义。</p>
<blockquote>
<p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>
<p>Conversely, define a capture as a weak reference when the captured reference may become <code>nil</code> at some point in the future. Weak references are always of an optional type, and automatically become <code>nil</code> when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p>
</blockquote>
<p>  定义无主引用的方式</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> someClosure <span class="operator">=</span> &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate <span class="operator">=</span> <span class="keyword">self</span>.delegate]</span><br><span class="line">        (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  一般见到就是用一个方括号写在函数参数的定义之前<code>[weak self]</code></p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>samule
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://samulenzz.github.io/2023/03/14/swift-programming-language%E7%AC%94%E8%AE%B0/" title="swift programming language笔记">https://samulenzz.github.io/2023/03/14/swift-programming-language笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/05/self-captured-by-a-closure-before-all-members-were-initialized%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/" rel="prev" title="self captured by a closure before all members were initialized错误解决">
      <i class="fa fa-chevron-left"></i> self captured by a closure before all members were initialized错误解决
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" rel="next" title="回溯问题总结">
      回溯问题总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Basic"><span class="nav-number">1.</span> <span class="nav-text">The Basic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Operators"><span class="nav-number">2.</span> <span class="nav-text">Basic Operators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Strings-and-Characters"><span class="nav-number">3.</span> <span class="nav-text">Strings and Characters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-Types"><span class="nav-number">4.</span> <span class="nav-text">Collection Types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Control-Flow"><span class="nav-number">5.</span> <span class="nav-text">Control Flow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function"><span class="nav-number">6.</span> <span class="nav-text">function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Closures"><span class="nav-number">7.</span> <span class="nav-text">Closures</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enumerations"><span class="nav-number">8.</span> <span class="nav-text">Enumerations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Structures-and-Classes"><span class="nav-number">9.</span> <span class="nav-text">Structures and Classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties"><span class="nav-number">10.</span> <span class="nav-text">Properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Methods"><span class="nav-number">11.</span> <span class="nav-text">Methods</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subscripts"><span class="nav-number">12.</span> <span class="nav-text">subscripts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inheritance"><span class="nav-number">13.</span> <span class="nav-text">inheritance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Initialization"><span class="nav-number">14.</span> <span class="nav-text">Initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deinitialization"><span class="nav-number">15.</span> <span class="nav-text">deinitialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-Chaining"><span class="nav-number">16.</span> <span class="nav-text">Optional Chaining</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-handling"><span class="nav-number">17.</span> <span class="nav-text">error handling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nested-Types"><span class="nav-number">18.</span> <span class="nav-text">Nested Types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extentions"><span class="nav-number">19.</span> <span class="nav-text">Extentions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protocols"><span class="nav-number">20.</span> <span class="nav-text">Protocols</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">20.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%B1%9E%E6%80%A7%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">20.2.</span> <span class="nav-text">协议对属性的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">20.3.</span> <span class="nav-text">协议对方法的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">20.4.</span> <span class="nav-text">协议对构造器的要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.5.</span> <span class="nav-text">协议作为类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98delegation"><span class="nav-number">20.6.</span> <span class="nav-text">委托delegation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8extension%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%B7%BB%E5%8A%A0%E6%8B%93%E5%B1%95"><span class="nav-number">20.7.</span> <span class="nav-text">使用extension为类型添加拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E9%81%B5%E5%BE%AA%E5%8D%8F%E8%AE%AE"><span class="nav-number">20.8.</span> <span class="nav-text">有条件地遵循协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decalring-protocol-adoption-with-an-extension"><span class="nav-number">20.9.</span> <span class="nav-text">decalring protocol adoption with an extension</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adopting-a-protocol-using-a-synthesized-implementation"><span class="nav-number">20.10.</span> <span class="nav-text">adopting a protocol using a synthesized implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">20.11.</span> <span class="nav-text">协议类型的集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-inheritance"><span class="nav-number">20.12.</span> <span class="nav-text">protocol inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%93%E5%B1%9E%E5%8D%8F%E8%AE%AEclass-only-protocols"><span class="nav-number">20.13.</span> <span class="nav-text">类专属协议class-only protocols</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-composition-%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88"><span class="nav-number">20.14.</span> <span class="nav-text">protocol composition 协议组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protocol-extension%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95"><span class="nav-number">20.15.</span> <span class="nav-text">protocol extension协议扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95%E6%B7%BB%E5%8A%A0%E9%99%90%E5%88%B6"><span class="nav-number">20.16.</span> <span class="nav-text">为协议扩展添加限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#generics"><span class="nav-number">21.</span> <span class="nav-text">generics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#extending-a-generic-type%E6%89%A9%E5%B1%95%E6%B3%9B%E5%9E%8B"><span class="nav-number">21.1.</span> <span class="nav-text">extending a generic type扩展泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-constarints"><span class="nav-number">21.2.</span> <span class="nav-text">type constarints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#generic-where-clauses"><span class="nav-number">21.3.</span> <span class="nav-text">generic where clauses</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#automatic-reference-counting"><span class="nav-number">22.</span> <span class="nav-text">automatic reference counting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strong-reference-cycle"><span class="nav-number">22.1.</span> <span class="nav-text">strong reference cycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resolving-strong-reference"><span class="nav-number">22.2.</span> <span class="nav-text">resolving strong reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="samule"
      src="/images/baobao.jpg">
  <p class="site-author-name" itemprop="name">samule</p>
  <div class="site-description" itemprop="description">记录一点学习轨迹</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/samulenzz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;samulenzz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">samule</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>
